"Name of the exercise","Problem description","Problem solution (key points)","Methods used for solution","Code (solution.cpp)"
"Build the Sum","Given n ‚©æ1 integers a0, a1, . . . , an‚àí1, calculate the sum Pn‚àí1 i=0 ai. Input: The Ô¨Årst line of the input contains the number t ‚©Ω10 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains an integer n, denoting the number of integers to sum up, such that 0 ‚©Ωn ‚©Ω10. ‚Ä¢ The following line contains n integers a0 . . . an‚àí1, separated by a space, such that ‚àí1000 ‚©Ωai ‚©Ω1000, for every i ‚àà{0, . . . , n ‚àí1}. Output: For each test case output one line with a single integer that denotes the required sum.","Build the Sum - solution Trivial solution.","Implementation","#include <iostream>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    int sum = 0;
    for(int i = 0; i < n; i++){
      int a;
      std::cin>>a;

      sum += a;
    }

    std::cout<< sum << ""\n"";
  }
}
"
"Dominoes","Your task is to determine, given an arrangement of these tiles in a line, how many of the domino tiles will fall after toppling the left-most domino. More precisely, we have the following set-up: the dominoes are placed at successive points on the integer line, the Ô¨Årst at position 1, the second at 2, and so on. If a tile of height h at position i is toppled, this causes the tiles at all positions j > i such that j‚àíi < h to fall as well. Input: The Ô¨Årst line of the input contains the number t ‚©Ω10 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing an integer n denoting the number of dominoes (1 ‚©Ωn ‚©Ω 106). ‚Ä¢ The following line contains n integers h0 . . . hn‚àí1, separated by a space, where hi denotes the height of the domino placed at the (i + 1)-st position (1 ‚©Ωhi < 231). Output: For each test case output a single line that consists of a single integer denoting the number of domino tiles that will fall after toppling the left-most tile.","Dominoes - solution The key idea is to store the data about how many dominoes can be toppled from the current position.","Greedy / Linear scan","#include <iostream>
#include <algorithm>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    int topple_counter = -1;
    int dominoes = 0;
    for(int i = 0; i < n; i++){
      int h;
      std::cin>>h;

      //If a previous domino can topple this one, or if it's the first
      if(topple_counter != 0){
        topple_counter = std::max(topple_counter, h) - 1;
        dominoes++;
      }
    }

    std::cout<<dominoes<<""\n"";
  }
}
"
"Even Matrices","You are still part of a team to develop a pseudorandom number generator. Your generator has already passed some simple statistical tests, but now it is time to get serious. You arrange a list of bits produced by the generator in an n by n matrix. If M = Ô£´ Ô£¨ Ô£¨ Ô£¨ Ô£≠ x1,1 x1,2 x1,n x2,1 x2,2 ¬∑ ¬∑ ¬∑ x2,n ... ... xn,1 xn,2 xn,n Ô£∂ Ô£∑ Ô£∑ Ô£∑ Ô£∏ was a truly random matrix of bits, then it would have the property that the sum i2 X i‚Ä≤=i1 j2 X j‚Ä≤=j1 xi‚Ä≤,j‚Ä≤ is even for about half of the quadruples (i1, i2, j1, j2), 1 ‚©Ωi1 ‚©Ωi2 ‚©Ωn and 1 ‚©Ωj1 ‚©Ωj2 ‚©Ωn. To check whether this is the case for your generator, you need to be able to count the number of such quadruples. Input: The Ô¨Årst line of the input contains the number t ‚©Ω15 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains an integer n such that 1 ‚©Ωn ‚©Ω200. ‚Ä¢ This is followed by n lines, where the i-th line contains the n integers xi,1 . . . xi,n, separated by a space, such that xi,j ‚àà{0, 1}, for all i ‚àà{1, . . . , n} and j ‚àà{1, . . . , n}. Output: For each test case output a single line that contains the number of quadruples (i1, i2, j1, j2) where 1 ‚©Ωi1 ‚©Ωi2 ‚©Ωn and 1 ‚©Ωj1 ‚©Ωj2 ‚©Ωn and for which the sum i2 X i‚Ä≤=i1 j2 X j‚Ä≤=j1 xi‚Ä≤,j‚Ä≤ is even.","Even Matrices - solution It is easier to create a matrix with dimensions $(n+2) \times (n+2)$ to not have to deal with many edge cases. In this case, when a border element is accessed, adding or subtracting a zero does not make any difference. Firstly, it is necessary to save in the cell $(i,j)$ the partial sum of the sub-matrix $(0,i,0,j)$. After, it is possible to find the partial sums of the sub-matrices $(i1, i2, 0, j)$ through difference of partial sums $[(0, i2, 0, j) - (0, i1, 0, j)]$. At this point, for every pair $(i1, i2)$, it is...","Prefix sums / Parity counting","#include <iostream>
#include <vector>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<std::vector<int>> matrix(n+2, std::vector<int>(n+2, 0));
    for(int i = 1; i < n+1; i++){
      int par_sum = 0;
      for(int j = 1; j < n+1; j++){
        int x;
        std::cin>>x;

        par_sum += x;
        matrix[i][j] = matrix[i-1][j] + par_sum;
      }
    }

    int tot_even = 0;
    for(int i1 = 1; i1 < n+1; i1++){
      for(int i2 = i1+1; i2 < n+2; i2++){

        int even = 0;
        int odd = 0;
        for(int j = 1; j < n+1; j++){
          int sum = matrix[i2][j] - matrix[i1][j];

          if(sum % 2 == 0){
            even++;
          }else{
            odd++;
          }
        }

        tot_even += (even + even*(even-1)/2 + odd*(odd-1)/2);
      }
    }

    std::cout<<tot_even<<""\n"";
  }
}
"
"Even Pairs","You are part of a team to develop a new kind of pseudorandom number generator (PRNG). To gauge how good your algorithm is at producing random sequences of bits, you are running several diÔ¨Äerent statistical tests. For example, if x0, . . . , xn‚àí1 was a truly random sequence of bits, then it would have the property that the sum xi + ¬∑ ¬∑ ¬∑ + xj is even for about half of the pairs 0 ‚©Ωi ‚©Ωj < n (and odd for the other half). To check whether this is the case, if x0, . . . , xn‚àí1 are generated by your PRNG, you need to be able to count the number of pairs 0 ‚©Ωi ‚©Ωj < n for which the sum is even. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains an integer n, such that 1 ‚©Ωn ‚©Ω5 ¬∑ 104. ‚Ä¢ The following line contains n integers x0 . . . xn‚àí1, separated by a space, such that xi ‚àà{0, 1}, for all i ‚àà{0, . . . , n ‚àí1}. Output: For each test case output a single line containing the number of pairs 0 ‚©Ωi ‚©Ωj < n such that the sum xi + ¬∑ ¬∑ ¬∑ + xj is even.","Even Pairs - solution In order to minimize the number of loops necessary to find the solution, add each new value to a partial sum, and for each new value, increase the counter of the even partial sums or the odd partial sums. The final formula is: (even*(even-1))/2 + (odd*(odd-1))/2 + even.","Prefix sums / Parity counting","#include <iostream>

int main(){
  std::ios_base::sync_with_stdio(false);
  
  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;
    
    //Count how many even and odd partial sums are created
    int sum = 0;
    int evens = 0;
    int odds = 0;
    
    for(int i = 0; i < n; i++){
      int x;
      std::cin>>x;
      
      sum += x;
      
      if(sum % 2 == 0){
        evens++;
      }else{
        odds++;
      }
    }
    
    std::cout<< evens*(evens-1)/2 + odds*(odds-1)/2 + evens <<""\n"";
  }
}"
"Beach Bars","given by the distance along the beach from the parking lot in meters, using positive or negative numbers depending on whether the parasol is up or down the beach from the parking lot. With this data at hand, all that remains to do is to identify the best possible locations for your bar. For each point on the beach you can compute how many parasols are at most 100m away from it and pick out all points that maximize this number. However you quickly realize that this leads to a large number of locations. You then decide that you further want to minimize the maximum distance that any of your potential customers (i.e. those within 100m) must walk. Input: The Ô¨Årst line of the input contains the number t ‚©Ω40 of test cases. Each test case is described as follows.  It starts with a line that contains an integer n denoting the number of parasols, and such that 1 ‚©Ωn ‚©Ω106.  The next line contains n (not necessarily positive) integers x0 . . . xn‚àí1, separated by a space, denoting the coordinates of the parasols, with |xi| ‚©Ω106. You can assume that no two parasols have the same coordinates. Output: A location x on the beach can only have integer coordinates and is optimal if the number of parasols within 100m of it (i.e. with coordinates in [x ‚àí100, x + 100]) is maximal with respect to all other locations on the beach. If many locations maximize the number of parasols we only want those such that the distance to the farthest parasol at most 100m away is minimized. For each beach you have to print two lines. The Ô¨Årst line must contain the maximum number of parasols and the minimal longest distance as above. The second line should contain the coordinates of all possible optimal locations for your bar sorted from low to high.","Beach Bars - solution It is a sliding window problem, moving the bar position from one end to the other of the beach while counting the number of parasols and the maximum distance to a parasol inside the current window. It is necessary to save in a vector all the locations with the same best characteristics. The best location has the maximum amount of parasols with the minimum maximum walking distance. Given a new location, it replaces the old one if there are more parasols inside the window or, if the number of parasols inside the window is...","Two pointers / Sliding window","#include <iostream>
#include <vector>
#include <algorithm>

typedef struct{
  int dist;
  int num;
  std::vector<int> positions;
} solution_t;

void check_best(int dist, int num, int new_pos, solution_t &best){
  //More parasols than the previous best
  if(best.num < num){
    best = {dist, num, {new_pos}};

  //Less maximum distance than the previous best
  }else if(best.num == num && best.dist > dist){
    best = {dist, num, {new_pos}};

  //Same characteristics as the best
  }else if(best.num == num && best.dist == dist){
    best.positions.push_back(new_pos);
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<int> parasols(n);
    for(int i = 0; i < n; i++){
      int x;
      std::cin>>x;

      parasols[i] = x;
    }

    std::sort(parasols.begin(), parasols.end());

    //First parasol in the range on the left. Vector index
    int first_in = 0;
    //Last parasol in the rang on the right. Vector index
    int last_in = 0;

    //Bar position. Start where there is the first parasol on the left
    int bar_pos = parasols[0];

    //Best position info
    solution_t best = {0, 1, {parasols[0]}};

    //Current info
    int dist = 0;
    int num = 1;

    while(bar_pos < parasols[n-1]){

      //While new parasols can be included on the right
      while(last_in+1 < n && parasols[last_in+1] <= bar_pos+100){
        last_in++;
        num++;
      }

      //While parasols needs to be excluded on the left
      while(parasols[first_in] < bar_pos-100){
        first_in++;
        num--;
      }

      dist = std::max(std::abs(bar_pos-parasols[first_in]), std::abs(bar_pos-parasols[last_in]));
      check_best(dist, num, bar_pos, best);

      bar_pos++;
    }

    std::cout<<best.num<<"" ""<<best.dist<<""\n"";

    //Already sorted
    for(int pos: best.positions){
      std::cout<<pos<<"" "";
    }

    std::cout<<""\n"";
  }
}
"
"Burning Coins","given row of coins with corresponding values v1, v2, . . . , vn, you want to know what is the largest amount of money you are guaranteed to win if you manage to play optimally, assuming you start the game. (Independent of the strategy of your friend.) Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains one integer n denoting the number of coins used for the game, such that 1 ‚©Ωn ‚©Ω2500.  The following line contains n integers v0 . . . vn‚àí1, separated by a space, where vi denotes the value of the ith coin, and such that 1 ‚©Ωvi ‚©Ω1000. Output: For each test case output a single line with one integer denoting the largest amount you are guaranteed to win if you start the game.","Burning Coins - solution Each player (me and the rich guy) can do one of two things: take from the left or take from the right of the line of coins. During the game, the same configuration described by two indices $i$ and $j$ may present itself after different combinations of moves, but the pairs of indices $(i, j)$ are unique to each player. This means that, no matter the moves, a given pair $(i, j)$ always appears to the same player. This makes it possible to use only one DP table. For every new move, the main guy (me) needs to take the coin...","Dynamic Programming","#include <iostream>
#include <vector>
#include <algorithm>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

int solve(bool is_me, int i, int j, VVI &best, VI &values){
  if(i == j){  //Only one coin remaining
    if(is_me){
      best[i][j] = values[i];
      return best[i][j];
    }else{
      return 0;
    }
  }

  if(best[i][j] == -1){
    if(is_me){

      //Take a coin and remove it from the pile
      best[i][j] = std::max(solve(false, i+1, j, best, values) + values[i], solve(false, i, j-1, best, values) + values[j]);
    }else{

      //Just remove the coin
      best[i][j] = std::min(solve(true, i+1, j, best, values), solve(true, i, j-1, best, values));
    }
  }

  return best[i][j];
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<int> values(n);
    for(int i = 0; i < n; i++){
      int v;
      std::cin>>v;

      values[i] = v;
    }

    //best[i][j] contains the best winning value considering the coins between i and j included
    VVI best(n, VI(n, -1));

    solve(true, 0, n-1, best, values);

    std::cout<<best[0][n-1]<<""\n"";
  }
}
"
"Deck of Cards","given a deck of n custom made cards, denoted by 0, . . . , n ‚àí1 going from the top of the deck to the bottom. Each card i has a number vi which represents its value. You play a strange game with your younger brother, where he tells you his favorite number k and you need to Ô¨Ånd cards i and j such that i ‚©Ωj and Pj ‚Ñì=i v‚Ñì= k. Since you are older than your brother, you know that Ô¨Ånding such a subset of the deck won‚Äôt always be possible. Thus, you want to write a program which Ô¨Ånds two cards i and j such that the sum Pj ‚Ñì=i v‚Ñìis as close as possible to k. If there are multiple candidates for the solution, Ô¨Ånd the one which is lexicographically smallest. Input: The Ô¨Årst line of the input contains the number t ‚©Ω80 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains two integers n k, separated by a space, where n denotes the number of cards, and such that 1 ‚©Ωn ‚©Ω105 and 0 ‚©Ωk ‚©Ω230.  The following line deÔ¨Ånes the values of the cards 0 to n ‚àí1, in that order. It contains n integers v0 . . . vn‚àí1, separated by a space, and such that 0 ‚©Ωvi ‚©Ω230, for i ‚àà {0, . . . , n ‚àí1}. It is guaranteed that Pn‚àí1 i=0 vi ‚©Ω230. Output: A solution is a pair i, j of cards with i ‚©Ωj. We deÔ¨Åne the value of the solution i, j as val(i, j) := k ‚àí j X ‚Ñì=i v‚Ñì . For each test case output a single line containing two numbers i and j, separated by a space, corresponding to the solution i, j with the smallest value. If there are multiple such solutions, output the lexicographically smallest one. Note: (i, j) is lexicographically smaller than (i‚Ä≤, j‚Ä≤) iÔ¨Äi < i‚Ä≤ or i = i‚Ä≤ and j < j‚Ä≤.","Deck of Cards - solution Considering that the goal is to have the sum closest to $k$, if the current sum is too high, it's necessary to consider one less element. If it is too low, it's necessary to consider one more element. It is therefore necessary to use the sliding window technique, paying attention to the indices when near the end. Every time a new sum is calculated, it is necessary to see if it is the best choice of indices $i$ and $j$.","Two pointers / Sliding window","#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

typedef struct{
  int i;
  int j;
  long diff;
} solution_t;

//Due to how the deck is traversed, the current answer has the best indices
void update_best(solution_t &best, int i, int j, long diff){
  if(diff < best.diff){
    best = {i, j, diff};

  }else if(diff == best.diff){

    //Lexicografically smaller
    if(i < best.i){
      best = {i, j, diff};
    }else if(i == best.i && j < best.j){
      best = {i, j, diff};
    }
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, k;
    std::cin>>n>>k;

    std::vector<int> values(n);
    for(int i = 0; i < n; i++){
      int v;
      std::cin>>v;

      values[i] = v;
    }

    solution_t best = {-1, -1, INT_MAX};

    int from = 0, to = 0;
    long sum = values[0];

    //Sliding window
    while(from < n){

      if(sum == k){
        update_best(best, from, to, 0);

        if(to < n-1){
          sum += values[++to];
        }else{
          sum -= values[from++];
        }
      }

      if(sum < k && to < n-1){

        //Sum is too low, need to find indices with higher sum
        sum += values[++to];
        update_best(best, from, to, std::abs(k-sum));
      }else{

        //Sum is too high, need to find indices with lower sum
        sum -= values[from++];
        update_best(best, from, to, std::abs(k-sum));
      }
    }

    std::cout<<best.i<<"" ""<<best.j<<""\n"";
  }
}
"
"Lord Voldemort","Your task is to determine the maximum number of Horcruxes that can be destroyed by the other members of Dumbledore‚Äôs Army today. Apart from Harry, Ron and Hermione, there are m other members of Dumbledore‚Äôs Army, each of whom has k magical power left for today. Recall that Harry, Ron and Hermione have no magical power left for today. There are n Horcruxes, arranged in a straight line on the ground and indexed 0 through n ‚àí1 from left to right. The i-th Horcrux has vi amount of evil in it, which means that it takes vi magical power to be destroyed. Each member of Dumbledore‚Äôs Army must be assigned to destroy a non-empty contiguous sequence of Horcruxes, so as to liquidate them all by casting just one single spell. The total evil in the Horcruxes in any such sequence must be exactly k ‚Äî a member of Dumbledore‚Äôs Army has precisely k magical power for today, and their pride would not allow them to spend less than that. Again for reasons of honour and pride, all members of Dumbledore‚Äôs Army with remaining magical power for today must contribute, and no Horcrux can be assigned to more than one member. Your task is to design a strategy for destroying as many Horcruxes as possible today, complying with all the requirements outlined above. Formally, a permissible strategy is a choice of disjoint intervals [a0, b0], . . . , [am‚àí1, bm‚àí1] (where [ai, bi] is the segment of Horcruxes... Input: The Ô¨Årst line of the input contains the number t ‚©Ω300 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains three integers n m k, separated by a space. They denote 1 ‚Äì n, the number of Horcruxes (1 ‚©Ωn ‚©Ω105); ‚Äì m, the number of members of Dumbledore‚Äôs Army, other than Harry, Ron and Hermione (1 ‚©Ωm ‚©Ω100); ‚Äì k, the magical power that each member of Dumbledore‚Äôs Army, other than Harry, Ron and Hermione, has for today (1 ‚©Ωk < 109).  The following line deÔ¨Ånes the amount of evil in each Horcrux. It contains n integers v0 . . . vn‚àí1, separated by a space, and such that 1 ‚©Ωvi < 104, for all i ‚àà{0, . . . , n ‚àí1}. Here vi denotes the amount of evil in the i-th Horcrux. Output: For each test case output one line that contains either a single integer that denotes the maximum eÔ¨Äect of a permissible strategy, or the string fail, if no permissible strategy exists.","Lord Voldemort - solution In the first part of the problem, the sliding window technique is needed because a member can only destroy objects that are in sequence. When the sum inside a window is equal to $k$, the bounding positions should be saved (the number of objects destroyed can be determined from the bounding indices). The window should continue to slide because the best answer may contain windows that overlap with worse windows. Given $m$ people and $n$ objects, it is necessary to create the memoization array with $m+1$ rows and $n+1$...","Dynamic Programming","#include <iostream>
#include <vector>
#include <algorithm>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, k;
    std::cin>>n>>m>>k;  //n = objects, m = members, k = power

    VI evils(n);
    for(int i = 0; i < n; i++){
      int v;
      std::cin>>v;

      evils[i] = v;
    }

    //Sliding window to find all possible windows
    //windows[i] = j means that from point i there is a window until j included

    int low = 0;
    int high = 0;
    int sum = evils[0];
    VI windows(n, -1);

    while(low < n){
      if(sum == k){
        windows[low] = high;

        if(high < n-1){
          sum += evils[++high];
        }else{
          sum -= evils[low++];
        }
        continue;
      }

      if(sum < k && high < n-1){
        sum += evils[++high];
      }else{
        sum -= evils[low++];
      }
    }

    //dp[i][j] where i is the first new object encountered and j is the number of remaining members
    VVI dp(n+1, VI(m+1, -1));

    for(int i = 0; i < n; i++){
      dp[i][0] = 0;  //No members remaining
    }

    for(int i = 0; i <= m; i++){
      dp[n][i] = 0; //All objects destroyed
    }

    for(int i = n-1; i >= 0; i--){
      for(int j = 1; j <= m; j++){

        if(windows[i] != -1){  //If there is a window starting at i
          int w_end = windows[i];
          int objects = w_end - i + 1;

          //Skip the object or destroy the window
          dp[i][j] = std::max(dp[i+1][j], dp[w_end+1][j-1] + objects);
        }else{
          //No window starting at i, skip the current object
          dp[i][j] = dp[i+1][j];
        }
      }
    }

    //Check if each member destroyed at least one object
    bool change = true;
    for(int i = 1; i <= m; i++){
      if(dp[0][i-1] == dp[0][i]){
        change = false;
      }
    }

    if(!change){
      std::cout<<""fail\n"";
    }else{
      std::cout<<dp[0][m]<<""\n"";
    }
  }
}
"
"The Great Game","Given the board and the starting positions of the two meeples, your job is to determine who has a winning strategy. A player has a winning strategy, if he can win no matter how the other player plays. As the game cannot end in a draw, exactly one player has a winning strategy. Remark: The two meeples are allowed to be at the same position. Input: The Ô¨Årst line of the input contains the number t ‚©Ω200 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains two integers n m, separated by a space, and such that 2 ‚©Ωn ‚©Ω105 and 1 ‚©Ωm ‚©Ω2 ¬∑ 105. Here n denotes the number of positions on the table and m denotes the number of transitions.  The following line contains two integers r b, separated by a space, and such that 1 ‚©Ω r, b ‚©Ωn ‚àí1. Here r denotes the starting position of the red meeple and b denotes the starting position of the black meeple.  The following m lines deÔ¨Åne the m transitions. Each transition is deÔ¨Åned by two integers u v, separated by a space, and such that 1 ‚©Ωu < v ‚©Ωn, which indicates that there exists a transition from position u to position v. Between every pair of positions there is at most one transition. Output: For each test case output a single line with one character 0 or 1. For each test case output 0, if Sherlock has a winning strategy, and 1, if Moriarty has a winning strategy. 1","The Great Game - solution The same positions on the board can be reached after different combinations of moves, but the two players have different goals, which means that DP is needed. Holmes (0) wins if the **red** meeple reaches the end; Moriarty (1) wins if the **black** meeple reaches the end, which means that the best move for the two players in a given moment may not be the same. If a player needs to do the best move possible, he needs to minimize the number of steps to reach the goal, considering that, from the landing position, the...","Dynamic Programming","#include <iostream>
#include <vector>
#include <climits>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

int solve(int current, int n, VVI &transitions, VI &best, VI &worst, bool is_best){

  if(is_best){

    if(best[current] == INT_MAX){
      for(int out: transitions[current]){
        //Consider that, from the current position, the other player will do the worst move from the landing position
        best[current] = std::min(best[current], solve(out, n, transitions, best, worst, false)+1);
      }
    }
    return best[current];
  }else{

    if(worst[current] == -1){
      for(int out: transitions[current]){
        //Consider that, from the current position, the other player will do the best move from the landing position
        worst[current] = std::max(worst[current], solve(out, n, transitions, best, worst, true)+1);
      }
    }
    return worst[current];
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; //n = positions, m = transitions
    std::cin>>n>>m;

    int r, b; //Red and black meeples starting position
    std::cin>>r>>b;

    //Positions go from 1 to n included
    VVI transitions(n+1);
    for(int i = 0; i < m; i++){
      int u, v;
      std::cin>>u>>v;

      transitions[u].push_back(v);
    }

    //Best and worst number of steps to reach the end starting from position i
    VI best(n+1, INT_MAX);
    VI worst(n+1, -1);

    best[n] = 0;
    worst[n] = 0;

    solve(r, n, transitions, best, worst, true);
    solve(b, n, transitions, best, worst, true);

    std::cout<<best[r]<<"" ""<<best[b]<<""\n"";

    if(best[r] < best[b] || (best[r] == best[b] && best[r] % 2 == 1)){
      std::cout<<""0\n"";  //Red arrives first
    }else{
      std::cout<<""1\n"";  //Black arrives first
    }
  }
}
"
"Ant Challenge","Given a start tree and a Ô¨Ånish tree, you are to Ô¨Ånd the duration of the fastest route through the combined private networks of all species from start to Ô¨Ånish. The different species can alternate carrying the breadcrumb: every edge in the shortest path must be covered by at least one private network and if an edge is covered by multiple networks, you are free to choose the species that can travel the edge fastest for carrying along that edge. See the Ô¨Ågure below for an example with two species: both species need to take over parts of the shortest route. 1 Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a line that contains Ô¨Åve integers n e s a b, separated by a space, denoting ‚Äì n, the number of trees in the forest (1 ‚©Ωn ‚©Ω500). ‚Äì e, the number of edges in the connected, but not necessarily acyclic forest (1 ‚©Ωe ‚©Ω  n 2  ). ‚Äì s, the number of species living in the forest (1 ‚©Ωs ‚©Ω10). ‚Äì a and b, the (zero-based) indices specifying the start tree and Ô¨Ånish tree. ‚Ä¢ The next e lines each describe one edge of the forest: They are of the form t1 t2 w0 . . . ws‚àí1, meaning there is an edge between the two trees of (zero-based) indices t1 and t2 and that an insect of species i (zero-based) takes (integer) time wi, 0 ‚©Ωwi ‚©Ω105, to travel along that edge. ‚Ä¢ The last line contains the indices of the species‚Äô hives h0 h1 . . . hs‚àí1, separated by a space. Output: For every test case output a single line containing the time it will take the insects to transport the breadcrumb from start to Ô¨Ånish if they choose an optimal route.","Ant Challenge - solution Each connection between two trees may be taken by any species, meaning that, at the end, it does not matter who is doing the work. The given input edges with the relative weights are **ALL** the possible edges that can be used by the insects of each species, because there is always a way, even if long, for an insect to travel between two connected trees. It is necessary to find the minimum scanning trees of each of these graphs to find the different fast networks of each species (this is how the networks were created)....","Dijkstra / Shortest path","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/kruskal_min_spanning_tree.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
  boost::no_property, boost::property<boost::edge_weight_t, int>> graph;

typedef boost::property_map<graph, boost::edge_weight_t>::type weight_map;
typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, e, s, a, b;  //n = nodes, e = edges, s = species
    std::cin>>n>>e>>s>>a>>b;

    std::vector<graph> full_networks(s);
    std::vector<weight_map> weights(s);

    //Create the full graphs for all the networks of the different species
    for(int i = 0; i < s; i++){
      full_networks[i] = graph(n);
      weights[i] = boost::get(boost::edge_weight, full_networks[i]);
    }

    for(int i = 0; i < e; i++){
      int t1, t2;
      std::cin>>t1>>t2;

      for(int j = 0; j < s; j++){
        int w;
        std::cin>>w;

        edge_desc e = boost::add_edge(t1, t2, full_networks[j]).first;
        weights[j][e] = w;
      }
    }

    for(int i = 0; i < s; i++){
      int h;
      std::cin>>h;  //Useless
    }

    //Will contain the edges of all the fastest networks of the different species
    graph fast_network(n);
    weight_map fast_weights = boost::get(boost::edge_weight, fast_network);

    //Find the MST of each specie and add its edges to the final network
    for(int i = 0; i < s; i++){

      std::vector<edge_desc> mst;
      boost::kruskal_minimum_spanning_tree(full_networks[i], std::back_inserter(mst));

      for(auto it = mst.begin(); it != mst.end(); it++){
        int u = boost::source(*it, full_networks[i]);
        int v = boost::target(*it, full_networks[i]);

        edge_desc e = boost::add_edge(u, v, fast_network).first;
        fast_weights[e] = weights[i][*it];
      }
    }

    std::vector<int> dist_map(n);

    //Find the shortest path to the destination choosing edges from the fast networks of the different species
    boost::dijkstra_shortest_paths(fast_network, a,
      boost::distance_map(boost::make_iterator_property_map(
        dist_map.begin(), boost::get(boost::vertex_index, fast_network))));

    std::cout<<dist_map[b]<<""\n"";
  }
}
"
"Buddy Selection","Given a list of students and several characteristics per student, check whether there is a buddy assignment in which partners share more common characteristics than in the solution of Dr. Fuzzman. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a line that contains three integers n c f, separated by a space, denoting ‚Äì n, the (even) number of students (2 ‚©Ωn ‚©Ω400, n ‚â°0 mod 2). ‚Äì c, the number of characteristics per student (1 ‚©Ωc ‚©Ω100). ‚Äì f, the minimum number of common characteristics over all pairs of buddies in Dr. Fuzzman‚Äôs solution (f ‚©æ0). ‚Ä¢ The next n lines each describe the characteristics of one student: each student is described by c space separated keywords. Every keyword describes a characteristic. Each keyword consists of less than 20 lowercase letters and no two keywords for one student are the same. Output: For every testcase, if there is a buddy assignment in which all pairs of buddies share more than f characteristics, output not optimal, otherwise output optimal. Two characteristics are considered equal only if they have identical keywords.","Buddy Selection - solution It is necessary to find new connections with more than $f$ common hobbies. There may be different connections for each student, but it is necessary to find at least one possible set of pairs of students that includes all the students. To quickly check how many common hobbies two students have, it is possible to sort the arrays containing the hobbies and then check one by one the strings, increasing the pointing index in one array or the other (or both) depending on the lexographical order. This brings the...","Maximum Matching","#include <iostream>
#include <string>
#include <algorithm>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/max_cardinality_matching.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> graph;
typedef boost::graph_traits<graph>::vertex_descriptor vertex_desc;

typedef std::vector<std::string> VS;
typedef std::vector<VS> VVS;

void create_matches(int s1, int s2, int c, int f, VVS &hobbies, graph &G){
  int i1 = 0, i2 = 0;

  int match = 0;
  //Find the number of matching hobbies.
  //Make use of the fact that hobbies are ordered
  while(i1 < c && i2 < c){
    if(hobbies[s1][i1] == hobbies[s2][i2]){
      match++;
      i1++; i2++;
      continue;
    }

    if(hobbies[s1][i1] < hobbies[s2][i2]){
      i1++;
      continue;
    }

    if(hobbies[s1][i1] > hobbies[s2][i2]){
      i2++;
      continue;
    }
  }

  //Connect the two children if they have enough hobbies in common
  if(match > f){
    boost::add_edge(s1, s2, G);
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, c, f;  //n = students, c = characteristics, f = common
    std::cin>>n>>c>>f;

    VVS hobbies(n, VS(c));
    for(int i = 0; i < n; i++){
      for(int j = 0; j < c; j++){
        std::string s;
        std::cin>>s;

        hobbies[i][j] = s;
      }

      //Speed-up search by ordering the hobbies of each child
      std::sort(hobbies[i].begin(), hobbies[i].end());
    }

    graph G(n);

    for(int i = 0; i < n; i++){
      for(int j = i+1; j < n; j++){
        create_matches(i, j, c, f, hobbies, G);
      }
    }

    //Find if it's possible to create pairs for all the children
    std::vector<vertex_desc> mate_map(n);
    boost::edmonds_maximum_cardinality_matching(G,
      boost::make_iterator_property_map(mate_map.begin(), boost::get(boost::vertex_index, G)));

    int matching_size = boost::matching_size(G,
      boost::make_iterator_property_map(mate_map.begin(), boost::get(boost::vertex_index, G)));

    if(matching_size == n/2){
      std::cout<<""not optimal\n"";
    }else{
      std::cout<<""optimal\n"";
    }
  }
}
"
"First steps with BGL","Read a weighted undirected graph, compute the total weight of its minimum spanning tree and the distance from node 0 to a node furthest from it. Input: The Ô¨Årst line of the input Ô¨Åle contains t ‚©Ω100, the number of test cases. Each test case starts with a line containing n ‚©Ω100, m ‚©Ωn¬∑(n‚àí1) 2 , the number of vertices and edges of the graph. m lines follow, each deÔ¨Åning the two endpoints and weight of an edge. All weights are non-negative integers and at most 1000. The input graph is guaranteed to be connected. Output: For each test case output a single line containing w, the sum of weights of all edges of a minimum spanning tree, and d, the distance from node 0 to a node furthest from it.","First steps with BGL - solution Trivial solution.","Dijkstra / Shortest path","#include <iostream>
#include <vector>
#include <algorithm>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/kruskal_min_spanning_tree.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
  boost::no_property, boost::property<boost::edge_weight_t, int>> graph;

typedef boost::property_map<graph, boost::edge_weight_t>::type weight_map;
typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;  //n = nodes, m = edges
    std::cin>>n>>m;

    graph G(n);
    weight_map weights = boost::get(boost::edge_weight, G);

    for(int i = 0; i < m; i++){
      int u, v, w;
      std::cin>>u>>v>>w;

      edge_desc e = boost::add_edge(u, v, G).first;
      weights[e] = w;
    }

    std::vector<edge_desc> mst;
    boost::kruskal_minimum_spanning_tree(G, std::back_inserter(mst));

    int sum = 0;
    for (auto it = mst.begin(); it != mst.end(); it++) {
      sum += weights[*it];
    }

    std::vector<int> dist_map(n);
    boost::dijkstra_shortest_paths(G, 0,
      boost::distance_map(boost::make_iterator_property_map(
        dist_map.begin(), boost::get(boost::vertex_index, G))));

    int max_d = -1;
    for(int i = 0; i < n; i++){
      max_d = std::max(max_d, dist_map[i]);
    }

    std::cout<<sum<<"" ""<<max_d<<""\n"";
  }
}
"
"Important Bridges","Scatteredalot is a small country, that consists of many inhabited islands connected with bidi- rectional bridges, so that you can get from any island to any other (possibly using several bridges). Every bridge connects two different islands and for any pair of islands there is at most one bridge that connects them. Of course it happens from time to time that one of these bridges has to be repaired and the Scatterlotian people cannot use it during this time. Usually this is not a problem because there are so many bridges that most of the times they can use another path leading to the same destination they are heading to. Unfortunately this is not always the case. If repairing a single bridge causes some two islands to be inaccesible from each other, we will call such a bridge critical. Scatteredalot‚Äôs prime minister, who would like to be re-elected, asks you to Ô¨Ånd all critical bridges. Can you help him? Input: The Ô¨Årst line of the input Ô¨Åle will contain an integer giving the number c ‚©Ω30 of test cases following. Each test case starts with a line containing n, the number of islands and m, the number of bridges (0 ‚©Ωn ‚©Ω3¬∑104, 0 ‚©Ωm ‚©Ω3¬∑104). After that, you will Ô¨Ånd m lines, the i-th of them con- taining two space-separated integers ei1 ei2, with 0 ‚©Ωei1, ei2 < n and ei1 Ã∏= ei2, describing the numbers of the two islands that the i-th bridge connects (the islands are numbered from 0 to n ‚àí1). You will never Ô¨Ånd two bridges connecting the same pair of islands. Output: For each test case write Ô¨Årst k, the amount of critical bridges, in a single line, followed by k lines containing the island numbers ei1ei2 that the i-th critical bridge connects. Please make sure that the list of bridges is ordered in such a way that ei1 is always smaller then ei2, and that for all i, j with i < j holds that ei1 ‚©Ωej1 and if ei1 = ej1 then also ei2 < ej2. (Which means that the output should be ordered lexicographically.) In this way, it will be easier for the prime minister to check the list you have created.","Important Bridges - solution A _biconnected graph_ is a connected and ""nonseparable"" graph, meaning that if any one vertex were to be removed, the graph would remain connected. A graph with only two vertices connected by an edge is still biconnected because, by removing one node, the remaining node will be connected to the rest of the graph (that is, itself). A _biconnected component_ is a maximal biconnected graph. The function defined in include <boost/graph/biconnected_components.hpp> can be used to find all the biconnected components in a...","Biconnected components / Bridges","#include <iostream>
#include <vector>
#include <set>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/biconnected_components.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS,
  boost::no_property, boost::property<boost::edge_name_t, int>> graph;

typedef boost::property_map<graph, boost::edge_name_t>::type component_map;
typedef boost::graph_traits<graph>::edge_iterator edge_it;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;
    std::cin>>n>>m;

    graph G(n);

    for(int i = 0; i < m; i++){
      int u, v;
      std::cin>>u>>v;

      boost::add_edge(u, v, G);
    }

    component_map component = boost::get(boost::edge_name, G);
    int num_comps = boost::biconnected_components(G, component);

    //Find how many bridges there are in each biconnected component
    std::vector<int> num_bridges(num_comps, 0);
    edge_it ei, ei_end;
    for (boost::tie(ei, ei_end) = boost::edges(G); ei != ei_end; ei++){
      num_bridges[component[*ei]]++;
    }

    //Important bridges in biconnected components of size 1
    int important_bridges = std::count(num_bridges.begin(), num_bridges.end(), 1);
    std::cout<<important_bridges<<""\n"";

    //Find and order the important bridges
    std::set<std::pair<int, int>> imp;
    for (boost::tie(ei, ei_end) = boost::edges(G); ei != ei_end; ei++){
     bool is_important = (num_bridges[component[*ei]] == 1);

     int u = std::min(boost::source(*ei, G), boost::target(*ei, G));
     int v = std::max(boost::source(*ei, G), boost::target(*ei, G));

     if(is_important){
      imp.insert({u, v});
     }
    }

    for(auto e: imp){
      std::cout<<e.first<<"" ""<<e.second<<""\n"";
    }
  }
}
"
"James Bond's sovereigns","Given an integer k ‚àà{0, . . . , m‚àí1}, you have to Ô¨Ånd the largest possible winnings that passenger pk can collect regardless of how other passengers play. Notice that the word ‚Äòregardless‚Äô implies that you cannot make any assumption of what the other passengers do. In particular, they may not play to maximise their own winnings. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains three integers n m k, separated by a space. They denote ‚Äì n, the number of sovereigns (1 ‚©Ωn ‚©Ω2 ¬∑ 103); ‚Äì m, the number of passengers (1 ‚©Ωm ‚©Ω5 ¬∑ 102); ‚Äì k, the index of the passenger whose winnings you are interested in (0 ‚©Ωk ‚©Ωm ‚àí1).  The following line deÔ¨Ånes the value of the sovereigns in pounds. It contains n integers x0 . . . xn‚àí1, separated by a space, and such that 0 ‚©Ωxi ‚©Ω210, for i ‚àà{0, . . . , n ‚àí1}. Output: For each test case the corresponding output appears on a separate line. It consists of one integer w which denotes the largest winnings that passenger pk can collect, regardless of how other passengers play. 1","James Bond's sovereigns For each possible coin configuration, the player $k$ takes the coin that will make it the most amount of money, while the other players take the coin that will make the player $k$ make the least amount of money. The fact that it says _regardless_ means that it's the maximum amount of money that could be made by the player $k$ in the worst-case scenario where all other players play against him. In the base case, if there is only one coin left, the value to store is 0 if the last player is not $k$, and it's the single...","Dynamic Programming","#include <iostream>
#include <vector>
#include <algorithm>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

int solve(int i, int j, int k, int m, int turn, VI &coins, VVI &dp){
  if(i == j){  //Only one coin left
    if(turn%m == k){
      dp[i][j] = coins[i];
    }else{
      dp[i][j] = 0;
    }
    return dp[i][j];
  }

  if(dp[i][j] == -1){
    if(turn%m == k){
      //Maximize the points
      dp[i][j] = std::max(solve(i+1, j, k, m, turn+1, coins, dp) + coins[i], solve(i, j-1, k, m, turn+1, coins, dp) + coins[j]);
    }else{
      //Minimize the points for the player k
      dp[i][j] = std::min(solve(i+1, j, k, m, turn+1, coins, dp), solve(i, j-1, k, m, turn+1, coins, dp));
    }
  }

  return dp[i][j];
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, k;  //n = coins, m = passengers, k = player index
    std::cin>>n>>m>>k;

    VI coins(n);
    for(int i = 0; i < n; i++){
      int x;
      std::cin>>x;

      coins[i] = x;
    }

    //dp[i][j] contains the maximum amount of points the player k can have
    //if the coins from i to j included are considered
    VVI dp(n, VI(n, -1));
    solve(0, n-1, k, m, 0, coins, dp);

    std::cout<<dp[0][n-1]<<""\n"";
  }
}
"
"Antenna","After the invention of radio, Theirland wants to demonstrate its technological superiority and builds a Ô¨Årst radio transmitter. The transmitter must cover the whole population. It is char- acterized by a location and a transmission radius (within which a reception of the signal is guaranteed). Not surprisingly, transmitters with a higher radius require more advanced tech- nology and more time to build and‚Äîlast but not least‚Äîthey cost much more. Thus, the government decided to Ô¨Ånd a location where the transmission radius is as small as possible, but every single citizen can receive the signal at home. This is not an easy goal to achieve, though. . . Input: The input contains several test cases. Each of them begins with a line containing one integer n (1 ‚©Ωn ‚©Ω200‚Ä≤000), denoting the number of citizens. The next n lines contain coordinates xi yi of homes of citizens (xi, yi integral with |xi|, |yi| < 248). All numbers on a single line are separated by a single space. The input is terminated by a single line containing 0 (i.e., an empty testcase). Output: For each input, write on a single line the smallest integral transmission radius needed to cover all citizens.","Antenna - solution Trivial solution.","Computational Geometry (CGAL)","#include <iostream>
#include <vector>

#include <CGAL/Exact_predicates_exact_constructions_kernel_with_sqrt.h>
#include <CGAL/Min_circle_2.h>
#include <CGAL/Min_circle_2_traits_2.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel_with_sqrt K;
typedef CGAL::Min_circle_2_traits_2<K> Traits;
typedef CGAL::Min_circle_2<Traits> Min_circle;

typedef K::Point_2 P;

long ceil_to_long(K::FT x){
  double a = std::floor(CGAL::to_double(x));
  while (a < x) a += 1;
  while (a-1 >= x) a -= 1;
  return a;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    std::vector<P> points(n);
    for(int i = 0; i < n; i++){
      long x, y;
      std::cin>>x>>y;

      points[i] = P(x, y);
    }

    Min_circle mc(points.begin(), points.end(), true);
    Traits::Circle c = mc.circle();

    std::cout<<ceil_to_long(CGAL::sqrt(c.squared_radius()))<<""\n"";
  }
}
"
"First Hit","A laser source shot Phileas Photon into some direction. How far will he have to travel? Where will he end up? The scenery is considered as seen from above, such that obstacle walls appear as line segments and the trajectory of Phileas is described by a ray. Input: The input Ô¨Åle consists of several test cases. Each of them starts with a line containing one integer n (1 ‚©Ωn ‚©Ω30‚Ä≤000). The following line describes the ray along which Phileas travels. It contains integers x y a b where (x, y) are the coordinates of the starting point of the ray and (a, b) Ã∏= (x, y) is another point on the ray. The following n lines describe an obstacle line segment each. The i-th of these lines contains four integers r s t u, where (r, s) and (t, u) are the endpoints of the i-th segment. All the above coordinates are integers that are in absolute value smaller than 251. All numbers on a line are separated by a single space. The input is terminated by a single line containing 0 (i.e., an empty testcase). Output: The output for each testcase appears on a separate line. This line contains the coor- dinates of the Ô¨Årst intersection of the ray with any obstacle segment1, where both coordinates are rounded2 down to the next integer. If there is no such intersection, the line consists of the word no.","First hit - solution To reduce the number of constructions to make, it's better to check if an intersection between the ray and the currently considered segment even exists. In the event that the intersection between the ray and a segment is the segment itself, it's necessary to check which one of the two points of the segment is closer to the starting point of the ray. Always using the starting ray would be too slow for the last test set. This is because, even if a closer intersection point is found, the ray would continue to consider the...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <algorithm>

#include <CGAL/Exact_predicates_exact_constructions_kernel.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef K::Ray_2 R;
typedef K::Point_2 P;
typedef K::Segment_2 S;

long floor_to_long(const K::FT& x){
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return a;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    long x, y, a, b;
    std::cin>>x>>y>>a>>b;

    R ray(P(x, y), P(a, b));

    std::vector<S> segments(n);
    for(int i = 0; i < n; i++){
      long r, s, t, u;
      std::cin>>r>>s>>t>>u;

      segments[i] = S(P(r, s), P(t, u));
    }

    //Shuffle the input segments to avoid the worst case
    std::random_shuffle(segments.begin(), segments.end());

    bool first_intersection = false;
    S segment_ray;

    for(int i = 0; i < n; i++){
      //Use the ray until an intersection is found
      if(!first_intersection && CGAL::do_intersect(ray, segments[i])){

        auto o = CGAL::intersection(ray, segments[i]);

        //Create a segment to make the ray smaller
        if (const P* op = boost::get<P>(&*o)){
          segment_ray = S(P(x, y), *op);

        }else if (const S* os = boost::get<S>(&*o)){
          //If the intersection is an entire segment, find which one of the points of the segment is closer
          K::FT d_source = CGAL::squared_distance(os->source(), P(x, y));
          K::FT d_target = CGAL::squared_distance(os->target(), P(x, y));

          if(d_source < d_target){
            segment_ray = S(P(x, y), os->source());
          }else{
            segment_ray = S(P(x, y), os->target());
          }
        }
        first_intersection = true;
      }else if(first_intersection && CGAL::do_intersect(segment_ray, segments[i])){
        //Use the smaller segment to find intersections
        auto o = CGAL::intersection(segment_ray, segments[i]);

        //Decrease the size of the segment
        if (const P* op = boost::get<P>(&*o)){
          segment_ray = S(P(x, y), *op);

        }else if (const S* os = boost::get<S>(&*o)){
          K::FT d_source = CGAL::squared_distance(os->source(), P(x, y));
          K::FT d_target = CGAL::squared_distance(os->target(), P(x, y));

          if(d_source < d_target){
            segment_ray = S(P(x, y), os->source());
          }else{
            segment_ray = S(P(x, y), os->target());
          }
        }
      }
    }

    if(!first_intersection){
      std::cout<<""no\n"";
    }else{
      P point = segment_ray.target();
      std::cout<<floor_to_long(point.x())<<"" ""<<floor_to_long(point.y())<<""\n"";
    }
  }
}
"
"Hiking Maps","Alice and Bob want to go for a hike. They have carefully planned a scenic route for a full-day trip and now they are looking for a map of the region that they can use to navigate. It turns out that this is not as easy as thought: Instead of a single large map, the publisher decided to oÔ¨Äer a large number of small triangular parts. Each of these parts is cheap to buy, but because they are so small, Alice and Bob need to buy lots of parts to cover the region for their trip. Thankfully there is an option to bulk-purchase parts. But the choices are limited: The map parts are numbered t0, . . . , tn‚àí1, and you can select b, e ‚àà{0, . . . , n} to bulk-purchase for e ‚àíb CHF all of tb, tb+1, . . . , te‚àí1. So Alice and Bob decide that they will purchase one single such sequence. Other than costs Alice and Bob are also concerned with practical aspects. They have to change between map parts during their trip, but at least every single leg of their hike should be contained on a single map part. Fortunately that appears to be possible. How many map parts should they buy? Input: The Ô¨Årst line of the input contains the number c ‚©Ω60 of test cases. Each of the following c test cases is described as follows. ‚Ä¢ It starts with a line that contains two integers m n (2 ‚©Ωm, n ‚©Ω2‚Ä≤000), separated by a space. Here m ‚àí1 denotes the number of legs on their hike and n denotes the number of map parts available. ‚Ä¢ The following m lines describe the hiking path p0, . . . , pm‚àí1. Each pi is deÔ¨Åned by two integer coordinates x y, separated by a space and so that |x|, |y| < 231. The hiking path is formed by the m ‚àí1 legs pi, pi+1, for i ‚àà{0, . . . , m ‚àí2}, each of which we model as a straight path from pi to pi+1. ‚Ä¢ The Ô¨Ånal n lines describe the map parts t0, . . . , tn‚àí1. Each part is a triangle t that is deÔ¨Åned by six pairwise distinct points q0, . . . , q5 as follows: The pair q0, q1 lies on the Ô¨Årst edge, the pair q2, q3 lies on the second edge, and the pair q4, q5 lies on the third edge of t. None of q0, . . . , q5 is a vertex of t, that is, all points lie in the relative... Output: For every test case the corresponding output appears on a separate line. It consists of the minimum costs k in CHF that are needed to cover the whole hiking path. In other words, there are some b, e ‚àà{0, . . . , n} with k = e ‚àíb such that the path p0, . . . , pm‚àí1 is covered by the map Se‚àí1 i=b ti and such that each leg pi‚àí1pi, for i ‚àà{1, . . . , m ‚àí1}, is completely contained in at least one tj, for j ‚àà{b, . . . , e ‚àí1}. 1","Hiking Maps - solution The map parts that need to be purchased are chosen in such a way that a leg of the hike is completely contained in at least one map part, so there is no need to worry about partial coverage of some legs. For every pair of points lying on a side of the triangle, it is necessary to create a line. With the resulting three lines, it is possible to construct the intersections between them that are the vertices of the triangle. The most intuitive way to know if a point is contained inside a triangle would be to use...","Two pointers / Sliding window","#include <iostream>
#include <vector>
#include <algorithm>

#include <CGAL/Exact_predicates_exact_constructions_kernel.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel K;
typedef K::Point_2 P;
typedef K::Line_2 L;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int m, n; //m-1 = legs, n = map parts
    std::cin>>m>>n;

    std::vector<P> points(m);
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      points[i] = P(x, y);
    }

    //Store which legs each map part contains
    //A leg is identified by the index of its first poin
    std::vector<std::vector<int>> contained_segments(n);
    for(int i = 0; i < n; i++){
      int a, b, c, d;
      std::cin>>a>>b>>c>>d;
      L side1 = L(P(a, b), P(c, d));

      std::cin>>a>>b>>c>>d;
      L side2 = L(P(a, b), P(c, d));

      std::cin>>a>>b>>c>>d;
      L side3 = L(P(a, b), P(c, d));

      //Find the vertices of the triangle parts
      auto o1 = CGAL::intersection(side1, side2);
      P* v1 = boost::get<P>(&*o1);

      auto o2 = CGAL::intersection(side2, side3);
      P* v2 = boost::get<P>(&*o2);

      auto o3 = CGAL::intersection(side3, side1);
      P* v3 = boost::get<P>(&*o3);

      //Check which single points are inside the map part
      std::vector<bool> contains(m, false);
      for(int j = 0; j < m; j++){
        int or1 = CGAL::orientation(*v1, *v2, points[j]);
        int or2 = CGAL::orientation(*v2, *v3, points[j]);
        int or3 = CGAL::orientation(*v3, *v1, points[j]);

        if((or1 <= 0 && or2 <= 0 && or3 <= 0) ||
          (or1 >= 0 && or2 >= 0 && or3 >= 0)){
            contains[j] = true;
          }
      }

      for(int j = 0; j < m-1; j++){
        if(contains[j] && contains[j+1]){
          contained_segments[i].push_back(j);
        }
      }
    }

    //Count how many map parts that are currently considered contain a certain leg
    std::vector<int> in_map(m-1, 0);
    int tot_segments = 0;
    int low = 0;
    int high = 0;

    //Insert the legs of the first map part
    for(int leg: contained_segments[0]){
      in_map[leg]++;
      tot_segments++;
    }

    //Sliding window to find the minimum number of map parts to use
    int min_maps = n;
    while(low <= high){
      if(tot_segments == m-1){
        min_maps = std::min(min_maps, high-low+1);

        for(int leg: contained_segments[low]){
          in_map[leg]--;
          if(in_map[leg] == 0){
            tot_segments--;
          }
        }
        low++;
        continue;
      }

      if(tot_segments < m-1 && high < n-1){
        high++;
        for(int leg: contained_segments[high]){
          in_map[leg]++;
          if(in_map[leg] == 1){
            tot_segments++;
          }
        }
      }else{
        for(int leg: contained_segments[low]){
          in_map[leg]--;
          if(in_map[leg] == 0){
            tot_segments--;
          }
        }
        low++;
      }
    }

    std::cout<<min_maps<<""\n"";
  }
}
"
"Hit","A laser source shot Phileas Photon into some direction. Will he stop at an obstacle or travel to inÔ¨Ånity? The scenery is considered as seen from above, such that obstacle walls appear as line segments and the trajectory of Phileas is described by a ray. Input: The input Ô¨Åle consists of several test cases. Each of them starts with a line containing one integer n (1 ‚©Ωn ‚©Ω20‚Ä≤000). The following line describes the ray along which Phileas travels. It contains integers x y a b where (x, y) are the coordinates of the starting point of the ray and (a, b) Ã∏= (x, y) is another point on the ray. The following n lines describe an obstacle line segment each. The i-th of these lines contains four integers r s t u, where (r, s) and (t, u) are the endpoints of the i-th segment. All the above coordinates are integers that are in absolute value smaller than 251. In particular, you cannot represent them using a 32-bit integer data type in general. All numbers on a single line are separated by a single space. The input is terminated by a single line containing 0 (i.e., an empty testcase). Output: The output for each testcase appears on a separate line. The line consists of the word yes, if the ray hits an obstacle1 and no, otherwise.","Hit - solution Only checking for an intersection does not require construction, so the inexact kernel is enough. It's necessary to read the coordinates as long.","Computational Geometry (CGAL)","#include <iostream>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel EPIC;
typedef EPIC::Segment_2 S;
typedef EPIC::Ray_2 R;
typedef EPIC::Point_2 P;

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    long x, y, a, b;
    std::cin>>x>>y>>a>>b;

    R ray(P(x,y), P(a, b));

    bool collision = false;
    for(int i = 0; i < n; i++){
      long r, s, t, u;
      std::cin>>r>>s>>t>>u;

      if(!collision){
        S segment(P(r, s), P(t, u));

        if(CGAL::do_intersect(ray, segment)){
          collision = true;
        }
      }
    }

    if(collision){
      std::cout<<""yes\n"";
    }else{
      std::cout<<""no\n"";
    }
  }
}
"
"The Iron Islands","‚ÄúIronborn captains were proud and willful, and did not go in awe of a man‚Äôs blood. The islands were too small for awe, and a longship smaller still. If every captain was a king aboard his own ship, as was often said, it was small wonder they named the islands the land of ten thousand kings.‚Äù Theon Greyjoy, A Song of Ice and Fire by George R. R. Martin After being freed by Theon, Yara Greyjoy decides to take the Iron Islands back from the hands of her uncle, Euron. While most of Euron‚Äôs men are busy ferrying the Golden Company to King‚Äôs Landing, some have been left back to protect the Iron Islands. You want to help Yara plan the first strike, to conquer some of the islands. For every island you know exactly how many men are needed to conquer it. You should take into account that the ironborn (the members of Yara‚Äôs army) are brave but stubborn men. Firstly, being left behind would be a grave insult and so they would refuse any plan that does not involve sending every single one of them to the islands. Also, they would refuse any plan that sends more men than strictly necessary to any of the islands‚Äîor do you doubt their skills? Apart from this, you must also take the topology of the Iron Islands into account. The Iron Islands are arranged on undirected waterways that all necessarily contain and start at Pyke (Island 0). Every island, other than Pyke, belongs to exactly one such... Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers n k b, separated by a space. They denote ‚Äì n, the number of islands (1 ‚©Ωn ‚©Ω5 ¬∑ 104); ‚Äì k, the number of ironborn men at your disposal (1 ‚©Ωk ‚©Ω106); ‚Äì w, the number of waterways that start at Pyke (1 ‚©Ωw < n). ‚Ä¢ The following line contains n integers c0 . . . cn‚àí1, separated by a space, where ci denotes the number of men required to conquer island i (1 ‚©Ωci ‚©Ω106). ‚Ä¢ The following w lines each define a waterway. Each line starts with an integer ‚Ñì, followed by ‚Ñìintegers, r0 r1 . . . r‚Ñì‚àí1, separated by a space, which represent the length of the waterway (1 ‚©Ω‚Ñì‚©Ωn) and the islands along this waterway (r0 = 0 and 1 ‚©Ωri ‚©Ωn ‚àí1, for all i ‚àà{1, . . . , ‚Ñì}). Output: For each test case, output a single line that consists of a single integer denoting the maximum number of islands that can be conquered with a valid plan or 0 if there is no such plan.","The Iron Islands - solution It is possible to divide the resolution into two steps: - The best path is inside a waterway. For this solution, it is possible to use the sliding window technique inside each waterway to find the maximum number of islands that can be taken. - The best path extends over two waterways. Because it is necessary to follow a straight path, it is possible to start in one waterway and finish in another. This means that the number of men needed is the sum of the number of men needed to conquer part of the first waterway and...","Prefix sums / Parity counting","#include <iostream>
#include <vector>
#include <algorithm>

typedef struct{
  int w;  //Waterway index
  int par_sum;  //Partial sum of men
  int nr_islands;  //Number of islands considered for the partial sum
} path_t;

struct orderPaths{
  bool operator()(path_t &p1, path_t &p2){
   if(p1.par_sum == p2.par_sum){
     return p1.nr_islands < p2.nr_islands;
   }
   return p1.par_sum < p2.par_sum;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, k, b;  //n = islands, k = men, b = waterways
    std::cin>>n>>k>>b;

    std::vector<int> required(n);
    for(int i = 0; i < n; i++){
      int c;
      std::cin>>c;

      required[i] = c;
    }

    std::vector<std::vector<int>> waterways(b);
    std::vector<path_t> paths;
    for(int w = 0; w < b; w++){
      int l;
      std::cin>>l;

      int par_sum = 0;
      for(int i = 0; i < l; i++){
        int r;
        std::cin>>r;

        waterways[w].push_back(r);
        par_sum += required[r];

        paths.push_back({w, par_sum, i+1});
      }
    }

    //The best path considers only one wateray. Use the sliding window technique
    int max_islands = 0;
    for(int w = 0; w < b; w++){
      int low = 0;
      int high = 0;
      int sum = required[waterways[w][0]];

      while(low < (int)waterways[w].size()){

        if(sum == k){
          max_islands = std::max(max_islands, high-low+1);

          if(high < (int)waterways[w].size()-1){
            sum += required[waterways[w][++high]];
          }else{
            sum -= required[waterways[w][low++]];
          }
          continue;
        }

        if(sum < k && high < (int)waterways[w].size()-1){
          sum += required[waterways[w][++high]];
        }else{
          sum -= required[waterways[w][low++]];
        }
      }
    }

    //The best path uses two waterways passing though the center. Use the two sum technique
    std::sort(paths.begin(), paths.end(), orderPaths());
    int low = 0;
    int high = paths.size()-1;

    while(low <= high){
      //Remove the men required to conquer island 0 because they are considered in both partial sums
      int sum = paths[low].par_sum + paths[high].par_sum - required[0];
      if(sum == k){
        if(paths[low].w != paths[high].w){
          //Remove the island 0 because it is considered in both island counts
          max_islands = std::max(max_islands, paths[low].nr_islands + paths[high].nr_islands - 1);
        }

        low++;
        continue;
      }

      if(sum < k){
        low++;
      }else{
        high--;
      }
    }

    std::cout<<max_islands<<""\n"";
  }
}
"
"Asterix the Gaul","After a long struggle all of Gaul is occupied by the Romans‚Äîall of it, except for a tiny village that is still holding out. After months of siege Centurion Caius Bonus manages to inÔ¨Åltrate the village. A spy discovers the secret that makes these Gauls invincible: a druid called Panoramix periodically prepares a magic potion. Upon receiving this information the Centurion orders to have the druid captured and interrogated for the recipe. Fortunately, the protagonist Ast√©rix learns about the plan and now wants to warn Panoramix before the Romans reach him. Panoramix is at distance D from Ast√©rix and the Romans need T seconds in order to reach Panoramix. However, Ast√©rix cannot run as he wishes‚Äîany suspicious movement will alert the Romans and he might end up imprisoned himself before he can warn Panoramix. Ast√©rix has a list M of n possible movements that will not raise any suspicion from the Romans. A movement consists of a traversed distance d and a number of seconds t that it takes to perform. Several movements in M may have the same parameters d and t, and you may think of M as a multiset. Ast√©rix may perform each movement in M at most once, that is, the list of movements performed must form a submultiset of M. Luckily, Ast√©rix is equipped with a bottle of magic potion. Before starting his quest, he can take up to m gulps from the bottle. Taking i gulps of the potion allows... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains four integers n m D T, separated by a space. They denote ‚Äì n, the number of movements Ast√©rix may perform (1 ‚©Ωn ‚©Ω30); ‚Äì m, the amount of magic potion Ast√©rix has available (0 ‚©Ωm ‚©Ω105); ‚Äì D, Ast√©rix‚Äôs distance to Panoramix (1 ‚©ΩD < 250); ‚Äì T, the number of seconds it takes for the Romans to reach the druid (1 ‚©ΩT < 250).  The following n lines deÔ¨Åne the list M of movements Ast√©rix may perform. Each line contains two integers d t, separated by a space, that denote the traversed distance (1 ‚©Ω d < 250) and the amount of time required for the movement (1 ‚©Ωt < 250).  The following line contains m integers s1 . . . sm, separated by a space, where si denotes the additional distance covered by every movement after taking i gulps of the magic potion initially (1 ‚©Ωs1 ‚©Ωs2 ‚©Ω. . . ‚©Ωsm < 250). 1 Output: For each test case output a single line with a single integer that denotes the minimum number of gulps of magic potion Ast√©rix needs to drink so as to warn Panoramix in time. If the available amount of potion does not suÔ¨Éce, output ‚ÄúPanoramix captured‚Äù instead","Asterix the Gaul - solution Keep in mind that all the calculations regarding distance and time must be done using long variables. Using a greedy algorithm would not work. For this reason, it is necessary to use Split & List. Considering that the subsets' elements must not overlap, it's not possible to divide the subset calculation just by dividing by two the range of indexes of the subset. It is necessary to divide the calculations by considering two non-overlapping subsets of the bits used for the index of the subset of elements currently...","Prefix sums / Parity counting","#include <iostream>
#include <vector>
#include <algorithm>

typedef struct{
  long d;
  long t;
} movement_t;

//Shortest time first, then longest distance
struct orderMovements{
  bool operator()(movement_t &m1, movement_t &m2){
    if (m1.t == m2.t) {
        return m1.d > m2.d;
    }
    return m1.t < m2.t;
  }
};

bool solve(std::vector<movement_t> &movements, int n, long D, long T, long gulp){

  //Split and list
  int n1 = n/2;
  int n2 = n-n1;

  std::vector<movement_t> list1;
  for(int i = 0; i < (1<<n1); i++){

    long d_sum = 0;
    long t_sum = 0;

    for(int j = 0; j < n1; j++){
      if(i & (1<<j)){
        d_sum += movements[j].d + gulp;  //Add potion each step
        t_sum += movements[j].t;
      }
    }

    list1.push_back({d_sum, t_sum});
  }

  std::vector<movement_t> list2;
  for(int i = 0; i < (1<<n2); i++){

    long d_sum = 0;
    long t_sum = 0;
    int steps = 0;

    for(int j = 0; j < n2; j++){
      if(i & (1<<j)){
        d_sum += movements[n1+j].d + gulp;  //Add potion each step
        t_sum += movements[n1+j].t;
        steps++;
      }
    }

    list2.push_back({d_sum, t_sum});
  }

  std::sort(list1.begin(), list1.end(), orderMovements());
  std::sort(list2.begin(), list2.end(), orderMovements());

  //The partial sums are ordered first my the time (less time first), then by the distance (more distance first)
  //For this reason, if there are cases when less space is traversed in more time, that should not be considered

  //If while traversing the vector there an instance where the distance traversed is less than previously found,
  //that value is discarded because, considering the ordering, the speed will be for sure lower than previously found
  long max_d = 0;
  std::vector<movement_t> list1_cleaned;
  for (auto mov : list1){
    if(mov.d > max_d) {
      max_d = mov.d;
      list1_cleaned.push_back(mov);
    }
  }

  max_d = 0;
  std::vector<movement_t> list2_cleaned;
  for (auto mov : list2){
    if(mov.d > max_d) {
      max_d = mov.d;
      list2_cleaned.push_back(mov);
    }
  }

  bool found = false;
  int i1 = 0, i2 = list2_cleaned.size() - 1;

  //Two sum technique
  while (i1 < (int)list1_cleaned.size() && i2 >= 0){

    long tot_D = list1_cleaned[i1].d + list2_cleaned[i2].d;
    long tot_T = list1_cleaned[i1].t + list2_cleaned[i2].t;

    if (tot_D >= D){
      if(tot_T < T){
        found = true;
        break;
      }else{
        i2--;
      }
    }else{
      i1++;
    }
  }

  //Return if it's possible to reach Panoramix in time
  return found;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;  //n = movements, m = gulps
    long D, T;  //D = distance, T = max time
    std::cin>>n>>m>>D>>T;

    std::vector<movement_t> movements(n);
    for(int i = 0; i < n; i++){
      long d, t;
      std::cin>>d>>t;

      movements[i] = {d, t};
    }

    std::vector<long> gulps(m+1);
    gulps[0] = 0;
    for(int i = 1; i < m+1; i++){
      long s;
      std::cin>>s;

      gulps[i] = s;
    }

    //Binary search on the number of gulps to take
    int l = 0; int h = m;
    while(l < h){
      int mid = (l+h)/2;
      long gulp = gulps[mid];

      if(solve(movements, n, D, T, gulp)){
        h = mid;
      }else{
        l = mid+1;
      }
    }

    if(solve(movements, n, D, T, gulps[l])){
      std::cout<<l<<""\n"";
    }else{
      std::cout<<""Panoramix captured\n"";
    }
  }
}
"
"Boats","Every year all the wizards of the world gather at the Algwarts School of Magic to celebrate the fact that their magic is still not replaced by science. They can come with boats, among other ways. The organizers have reserved a ring for every participant, so he can tie his boat to the ring assigned uniquely to him. Every magician has sent the length of his boat to the organizers. The boat has to be tied so that the ring is somewhere on the length of the boat, including the endpoints of the boat. The ends of two boats can touch each other, but boats cannot overlap (see the picture). Because of this restriction it is possible that all boats cannot be tied at the same time. The organizing committee of the Wizard Assembly asked you to write the program BOATS that Ô¨Ånds the maximal number of boats which can be tied at the same time to the as- signed ring. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains a single integer n, denoting the number of wizards (1 ‚©Ωn ‚©Ω2 ¬∑ 105).  The following n lines deÔ¨Åne the boats. The i-th such line contains two integers l p, separated by a space, denoting the length of the i-th boat (1 ‚©Ω‚Ñì‚©Ω106) and the position of the assigned ring along the river bank starting from the school building (1 ‚©Ωp ‚©Ω106). No two rings have the same position. While the positions of the rings are always positive, the left endpoint of the boats can be negative. Output: For each test case, on a single line output the maximal number of boats that can be attached to their ring without collisions.","Boats - solution Order the boats by their ring position, then proceed with a greedy algorithm with a little twist. Take the first boat and set the position of its ring as the rightmost occupied position. Then, for each boat: - Try to place the new boat so that it occupies only the space until its ring (this results in less space being occupied). To do this, it's necessary to see if, by placing the boat in this position, it would overlap with the occupied positions of other boats. Increase the number of boats used if this positioning is...","Greedy","#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

typedef struct{
  int l;  //Length
  int p;  //Anchoring point
} boat_t;

//Order by the anchoring points of the boats
struct orderBoats{
  bool operator()(boat_t &b1, boat_t &b2){
    return b1.p < b2.p;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<boat_t> boats(n);
    for(int i = 0; i < n; i++){
      int l, p;
      std::cin>>l>>p;

      boats[i] = {l, p};
    }

    std::sort(boats.begin(), boats.end(), orderBoats());

    int index = 1;
    int occ = boats[0].p;  //Position until the dock is occupied
    int prev_occ = INT_MIN;  //Position until the dock was occupied before taking the last boat

    int count = 1;

    while(index < n){
      boat_t current_b = boats[index];

      //The current boat fits
      if(current_b.p > occ){
        prev_occ = occ;
        count++;

        //Place the end where the point is
        if(current_b.p - current_b.l > occ){
          occ = current_b.p;
        }else{
          occ = occ + current_b.l;
        }
      }else{  //Boat does not fit

        //Try to see if it's better to replace the previous boat
        if(current_b.p > prev_occ){  //This boat would fit if the previous was not present

          //Try to see if the space occupied would get better
          if(current_b.p - current_b.l > prev_occ && current_b.p < occ){
            occ = current_b.p;
          }else if(prev_occ + current_b.l < occ){
            occ = prev_occ + current_b.l;
          }
        }
      }

      index++;
    }

    std::cout<<count<<""\n"";
  }
}
"
"Moving Books","Given that the time to move a box from the apartment to the van is exactly two minutes (regardless of the strength of the friend), and that the time to get back upstairs after moving a box is one minute, what is the least amount of time in which all the boxes can be moved to the van? Initially all friends are upstairs, but it is not necessary for all friends to be back upstairs at the end. You can assume that an unlimited number of friends can use the stairs at the same time without bumping into each other. You can also assume that Simone is busy carrying other things and does not help with the boxes. Input: The Ô¨Årst line of the input contains the number t ‚©Ω20 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains two integers n m, separated by a space, denoting the number of friends (1 ‚©Ωn ‚©Ω3 ¬∑ 105) and of boxes (1 ‚©Ωm ‚©Ω3 ¬∑ 105).  The following line deÔ¨Ånes the strengths of the friends. It contains n integers s0 . . . sn‚àí1, separated by a space, and such that 1 ‚©Ωsi ‚©Ω5 ¬∑ 105, for all i ‚àà{0, . . . , n ‚àí1}. Here si denotes the strength of the i-th friend.  The following line deÔ¨Ånes the weights of the boxes. It contains m integers w0 . . . wm‚àí1, separated by a space, and such that 1 ‚©Ωwi ‚©Ω5 ¬∑ 105, for all i ‚àà{0, . . . , m ‚àí1}. Here wi denotes the weight of the i-th box. Output: For each test case output a single line with the minimal time needed to move all the boxes from the apartment to the van. If the friends are not suÔ¨Éciently strong to move the boxes, output a single line with ‚Äòimpossible‚Äô.","Moving Books - solution It is possible to store the friends' strength in a vector that can be ordered from the strongest to the weakest. It's important to sort the vector by placing the strongest friend first because it removes some computation by skipping all weaker friends if one does not have a matching box. To store the boxes, it is possible to use a map that maps keys representing the weight of a box to the number of boxes with that weight. For every cycle, it is necessary to add 2 minutes that are needed to go down the stairs. In each...","Greedy + Multiset/Map","#include <iostream>
#include <vector>
#include <algorithm>
#include <map>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; //n = friends, m = boxes
    std::cin>>n>>m;

    std::vector<int> strengths(n);
    for(int i = 0; i < n; i++){
      int s;
      std::cin>>s;

      strengths[i] = s;
    }

    std::sort(strengths.begin(), strengths.end(), std::greater<int>());

    //Store how many boxes of each weight there are
    std::map<int, int> weights;
    for(int i = 0; i < m; i++){
      int w;
      std::cin>>w;

      weights[w]++;
    }

    //If the strongest friend cannot lift the heaviest box, it's impossible
    if(strengths[0] < weights.begin()->first){
      std::cout<<""impossible\n"";
    }

    int minutes = 0;
    bool impossible = false;
    while(true){
      minutes += 2;  //Time to go down the stairs

      //Try to find a matching box for each friend
      for(int i = 0; i < n; i++){
        int s = strengths[i];

        //Search for the first valid weight
        auto equal_greater_it = weights.lower_bound(s);
        while(equal_greater_it != weights.begin() && (equal_greater_it == weights.end() || equal_greater_it->first > s)){
          equal_greater_it--;
        }

        //No valid weight found
        if(equal_greater_it->first > s){
          if(i == 0){  //Impossible if there is not a weight for the strongest
            impossible = true;
          }
          break;  //No need to check also for weaker friends
        }

        (equal_greater_it->second)--;

        if(equal_greater_it->second == 0){
          weights.erase(equal_greater_it);
        }

        if(weights.empty()){
          break;
        }
      }

      if(impossible || weights.empty()){
        break;
      }else{
        minutes += 1;  //Go up the stairs because there are more boxes
      }
    }

    if(impossible){
      std::cout<<""impossible\n"";
    }else{
      std::cout<<minutes<<""\n"";
    }
  }
}
"
"Planet Express","Your task is to determine whether it is possible for Planet Express to complete the delivery within the advertised time of 1 second and, if that is the case, the shortest amount of time required for the delivery. You can assume that the time needed to travel between two locations on the same planet is negligible. Input: The Ô¨Årst line of the input contains the number t ‚©Ω20 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing four integers n, m, k, T, separated by a space. They denote n: the number of planets in the galaxy, i.e., the number of vertices in G (1 ‚©Ωn ‚©Ω105); m: the number of edges in G (0 ‚©Ωm ‚©Ω105), k: the number of warehouses, located at the vertices 0, . . . , k ‚àí1 in G (1 ‚©Ωk ‚©Ωn), T: the number of planets that are part of the teleportation network (0 ‚©ΩT ‚©Ωn). ‚Ä¢ The following line contains T distinct space-separated integers t0 . . . tT‚àí1 with 0 ‚©Ωti < n. They denote the vertices (planets) in G that are part of the teleportation network. ‚Ä¢ The next m lines deÔ¨Åne the edges of G. Each line contains three space-separated integers u, v, c deÔ¨Åning a directed edge (u, v) in G of weight c (0 ‚©Ωu, v < n, u Ã∏= v, 0 ‚©Ωc ‚©Ω107). 1A microsecond is equal to 10‚àí6 seconds. Spaceships are fast! 1 Output: The output consists of one line for each test case. ‚Ä¢ If the dark matter cannot be delivered within at most 1 second for the i-th test case, then the i-th line of the output should contain the string ‚Äúno‚Äù. ‚Ä¢ Otherwise, the i-th line of the output should contain a single integer that denotes the smallest number of microseconds needed to complete the delivery (i.e., the time a deliv- ery agent needs to reach Omicron Persei 8 from the optimal warehouse).","Planet Express - solution It would be wasteful to iterate over all the warehouses, using the Dijkstra shortest path algorithm, to find which one reaches the final planet in less time. It is much better to create the graph by inverting all the edge directions and using Dijkstra starting from the final planet. It is then possible to iterate on all the warehouses and see which one is the closest. There are some planets with teleportation systems, but that does not necessarily mean that they are connected to other planets through teleportation. A...","Dijkstra / Shortest path","#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/strong_components.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS,
  boost::no_property, boost::property<boost::edge_weight_t, int>> graph;

typedef boost::property_map<graph, boost::edge_weight_t>::type weight_map;
typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, k, T; //n = vertices, m = edges, k = warehouses, T = teleport planets
    std::cin>>n>>m>>k>>T;

    std::vector<int> teleport_planets(T);
    for(int i = 0; i < T; i++){
      int p;
      std::cin>>p;

      teleport_planets[i] = p;
    }

    graph G(n);
    weight_map weights = boost::get(boost::edge_weight, G);

    //Create the graph in reverse to speed up Dijkstra
    for(int i = 0; i < m; i++){
      int u, v, c;
      std::cin>>u>>v>>c;

      edge_desc e = boost::add_edge(v, u, G).first;
      weights[e] = c;
    }

    //Set up the teleportation network
    std::vector<int> scc_map(n);

    int nscc = boost::strong_components(G,
      boost::make_iterator_property_map(scc_map.begin(), boost::get(boost::vertex_index, G)));

    //A single teleportation network is formed by all the planets with teleportation
    //capabilities that are in the same strong connected component
    std::vector<int> teleport_per_scc(nscc, 0);
    for(int i = 0; i < T; i++){
      int tp_planet = teleport_planets[i];
      teleport_per_scc[scc_map[tp_planet]]++;
    }

    //Connect each teleport planet to a strong component hub
    //One way is free, the other costs the right amount
    for(int i = 0; i < T; i++){
      int tp_planet = teleport_planets[i];
      int scc = scc_map[tp_planet];

      edge_desc e = boost::add_edge(tp_planet, n+scc, G).first;
      weights[e] = 0;

      e = boost::add_edge(n+scc, tp_planet, G).first;
      weights[e] = teleport_per_scc[scc]-1;
    }

    //It's much faster to calculate the distance from the end point
    int vertices = boost::num_vertices(G);
    std::vector<int> dist_map(vertices);

    boost::dijkstra_shortest_paths(G, n-1,
      boost::distance_map(boost::make_iterator_property_map(
        dist_map.begin(), boost::get(boost::vertex_index, G))));

    int best_dist = INT_MAX;
    for(int p = 0; p < k; p++){
      best_dist = std::min(best_dist, dist_map[p]);
    }

    if(best_dist <= 1000000){
      std::cout<<best_dist<<""\n"";
    }else{
      std::cout<<""no\n"";
    }
  }
}
"
"Severus Snape","given to him by Snape, Harry has negative power or negative wit, and that is not a problem. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains two integers n m, separated by a space, denoting the number of potions of type A (1 ‚©Ωn ‚©Ω100) and the number of potions of type B (1 ‚©Ω m ‚©Ω100) at Snape‚Äôs disposal. 1  The following line contains two integers a b, separated by a space, denoting the wit Harry loses with each potion of type A he drinks (0 ‚©Ωa < 231) and the magical power Harry loses with each potion of type B he drinks (0 ‚©Ωb < 231).  The following line contains three integers P H W, separated by a space, denoting the mag- ical power Harry needs (1 ‚©ΩP < 231), the happiness he needs (1 ‚©ΩH ‚©Ω210), and the wit he needs (1 ‚©ΩW < 231).  The following n lines each describe a potion of type A. The i-th such line contains two integers pi hi, separated by a space, denoting the magical power (1 ‚©Ωpi < 231) and the happiness (1 ‚©Ωhi ‚©Ω210) Harry can get from the i-th potion of type... Output: For each test case, output a single line that consists of a single integer denoting the minimum number of potions necessary to boost Harry‚Äôs magical power, happiness, and wit to (at least) the required levels, or ‚àí1 if no subset of potions can do that.","Severus snape - solution The sums may overflow an int, so a long is needed. In addition, when reading a and 'b', it's necessary to read them as long because, when multiplied by the number of potions, which is an int, the result may overflow an int ('int * int is an int). To consider the A potions, it's necessary to follow a DP approach. The DP table is a three-dimensional array of long (let's call it power) of size $(n+1) \times (n+1) \times (H+1)$. power[j][i][h] denotes the maximum power that is achievable by taking j A potions out of the...","Max Flow / Min Cut","#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

typedef std::vector<long> VL;
typedef std::vector<VL> VVL;
typedef std::vector<VVL> VVVL;

typedef struct{
  long p;
  long h;
} potA;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; //n = pot A, m = pot B
    std::cin>>n>>m;

    long a, b;  //a = lose wit with A, b = lose power with B
    std::cin>>a>>b;

    long P, H, W;  //Target values
    std::cin>>P>>H>>W;

    std::vector<potA> potionsA(n);
    for(int i = 0; i < n; i++){
      int p, h;
      std::cin>>p>>h;

      potionsA[i] = {p, h};
    }

    VL potionsB(m);
    for(int i = 0; i < m; i++){
      int w;
      std::cin>>w;

      potionsB[i] = w;
    }

    //dp[j][i][h]. Take j potions out of the first i potions that have a happines of at least h
    VVVL dp(n+1, VVL(n+1, VL(H+1, LONG_MIN)));

    //Base case, take only one potion
    for(int h = 0; h <= H; h++){
      for(int i = 1; i < n+1; i++){  //Out of the first i potions, take only 1
        dp[1][i][h] = dp[1][i-1][h];  //Take the best single potion when only i-1 potions were considered

        //Check if the new potion is better than a previous one to reach an happines of h
        if(potionsA[i-1].h >= h && potionsA[i-1].p > dp[1][i][h]){
          dp[1][i][h] = potionsA[i-1].p;
        }
      }
    }

    for(int j = 2; j < n+1; j++){  //Take j potions
      for(int h = 0; h <= H; h++){  //With happines at least h
        for(int i = j; i < n+1; i++){  //Out of the first i potions

          //Previous happiness because, by taking the current potion, it arrives at h
          int prev_h = std::max(0L, h - potionsA[i-1].h);

          //Take the current potion instead of the one that was taken previously or not
          dp[j][i][h] = std::max(dp[j][i-1][h], dp[j-1][i-1][prev_h] + potionsA[i-1].p);
        }
      }
    }

    //Greedy approach for the B potions
    std::sort(potionsB.begin(), potionsB.end(), std::greater<long>());

    int num_potions_A = -1;
    int num_potions_B = 0;

    long sum_wit = 0;

    for(; num_potions_B < m; num_potions_B++){
      sum_wit += potionsB[num_potions_B];

      if(sum_wit >= W){
        for(int pA = 1; pA < n+1; pA++){
          long power = dp[pA][n][H];

          //Check that the wit remains high enough
          if(sum_wit-a*pA < W){
            break;
          }

          if(power >= P+b*(num_potions_B+1)){
            num_potions_A = pA;
            break;
          }
        }
      }

      if(num_potions_A != -1){
        break;
      }
    }

    if(num_potions_A == -1){
      std::cout<<""-1\n"";
    }else{
      //+1 because num_potions_B is an index
      std::cout<<num_potions_A + num_potions_B + 1<<""\n"";
    }
  }
}
"
"Coin Tossing Tournament","given the schedule of matches and the results you had noted. After all it should take some non-trivial effort to play a prank on you... Input: The Ô¨Årst line of the input contains the number of test cases 1 ‚©Ωt ‚©Ω200. Each test case is described as follows. ‚Ä¢ It starts with a line containing two integers n, m separated by a single space (1 ‚©Ωn ‚©Ω200, 1 ‚©Ωm ‚©Ω1000), the number of players and rounds played, respectively. The players are numbered from 0 to n ‚àí1. ‚Ä¢ The next m lines each describe one round of the game: each contains three integers a, b, c separated by single spaces (0 ‚©Ωa, b < n and a Ã∏= b) indicating a round was played between players a and b. The result of the coin toss is given by c: ‚Äì c = 1: player a won; ‚Äì c = 2: player b won; ‚Äì c = 0: you did not write down the winner. (c always takes one of these three values.) ‚Ä¢ On the Ô¨Ånal line of the test case, there are n integers s0, . . . , sn‚àí1 (with 0 ‚©Ωsi ‚©Ω210) separated by single spaces, where si is the score of player i according to the Ô¨Ånal score- board. Output: For each test case decide if it is possible to assign results to the rounds marked with c = 0 such that the Ô¨Ånal standings match the scoreboard speciÔ¨Åed in the input. Indicate the result with one word on a single line: either yes or no.","Coin Tossing Tournament - solution Create a graph that can be used to calculate the max flow with nodes for the rounds and for the players. From the source to each round, the edges have capacity 1 (one point can be assigned per round). From each round to the players, if it's known who will win, there is an edge from the round to the specific player with capacity 1. If it's not known, there is an edge from the round to both players with capacity 1. From each player to the sink, there is an edge with capacity equal to the player's score on the...","Max Flow / Min Cut","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
    boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

typedef struct{
  int a;
  int b;
  int c;
} round_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;  //n = players, m = rounds
    std::cin>>n>>m;

    std::vector<round_t> rounds(m);
    for(int i = 0; i < m; i++){
      int a, b, c;  //c = 1 -> a wins, c = 2 -> b wins, c = 0 -> no idea
      std::cin>>a>>b>>c;

      rounds[i] = {a, b, c};
    }

    std::vector<int> scores(n);
    int sum_scores = 0;
    for(int i = 0; i < n; i++){
      int s;
      std::cin>>s;

      scores[i] = s;
      sum_scores += s;
    }

    graph G(m+n);
    edge_adder adder(G);

    const vertex_desc v_source = boost::add_vertex(G);
    const vertex_desc v_sink = boost::add_vertex(G);

    for(int i = 0; i < m; i++){
      //One point to assign this round
      adder.add_edge(v_source, i, 1);

      if(rounds[i].c == 1){
        //Assign to a only
        adder.add_edge(i, m+rounds[i].a, 1);
      }else if(rounds[i].c == 2){
        //Assign to b only
        adder.add_edge(i, m+rounds[i].b, 1);
      }else{
        //Assign to one of the two
        adder.add_edge(i, m+rounds[i].a, 1);
        adder.add_edge(i, m+rounds[i].b, 1);
      }
    }

    for(int i = 0; i < n; i++){
      //Connect each player to the sink with the score it should get
      adder.add_edge(m+i, v_sink, scores[i]);
    }

    long flow = boost::push_relabel_max_flow(G, v_source, v_sink);

    //If all the points are assigned and the final total score is correct
    if(flow == m && sum_scores == m){
      std::cout<<""yes\n"";
    }else{
      std::cout<<""no\n"";
    }
  }
}
"
"Knights","given in the input Ô¨Åle. You may assume that no two knights start at the same intersection. Every segment of a hallway that a knight passes through will collapse immediately behind him, in a movie-like fashion. Intersections have a more heavy- weight construction: an intersection collapses imme- diately after C knights have been there. Because two knights never arrive at an intersection at exactly the same time, every hallway segment can only be used by a single knight and every hallway intersection by at most C knights. Find out how many knights can get to safety. Input: The Ô¨Årst line of the input contains t ‚©Ω30, the number of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a line that contains four numbers: m n k c, separated by a space. They denote ‚Äì 0 ‚©Ωm, n ‚©Ω50, the number of columns and rows of the cave, ‚Äì k, the number of knights in the cave, ‚Äì C ‚©Ω4, the maximum number of knights that can use the same intersection. 1 ‚Ä¢ The next line contains 2k numbers, with the 2i-th and (2i + 1)-th numbers denoting the x (column) and y (row) coordinates of the starting position of the knight i in the cave, i.e. 0 ‚©Ωx ‚©Ωm ‚àí1, 0 ‚©Ωy ‚©Ωn ‚àí1. No two knights start at the same intersection. Output: For every test case output a single line containing the maximum number of knights that can escape from the cave.","Knights - solution In a graph created in order to find the max flow, each intersection can be modeled using two nodes, one with an even id and one with an odd id. From the even one, it's possible to model the hallways that connect the even nodes to the neighboring odd nodes. These hallway edges have capacity 1 because they can be used only once before collapsing. If a node is next to an exit, the edge connects to the sink (always with capacity one, because it's necessary to go through a hallway to exit). It's necessary to remember that corner...","Max Flow / Min Cut","#include <iostream>
#include <vector>
#include <climits>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
    boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int m, n, k, c;
    std::cin>>m>>n>>k>>c;

    graph G(2*m*n);
    edge_adder adder(G);

    const vertex_desc v_source = boost::add_vertex(G);
    const vertex_desc v_sink = boost::add_vertex(G);

    for(int i = 0; i < n; i++){
      for(int j = 0; j < m; j++){
        int node = i*m+j;

        //Each vertex represents an intersection, that can be used c times
        adder.add_edge(2*node, 2*node+1, c);

        //Connect the intersections with tunnels or connect them to the exit
        if(i >= 1){
          int other = (i-1)*m + j;
          adder.add_edge(2*node+1, 2*other, 1);
        }else{
          adder.add_edge(2*node+1, v_sink, 1);
        }

        if(i <= n-2){
          int other = (i+1)*m + j;
          adder.add_edge(2*node+1, 2*other, 1);
        }else{
          adder.add_edge(2*node+1, v_sink, 1);
        }

        if(j >= 1){
          int other = i*m + j - 1;
          adder.add_edge(2*node+1, 2*other, 1);
        }else{
          adder.add_edge(2*node+1, v_sink, 1);
        }

        if(j <= m-2){
          int other = i*m + j + 1;
          adder.add_edge(2*node+1, 2*other, 1);
        }else{
          adder.add_edge(2*node+1, v_sink, 1);
        }
      }
    }

    for(int i = 0; i < k; i++){
      int x, y;
      std::cin>>x>>y;

      //Connect each knight to the intersection it is in
      int node = y*m+x;
      adder.add_edge(v_source, 2*node, 1);
    }

    long flow = boost::push_relabel_max_flow(G, v_source, v_sink);
    std::cout<<flow<<""\n"";
  }
}
"
"London","Phileas Fogg is a rich British gentleman, living a modest life in London with his valet Jean Passepartout. Most of his spare time is spent at the Reform Club, where he stays until midnight every day reading The Daily Telegraph. On Wednesday, 2 October 1872, he reads an article which claims that it is now possible to travel around the world in 80 days thanks to the opening of a new railway section in India. After a heated argument with his fellow club members, he accepts a wager for ¬£20‚Äô000 to complete the journey within this time period. Having no time to lose, Fogg and Passepartout set forth at once. Their Ô¨Årst objective is to board the steamer Mongolia, to bring them from Brindisi via Suez to Bombay. On the same day, a major bank robbery takes place. Scotland Yard has reason to believe that the robber is no ordinary man, but a gentleman from the Reform Club. The only trace left at the crime scene is an anonymous note made out of separate letters cut from a newspaper. The note seems to be made in order to mislead the detectives, but it can instead reveal information about the robber. Since the Reform Club and all its members are known to pride themselves on only reading from The Daily Telegraph, Scotland Yard wants to conÔ¨Årm their suspicion by verifying that the anonymous note could indeed be made from that particular newspaper. The Daily Telegraph has two sides: a front side... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. All newspaper and note characters are capital English letters from A to Z (no whitespaces, punctuation, accents, or other special characters). Each of the t test cases is described as follows. ‚Ä¢ The Ô¨Årst line contains two integers h w, separated by a space. They denote ‚Äì h, the number of lines in the newspaper (2 ‚©Ωh ‚©Ω103); ‚Äì w, the number of letters on every line of the newspaper (2 ‚©Ωw ‚©Ω103). ‚Ä¢ The second line deÔ¨Ånes the note from the crime scene. It consists of a single string of n letters (2 ‚©Ωn ‚©Ω106). Note that n need not be equal to the number of newspaper pieces. ‚Ä¢ The following h lines deÔ¨Åne the text on the front side of the newspaper. Each line contains exactly w letters. ‚Ä¢ The Ô¨Ånal h lines deÔ¨Åne the text on the back side of the newspaper. Each line contains exactly w letters. 1 Note that on the back of the i-th line from the front side of the newspaper is the i-th line from the back side, for i ‚àà{0, . . . , h... Output: For each test case output one line with a single word ‚ÄúYes‚Äù or ‚ÄúNo‚Äù, indicating whether or not the note can be composed from the given newspaper page.","London - solution All the pairs of letters that the newspaper pieces can form are stored in an array of size 26*26, counting how many times each pair is present in the newspaper. Each pair is formed by the letter in the front and the corresponding letter in the back of the newspaper (making sure to choose the correct letter from the back). The pairs of letters are linked to the indexes of the array by mapping each letter to the range 0-25 by removing 'A' from their value (so the letter A is mapped to 0). Then the index in the array can be...","Max Flow / Min Cut","#include <iostream>
#include <string>
#include <vector>
#include <climits>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
    boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int h, w;
    std::cin>>h>>w;

    std::string note;
    std::cin>>note;

    //Characters in the front page
    std::vector<std::vector<char>> front(h, std::vector<char>(w));
    for(int i = 0; i < h; i++){
      for(int j = 0; j < w; j++){
        char c;
        std::cin>>c;

        front[i][j] = c;
      }
    }

    //Characters in the back page, stored to make them match the front page
    std::vector<std::vector<char>> back(h, std::vector<char>(w));
    for(int i = 0; i < h; i++){
      for(int j = 0; j < w; j++){
        char c;
        std::cin>>c;

        back[i][w-j-1] = c;
      }
    }

    //Frequency of each letter of the note
    std::vector<int> note_freq(26, 0);
    for(int i = 0; i < (int)note.size(); i++){
      note_freq[note[i]-'A']++;
    }

    //Frequency of the pairs in the newspaper
    std::vector<int> news_freq(26*26, 0);
    for(int i = 0; i < h; i++){
      for(int j = 0; j < w; j++){
        int front_letter = front[i][j] - 'A';
        int back_letter = back[i][j] - 'A';
        int pair_id = front_letter*26+back_letter;

        news_freq[pair_id]++;
      }
    }

    //Vertices from 0 to 25 for the note letters
    //Vertices from 26 to 26+26*26 for the pairs of letters of the newspaper
    graph G(26*26+26);
    edge_adder adder(G);

    const vertex_desc v_source = boost::add_vertex(G);
    const vertex_desc v_sink = boost::add_vertex(G);

    for(int f = 0; f < 26; f++){
      for(int b = 0; b < 26; b++){

        int pair_id = f*26 + b;
        adder.add_edge(v_source, 26 + pair_id, news_freq[pair_id]);

        if(news_freq[pair_id] > 0){
          adder.add_edge(26 + pair_id, f, news_freq[pair_id]);
          adder.add_edge(26 + pair_id, b, news_freq[pair_id]);
        }
      }
    }

    for(int l = 0; l < 26; l++){
      if(note_freq[l] > 0){
        adder.add_edge(l, v_sink, note_freq[l]);
      }
    }

    int flow = boost::push_relabel_max_flow(G, v_source, v_sink);

    if(flow == (int)note.size()){
      std::cout<<""Yes\n"";
    }else{
      std::cout<<""No\n"";
    }
  }
}
"
"Motorcycles","It is an old biker‚Äôs dream to ride forever into the sunrise. Alas, not everybody manages to live the dream. Who will drive on forever? Consider n bikers that start on the y-axis and ride east, into the positive x-halfplane. All bikers start at the same time and drive with the same speed. Every biker follows a straight path. However, if a biker runs into the tracks of another biker, she loses the desire to continue on the trip and stops right there. (The point of riding into the sunrise is to boldly go where no . . . well, at least not follow someone else‚Äôs tracks.) Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains a single integer n so that 1 ‚©Ωn ‚©Ω5¬∑105. Here n denotes the number of bikers. ‚Ä¢ The following n lines deÔ¨Åne the starting positions and driving directions of the bikers b0, . . . , bn‚àí1. Each line contains three integers y0 x1 y1 separated by a space and such that x1 > 0 and |y0|, x1, |y1| < 251. The corresponding biker starts at position (0, y0) and rides oÔ¨Äfrom there in direction of the point (x1, y1). Note that the point (x1, y1) speciÔ¨Åes the direction not the destination. That is, the biker does not stop if she reaches this point. You may assume that the starting positions are pairwise distinct. Output: For each test case output a single line that lists the indices of all bikers that ride forever into the sunrise (as deÔ¨Åned below), sorted in increasing order and so that every index is followed by a space. Recall that the bikers are indexed with 0, . . . , n ‚àí1. A biker rides forever into the sunrise if she does not ever meet the tracks of any other biker (that is, a point where another biker has been to earlier than her). In case two bikers reach the same spot at exactly the same time, by the usual traÔ¨Éc regulations the biker that comes from the right takes precedence and continues her drive; the biker that came from the left ends her journey there.","Motorcycles - solution The most intuitive solution would require calculating the intersections of each pair of bikers (if any), then finding the biker that reaches the intersection point first. However, this is not fast enough for the last test sets. For each biker, it's necessary to store its index, the $y$ coordinate of its starting position, and the slope of its path (stored using EPEC:FT, it's necessary to have infinite precision, and a double, which is the same thing as using EPIC::FT, is not enough). Then, the bikers are sorted by their...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <set>

#include <CGAL/Exact_predicates_exact_constructions_kernel.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel K;

typedef struct{
  int index;  //Index in the original array
  long y;
  K::FT slope;  //Precise value
} biker_t;

//Order bikers by placing the highest first
struct compMoto{
  bool operator()(biker_t &m1, biker_t &m2){
    return m1.y > m2.y;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<biker_t> bikers(n);
    for(int i = 0; i < n; i++){
      long y0, x1, y1;
      std::cin>>y0>>x1>>y1;

      bikers[i] = {i, y0, K::FT(y1-y0)/K::FT(x1)};
    }

    std::sort(bikers.begin(), bikers.end(), compMoto());

    //Store the indices of the bikers that go on forever relative to the sorted array
    std::vector<int> forever;
    for(int i = 0; i < n; i++){

      while(true){

        //If the slope of the new biker is smaller than the one of the previous biker, there are no collisions
        if(forever.size() == 0 || bikers[i].slope <= bikers[forever.back()].slope){
          forever.push_back(i);
          break;
        }

        //There is a collision
        int last_i = forever.back();

        if(CGAL::sign(bikers[i].slope) == CGAL::sign(bikers[last_i].slope)){
          if(CGAL::sign(bikers[i].slope) == CGAL::NEGATIVE){

            //Current slope higher than the previous one, with same negative signs. The current one arrives sooner
            forever.pop_back();
            continue;
          }else{
            //Current slope higher than the previous one, with same positive signs. The current one arrives later
            break;
          }

        }else{
          if(CGAL::abs(bikers[i].slope) <= CGAL::abs(bikers[last_i].slope)){

            //Current slope higher than the previous one, but with a lower absolute value, with different signs.
            //The current one arrives sooner
            forever.pop_back();
            continue;
          }else{

            //Current slope higher than the previous one, but with a higher absolute value, with different signs.
            //The current one arrives later
            break;
          }
        }
      }
    }

    //Retrieve the indexes considering the original ordering
    std::set<int> indices;
    for(int i: forever){
      indices.insert(bikers[i].index);
    }

    for(int i: indices){
      std::cout<<i<<"" "";
    }
    std::cout<<""\n"";
  }
}
"
"Tiles","given layout can be tiled with 2:1 tiles. Every tile covers exactly two horizontally or vertically adjacent spaces of the garden layout. Every space that is to be tiled must be covered by exactly one tile while the other spaces must remain untiled. The supply of tiles is unlimited. Input: The Ô¨Årst line of input contains the number n of test cases to follow (0 ‚©Ωn ‚©Ω100). Every test case starts with a single line containing two space-separated integers 1 ‚©Ωw, h ‚©Ω50, specifying the width and the height of the garden layout at hand, respectively. The next h lines each describe one row of the layout. Each such line consists of w characters: ‚Äô.‚Äô if that space is to be tiled and ‚Äôx‚Äô if it is to be left free. Output: For every test case output a single line containing the word ‚Äúyes‚Äù if the given layout can be tiled and ‚Äúno‚Äù otherwise.","Tiles - solution If the number of spaces to tile is odd, then it's not possible to tile the area. Prepare a graph for max flow. For every space, if it's an x, skip that space. If not: - If the space is ""even"", meaning that i+j is even, make that space the starting position for a tile. Connect it to the source with an edge of capacity one, meaning that it's possible to choose only one of the possible tiles that start at that space. Try to place the four tiles that start with that space, connecting that space to the other space covered by the...","Max Flow / Min Cut","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
    boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int n;
  std::cin>>n;
  while(n--){
    int w, h;
    std::cin>>w>>h;

    int to_cover = 0;

    std::vector<std::vector<char>> board(h, std::vector<char>(w));
    for(int i = 0; i < h; i++){
      for(int j = 0; j < w; j++){
        char c;
        std::cin>>c;

        if(c == '.'){
          to_cover++;
        }

        board[i][j] = c;
      }
    }

    //It's not possible to cover an odd number of spaces
    if(to_cover % 2 == 1){
      std::cout<<""no\n"";
      continue;
    }

    graph G(w*h);
    edge_adder adder(G);

    const vertex_desc v_source = boost::add_vertex(G);
    const vertex_desc v_sink = boost::add_vertex(G);

    for(int i = 0; i < h; i++){
      for(int j = 0; j < w; j++){
        char c = board[i][j];

        //If the current space needs to be tiled
        if(c == '.'){
          int node = i*w+j;

          //Each space to be tiled can only be connected to the source or the sink
          if((i+j) % 2 == 0){

            adder.add_edge(v_source, node, 1);

            if(i > 0 && board[i-1][j] == '.'){
              int other_node = (i-1)*w+j;
              adder.add_edge(node, other_node, 1);
            }

            if(i < h-1 && board[i+1][j] == '.'){
              int other_node = (i+1)*w+j;
              adder.add_edge(node, other_node, 1);
            }

            if(j > 0 && board[i][j-1] == '.'){
              int other_node = i*w+(j-1);
              adder.add_edge(node, other_node, 1);
            }

            if(j < w-1 && board[i][j+1] == '.'){
              int other_node = i*w+(j+1);
              adder.add_edge(node, other_node, 1);
            }
          }else{
            adder.add_edge(node, v_sink, 1);
          }
        }
      }
    }

    long flow = boost::push_relabel_max_flow(G, v_source, v_sink);

    if(flow == to_cover/2){
      std::cout<<""yes\n"";
    }else{
      std::cout<<""no\n"";
    }
  }
}
"
"Bistro","Sunbunny is a chain of bistros that provide among the Ô¨Ånest snacks available in the country of Sealand. These places have become so popular that at lunch and dinner prime time one can regularly Ô¨Ånd long queues of people waiting to be served. Due to the continuing success the head oÔ¨Éce started to evaluate possible locations where to open another restaurant. One important selection criterion is that the new location must not be too close to an existing Sunbunny restaurant. . . Input: The input contains several test cases. Each of them begins with a line containing one integer n (1 ‚©Ωn ‚©Ω110‚Ä≤000), denoting the number of existing restaurants. The next n lines describe the location xi yi of these restaurants (xi, yi integers, |xi|, |yi| < 224). It follows the number m (1 ‚©Ωm ‚©Ω110‚Ä≤000) of possible locations for the new restaurant, and on the next m lines the coordinates of these locations, in the same format as for the existing restaurants. The input is terminated by a line containing a single number 0. Output: For each possible location for the new restaurant, write on a single line the squared (Euclidean) distance to the closest existing restaurant.","Bistro - solution Create a triangulation containing the locations of existing restaurants. For each new restaurant location, determine the nearest point in the triangulation and find the squared distance to that point.","Computational Geometry (CGAL)","#include <iostream>
#include <vector>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Delaunay_triangulation_2<K> Triangulation;

typedef K::Point_2 P;

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    std::vector<P> points(n);
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      points[i] = P(x, y);
    }

    Triangulation t;
    t.insert(points.begin(), points.end());

    int m;
    std::cin>>m;
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;
      P new_res = P(x, y);

      auto near = t.nearest_vertex(new_res);
      std::cout<<(long)CGAL::squared_distance(new_res, near->point())<<""\n"";
    }
  }
}
"
"Germs","Microbactus solitarius is a very interesting type of organism: it grows as long as it lives, but it dies immediately as soon as something impedes its growing. In Labland they plan to run experiments to Ô¨Ånd out how long these bacteria live under certain circumstances. However, the plans stalled as soon as the national ethics commission heard of it, because any experiments on living organisms come under very close scrutiny. As of yet it is unclear whether these experiments will be allowed eventually, and there is not even a timeframe known when such a decision will be made. Therefore, it is currently being considered whether computer simulations form a viable alternative. This is where you come into play. . . The setup is as follows. An initial conÔ¨Åguration of bacteria is placed in a rectangular dish. Bacteria are modeled as disks, whose initial radius is 0.5¬µm. Each bacterium grows such that its center remains stationary and its radius grows quadratically, described by the function œÅ(t) = t2 + 1 2, where t is the time (measured in hours) that passed since the start of the simulation. For instance, after one hour the radius is 1.5¬µm and after two hours the radius is 4.5¬µm. In the very moment a bacterium touches another bacterium or the outer boundary of the dish, it dies. A dead bacterium stays where it is. In particular, it continues to be an obstacle to the growth (and life)... Input: The input contains several test cases. Each of them is described as follows. ‚Ä¢ It starts with a line that contains a single integer n (1 ‚©Ωn ‚©Ω105), denoting the number of bacteria. ‚Ä¢ The next line describes the dish by four integers l b r t, with |l|, |b|, |r|, |t| < 225. The dish consists of all points (x, y), for which l ‚©Ωx ‚©Ωr and b ‚©Ωy ‚©Ωt. ‚Ä¢ The following n lines describe the position of the bacteria, given by the integer coordinates of their centers x y, separated by space and so that |x|, |y| < 224. You may assume that all bacteria are located within the dish and they are at pairwise distinct positions. The input is terminated by a line containing a single value 0. All coordinates are measured in ¬µm. Output: For every test case the corresponding output appears on a single line consisting of three non-negative integers f m l, where ‚Ä¢ f denotes the moment in which the Ô¨Årst bacterium dies, ‚Ä¢ m denotes the moment in which the amount of bacteria still alive goes below 50%, 1 ‚Ä¢ l denotes the moment in which the last bacterium dies. All three output numbers are to be given in hours and possibly rounded up, that is, if the particular moment falls into the interval (m, m + 1], for some non-negative integer m, then output the number m + 1. The terms ‚Äúdie‚Äù and ‚Äúalive‚Äù refer to our simulation using the simpliÔ¨Åed model, as described above.","Germs - solution The first goal is to calculate the time at which each germ will die: - Try all the dish borders. It's not necessary to check for a collision between a disk and a segment (it would be too expensive); it's possible to just consider the distance between a germ and the dish borders, trying all four combinations of the coordinates of the point and the x-y coordinates of the dish borders. This distance needs to be squared. - Try all the close pairs of germs defined by the edges of the triangulation created using the germ...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <algorithm>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <CGAL/Triangulation_face_base_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;

typedef CGAL::Triangulation_vertex_base_with_info_2<int, K> Vb;
typedef CGAL::Triangulation_face_base_2<K> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<K, Tds> Triangulation;

typedef K::Point_2 P;

long hours(double death_d){
  //r = t^2+0.5, meaning that r^2 = (t^2+0.5)^2
  //(t^2+0.5) = sqrt(r^2) -> t^2 = sqrt(r^2)-0.5 -> t = sqrt(sqrt(r^2)-0.5)
  double hours = std::max(0.0, std::sqrt(std::sqrt(death_d)-0.5));
  return std::ceil(hours);
}

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    long l, b, r, t;
    std::cin>>l>>b>>r>>t;

    std::vector<std::pair<P, int>> germs(n);
    std::vector<double> death(n);  //Store the death time of each germ
    for(int i = 0; i < n; i++){
      long x, y;
      std::cin>>x>>y;

      //Find the first death by border
      double border_death = std::pow(x-l, 2);
      border_death = std::min(border_death, std::pow(r-x, 2));
      border_death = std::min(border_death, std::pow(y-b, 2));
      border_death = std::min(border_death, std::pow(t-y, 2));
      death[i] = border_death;

      germs[i] = {P(x, y), i};
    }

    Triangulation tri;
    tri.insert(germs.begin(), germs.end());

    for (auto e = tri.finite_edges_begin(); e != tri.finite_edges_end(); e++) {
      int i1 = e->first->vertex((e->second+1)%3)->info();
      int i2 = e->first->vertex((e->second+2)%3)->info();

      double death_germ = tri.segment(e).squared_length()/4.0;

      //Update the death time of the two germs connected by the current edge
      death[i1] = std::min(death[i1], death_germ);
      death[i2] = std::min(death[i2], death_germ);
    }

    std::sort(death.begin(), death.end());

    std::cout<<hours(death[0])<<"" "";
    std::cout<<hours(death[n/2])<<"" "";
    std::cout<<hours(death[n-1])<<""\n"";
  }
}
"
"GoldenEye","given that all agents must operate under the umbrella of protection at any time. However, it turned out quickly that the directive is prob- lematic: (1) an agent may not be able to reach the target of her/his mission under the umbrella and (2) the jammers need so much energy to operate that the collective energy costs stretch the budget inacceptibly. Research is ongoing so as to (1) estimate how much energy would be needed to allow all missions to be executed and (2) how much energy could be saved without further restricting operational capacities. The jammers j0, . . . , jn‚àí1 ‚ààR2 are given along with an initial power consumption. For a given power consumption œâ ‚©æ0, a position q ‚ààR2 is safe under the œâ-umbrella provided by j0, . . . , jn‚àí1, if there is an i ‚àà{0, . . . , n ‚àí1} so that ||q ‚àíji|| ‚©Ω p œâ/4. A mission is speciÔ¨Åed by two positions s and t so that an agent has to move from s to t. During such a movement we do not want the agent to leave the umbrella of protection. More formally, a movement from s to t is a continuous map Œ≥ : [0, 1] ‚ÜíR2 with Œ≥(0) = s and Œ≥(1) = t. A movement Œ≥ is safe under the œâ-umbrella provided by j0, . . . , jn‚àí1, if Œ≥(x) is safe under the œâ-umbrella provided by j0, . . . , jn‚àí1, for all x ‚àà[0, 1]. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers n m p, separated by a space. They denote ‚Äì n, the number of jammers (1 ‚©Ωn ‚©Ω3 ¬∑ 104); ‚Äì m, the number of missions (1 ‚©Ωm ‚©Ω3 ¬∑ 104); ‚Äì p, the initial power consumption (0 < p < 253). ‚Ä¢ The following n lines deÔ¨Åne the individual positions j0, . . . , jn‚àí1 of the jammers. Each position is described by two integer coordinates x y, separated by a space and such that |x|, |y| < 224. You may assume that these positions are pairwise distinct. ‚Ä¢ The following m lines deÔ¨Åne the missions (s0, t0), . . . , (sm‚àí1, tm‚àí1). Each pair (si, ti), for i ‚àà{0, . . . , m ‚àí1}, is described by four integer coordinates x0 y0 x1 y1, separated by a space and such that |x0|, |y0|, |x1|, |y1| < 224. Output: For each test case output three lines. ‚Ä¢ The Ô¨Årst line contains a string c0c1 . . . cm‚àí1 of m characters, where ci = y, if there exists a valid safe movement from si to ti under the p-umbrella provided by j0, . . . , jn‚àí1, and ci = n, otherwise. 1 ‚Ä¢ The second line consists of a single integer a that denotes the smallest power consumption that allows to execute all given missions. More precisely, a is the smallest integer such that there exists a valid safe movement from si to ti under the a-umbrella provided by j0, . . . , jn‚àí1, for all i ‚àà{0, . . . , m ‚àí1}. ‚Ä¢ The third line consists of a single integer b that denotes the smallest power consumption that allows to execute the same set of missions as possible at power consumption p. More precisely, b is the smallest nonnegative integer such that if there exists a valid safe movement from si to ti under the p-umbrella provided by j0, . ....","GoldenEye - solution In order to solve this problem, it's better to take a look at the example code in _emst.cpp_. Firstly, it's necessary to create the triangulation with the jammer positions. Each vertex of the triangulation needs to have its own index as info. While iterating through all the finite vertices of the triangulation, it's possible to represent them with the indexes of the two vertices they connect: - An edge is stored as a pair of a face and the index (from 0 to 2) of the vertex that is opposite to the edge in the face: - If i...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <algorithm>

#include <boost/pending/disjoint_sets.hpp>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> graph;

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <CGAL/Triangulation_face_base_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Triangulation_vertex_base_with_info_2<int, K>  Vb;
typedef CGAL::Triangulation_face_base_2<K> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<K, Tds> Triangulation;

typedef K::Point_2 P;

typedef struct{
  int from;
  int to;
  long sq_len;
} edge_t;  //Edge in the triangulation

struct orderEdges{
  bool operator()(edge_t &e1, edge_t &e2){
    return e1.sq_len < e2.sq_len;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;  //n = jammers, m = missions
    long p;  //p = initial power
    std::cin>>n>>m>>p;

    std::vector<std::pair<P, int>> jammers(n);
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      jammers[i] = {P(x, y), i};
    }

    Triangulation tri;
    tri.insert(jammers.begin(), jammers.end());

    std::vector<edge_t> covered_edges;  //Edges covered with the inital power
    std::vector<edge_t> all_edges;  //All edges

    for (auto e = tri.finite_edges_begin(); e != tri.finite_edges_end(); e++) {
      //An edge is stored as a pair of a face and the index (from 0 to 2) of the vertex
      //which is opposite to the edge in the face. This means that:
      //face = e->first
      //v1 = (e->second+1)%3, v2 = (e->second+2)%3
      //At this point, it's possible to get the indexes of the vertices at the triangulation level
      int i1 = e->first->vertex((e->second+1)%3)->info();
      int i2 = e->first->vertex((e->second+2)%3)->info();

      long sq_len = tri.segment(e).squared_length();

      //Safe if len/2 <= sqrt(p/4) -> len^2 <= p
      if(sq_len <= p){
        covered_edges.push_back({i1, i2, sq_len});
      }
      all_edges.push_back({i1, i2, sq_len});
    }

    //Sort the edges by the squared length
    std::sort(covered_edges.begin(), covered_edges.end(), orderEdges());
    std::sort(all_edges.begin(), all_edges.end(), orderEdges());

    //Find connected components with BGL
    graph G(n);
    for(edge_t e: covered_edges){
      boost::add_edge(e.from, e.to, G);
    }
    std::vector<int> component(boost::num_vertices(G));
    connected_components(G, &component[0]);

    //Disjointed sets for faster dynamic connected components
    boost::disjoint_sets_with_storage<> all_graph(n);
    boost::disjoint_sets_with_storage<> covered_graph(n);

    auto all_it = all_edges.begin();
    auto covered_it = covered_edges.begin();

    long power_all = 0;
    long power_covered = 0;

    for(int i = 0; i < m; i++){
      int x0, y0, x1, y1;
      std::cin>>x0>>y0>>x1>>y1;

      P start(x0, y0);
      P end(x1, y1);

      //Find the distance to the nearest jammers to the start position of the mission
      auto near_start = tri.nearest_vertex(start);
      int near_start_index = near_start->info();
      long sq_d_start = CGAL::squared_distance(start, near_start->point());

      //Find the distance to the nearest jammers to the end position of the mission
      auto near_end = tri.nearest_vertex(end);
      int near_end_index = near_end->info();
      long sq_d_end = CGAL::squared_distance(end, near_end->point());

      //Update the power to execute all mission making sure to cover both start and end positions
      power_all = std::max(power_all, sq_d_start*4);
      power_all = std::max(power_all, sq_d_end*4);

      //Add edges to the disjointed set until the jammer near the start and the jammer near
      //the end are both in the same connected component
      int near_start_set, near_end_set;
      while(all_it != all_edges.end() &&
        ((near_start_set = all_graph.find_set(near_start_index)) != (near_end_set = all_graph.find_set(near_end_index)))){

        power_all = std::max(power_all, all_it->sq_len);

        int from_set = all_graph.find_set(all_it->from);
        int to_set = all_graph.find_set(all_it->to);

        if(from_set != to_set){
          all_graph.link(all_it->from, all_it->to);
        }
        all_it++;
      }

      //Check if the start and end positions are covered by their closest jammers
      //d <= sqrt(p/4) -> d^2 <= p / 4
      if(sq_d_start * 4 > p){
        std::cout<<""n"";
        continue;
      }

      if(sq_d_end * 4 > p){
        std::cout<<""n"";
        continue;
      }

      //Check if the jammers near the start and the end positions are in the same connected components
      if(component[near_start_index] != component[near_end_index]){
        std::cout<<""n"";
        continue;
      }

      //The mission can be done
      std::cout<<""y"";

      //Update the power to execute the same mission making sure to cover both start and end positions
      power_covered = std::max(power_covered, sq_d_start*4);
      power_covered = std::max(power_covered, sq_d_end*4);

      //Add edges to the disjointed set until the jammer near the start and the jammer near
      //the end are both in the same connected component
      while(covered_it != covered_edges.end() &&
        ((near_start_set = covered_graph.find_set(near_start_index)) != (near_end_set = covered_graph.find_set(near_end_index)))){

        power_covered = std::max(power_covered, covered_it->sq_len);

        int from_set = covered_graph.find_set(covered_it->from);
        int to_set = covered_graph.find_set(covered_it->to);

        if(from_set != to_set){
          covered_graph.link(covered_it->from, covered_it->to);
        }
        covered_it++;
      }
    }

    std::cout<<""\n"";
    std::cout<<power_all<<""\n"";
    std::cout<<power_covered<<""\n"";
  }
}
"
"H1N1","given user of the device is able to escape the contaminated area, assuming that all infected individuals stay at their current location. In order to escape, the user must be able to get arbitrarily far from all infected people, without ever coming closer than a given distance d to any of them. Input: We consider the situation as seen from above, such that people appear as points in the plane. The input contains several test cases. Each of them is described as follows. ‚Ä¢ It starts with a line that contains a single integer n (2 ‚©Ωn ‚©Ω6¬∑104), denoting the number of infected people in the area. ‚Ä¢ The next n lines contain their integer coordinates x y separated by a space and so that |x|, |y| < 224. ‚Ä¢ The following line contains a single integer m (1 ‚©Ωm ‚©Ω4 ¬∑ 104) denoting the number of users asking for an escape route. These are to be checked one by one separately, that is, they should be considered separate queries. None of them is infected. ‚Ä¢ Finally, each of the subsequent m lines describes a user who wants to escape. Each user is speciÔ¨Åed by three integer coordinates x, y, and d, separated by space and such that |x|, |y| < 224 and 0 ‚©Ωd < 249. The person is located at position (x, y) and wants to keep distance at least ‚àö d from the infected (i.e., ‚àö d is still allowed). The input is... Output: For every test case the corresponding output appears on a single line consisting of m characters ‚Äúy‚Äù or ‚Äún‚Äù (one letter per query). Output the letter ‚Äúy‚Äù, if there is a way to escape, and ‚Äún‚Äù, otherwise.","H1N1 - solution The idea is that, from a certain face, it's necessary to find a way out. This means that, for each face traversed to reach the exit, there must be an edge in the triangulation whose length is adequate and that was not traversed before. This problem is called the _widest path problem_, where, given a starting point, it's necessary to find the route to the destination, making sure to maximize the minimum edge weight traversed. Considering that the destination is any of the infinite faces, it's possible to store, for each face...","Dijkstra / Shortest path","#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <climits>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_face_base_with_info_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel EPIC;

typedef CGAL::Triangulation_vertex_base_2<EPIC> Vb;
typedef CGAL::Triangulation_face_base_with_info_2<EPIC::FT, EPIC> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<EPIC, Tds> Triangulation;

typedef EPIC::Point_2 P;

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;
    std::cin>>n;

    if(n == 0){
      break;
    }

    std::vector<P> infected(n);
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      infected[i] = P(x, y);
    }

    //Triangulation of the infected people
    Triangulation t;
    t.insert(infected.begin(), infected.end());

    //Priority queue that contains pairs.
    //The default behaviour is ordering the pairs by the first element of each pair
    std::priority_queue<std::pair<long, Tds::Face_handle>> q;
    for (auto f = t.all_faces_begin(); f != t.all_faces_end(); f++){
      if(t.is_infinite(f)){
        f->info() = LONG_MAX;
      }else{
        f->info() = 0;

        for(int i = 0; i < 3; i++){
          auto neighbor = f->neighbor(i);

          if(t.is_infinite(neighbor)){
            //Associate with each face near the border the space available to escape to infinity
            q.push({t.segment(f, i).squared_length(), f});
          }
        }
      }
    }

    while(!q.empty()){

      auto current = q.top();
      q.pop();

      //Face was already considered or is an infinite face
      if(current.second->info() != 0){
        continue;
      }

      //Associate to each face the space available to escape to infinity
      current.second->info() = current.first;

      for(int i = 0; i < 3; i++){
        auto neigh = current.second->neighbor(i);

        if(!t.is_infinite(neigh)){
          //The space available to escape from a face is the bottleneck
          //of the best path from the current face to infinity
          long edge = t.segment(current.second, i).squared_length();
          long best = std::min(current.first, edge);

          q.push({best, neigh});
        }
      }
    }

    int m;
    std::cin>>m;
    for(int i = 0; i < m; i++){
      long x, y, d;
      std::cin>>x>>y>>d;

      auto nearest = t.nearest_vertex(P(x, y));
      long dist = CGAL::squared_distance(nearest->point(), P(x, y));

      //Check if the current person is already too close to an infected person
      if(dist < d){
        std::cout<<""n"";
        continue;
      }

      //Check if the best path to infinity is large enough
      auto locate = t.locate(P(x, y));
      if(locate->info() < 4*d){
        std::cout<<""n"";
      }else{
        std::cout<<""y"";
      }
    }
    std::cout<<""\n"";
  }
}
"
"Octopussy","Bond took over a case from Agent 009 who met an untimely end in the British embassy in East-Berlin. During his investigations James meets Octopussy, a mysterious, beautiful, and fabulously wealthy woman. She lives in a luxurious island palace, from where she runs a wide network of business enterprises such as shipping, hotels, carnivals, and circuses. A less known fact is that Octopussy also is a successful jewellery smuggler. Together with her friend Kalam Khan‚Äîan exiled prince‚Äîshe uses the circus as a cover for various illegal activities. While trying to inÔ¨Åltrate the smuggling operation, Bond discovers a much greater threat. Khan has a grand evil plan which even Octopussy is oblivious of. He uses Octopussy‚Äôs circus to hide a nuclear warhead in each of n balls B0, . . . , Bn‚àí1, which play a central role in one of the circus‚Äô acts. The warheads are set to explode during a performance at an US Air Force base in West Germany so as to start World War III. The bombs have timers which activate at the start of the show. The timer in Bi lets the bomb explode exactly ti minutes after activation. After revealing Khan‚Äôs plans, Bond convinces Octopussy to work with him against Khan to deactivate the bombs. Fortunately, Octopussy gained some crucial information just before the start of the show: the bombs are connected in a sophisticated way in order to make them, as Khan believes... Input: The Ô¨Årst line of the input contains the number t ‚©Ω50 of test cases. Each of the t test cases is described as follows.  It starts with a line that contains one integer n, the number of balls (n = 2i ‚àí1, for i ‚àà{1, . . . , 16}).  The following line deÔ¨Ånes the individual explosion times of the bombs. The line contains n integers t0 . . . tn‚àí1, separated by a space, and such that 1 ‚©Ωti ‚©Ω230, for i ‚àà {0, . . . , n ‚àí1}. Output: For each test case the corresponding output appears on a separate line. Output the string ‚Äòyes‚Äô, if Bond can deactivate all bombs, that is if there is a permutation œÄ: {0, . . . , n‚àí1} ‚Üí 1 {0, . . . , n ‚àí1} (which we interpret as ‚Äòthe bomb in Bi is the œÄ(i)-th bomb to be deactivated‚Äô) such that  œÄ(i) < ti, for every i ‚àà{0, . . . , n ‚àí1}, and  œÄ(x) < œÄ(y), for each pair (x, y) such that By stands on Bx. If such a permutation does not exist, output the string ‚Äòno‚Äô.","Octopussy - solution Recursive method Each bomb is stored in a custom struct that contains its index (to be able to determine quickly the bombs that are under it), if it was already defused, and the time at which it will explode. At first, it's necessary to store in an ordered vector (determined recursively) all the bombs that it's necessary to defuse before defusing the current bomb (each bomb has such a vector that can contain bombs of multiple levels below). This vector is the ordered union of the two vectors of the left and right bottom...","Implementation","#include <iostream>
#include <vector>
#include <algorithm>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<int> times(n);
    for(int i = 0; i < n; i++){
      int exp_t;
      std::cin>>exp_t;

      times[i] = exp_t;
    }

    //Assign to each bomb the minimum time it needs to be defused in order to avoid an explosion
    //Each bomb must be defused before it explodes or 1 second before its parent explodes (minimum of the two)
    for(int j = 0; j <= (n-3)/2; j++){
      times[2*j+1] = std::min(times[j]-1, times[2*j+1]);
      times[2*j+2] = std::min(times[j]-1, times[2*j+2]);
    }

    std::sort(times.begin(), times.end());

    //Check if, by defusing a bomb a second, it's possible to avoid an explosion
    bool explosion = false;
    for(int i = 0; i < n; i++){
      if(i >= times[i]){
        explosion = true;
        break;
      }
    }

    if(explosion){
      std::cout<<""no\n"";
    }else{
      std::cout<<""yes\n"";
    }
  }
}
"
"Diet","given the constraints for an individual and the food which is available in the area where the individual lives, calculates the cheapest diet (that means amounts of each product such that the total amounts of each nutrient fulÔ¨Ålls the prescribed conditions; these amounts do not need to be integral - it is possible to consume any fractional amount of a product in a day). They understand though, that it is an uneasy task on such a short notice and will for now be happy with an alpha version which only calculates the price of a cheapest diet. Input: The input Ô¨Åle consists of several test cases. Each of them starts with a line containing two integers n and m (1 ‚©Ωn ‚©Ω40 and 1 ‚©Ωm ‚©Ω100). The following n lines describe the nutrients. The ith of these lines contains two integers mini and maxi, the minimal and maximal daily amount of the ith nutrient. The next m lines describe the foods. Each of them contains an integer price of a unit of the jth product, pj, and another n integers Cj,1 . . . Cj,n describing the amounts of nutrients 1 . . . n in a unit of product j. All the above integer values are in absolute value smaller than 220. The input is terminated by a line 0 0. All the numbers on a single line are separated by a single space and there are no trailing whitespaces at the end of a line. Output: The output for each testcase is a line containing a single number c, the cost of the cheapest diet rounded down to an integer. If there is no diet fulÔ¨Ålling the criteria, output the line ""No such diet."". Please note the trailing dot and that no trailing spaces at the end of the line are allowed.","Diet - solution For each nutrient, there are two inequalities. Considering $q_j$ the quantity of food $j$ to use and $c_{i, j}$ the quantity of the nutrient $i$ that the food $j$ gives, the inequalities are: - $q_1 \cdot c_{i,1} + ... + q_j \cdot c_{i, j} \leq max_i$ - $-q_1 \cdot c_{i,1} - ... - q_j \cdot c_{i, j} \leq -min_i$. All the inequalities must have the same verse, so it's necessary to change the original verse of this inequality by multiplying it by $(-1)$. The objective function, considering $p_j$ the price of the food $j$ is $q_1...","Computational Geometry (CGAL)","#include <iostream>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpq.h>

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

long floor_to_long(const CGAL::Quotient<ET> &x){
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a + 1 <= x) a += 1;
  return a;
}


int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n, m; //n = nutrients, m = foods
    std::cin>>n>>m;

    if(n == 0 && m == 0){
      break;
    }

    //Each food can be taken in only non-negative amounts
    Program lp (CGAL::SMALLER, true, 0, false, 0);

    for(int i = 0; i < n; i++){
      int min, max;
      std::cin>>min>>max;

      lp.set_b(2*i, -min);
      lp.set_b(2*i+1, max);
    }

    for(int j = 0; j < m; j++){
      int p;
      std::cin>>p;

      lp.set_c(j, p);

      for(int i = 0; i < n; i++){
        int c;
        std::cin>>c;

        lp.set_a(j, 2*i, -c);
        lp.set_a(j, 2*i+1, c);
      }
    }

    Solution s = CGAL::solve_linear_program(lp, ET());

    if(s.is_infeasible()){
      std::cout<<""No such diet.\n"";
    }else{
      std::cout<<floor_to_long(s.objective_value())<<""\n"";
    }
  }
}
"
"Inball","The many-dimensional country of Ballland experienced a natural disaster and all its inhibitants have to seek shelter in its sophisticated system of underground caves. Unfortunatelly, some of the inhabitants of the Ballland have grown quite large (they are ball-shaped, indeed), it is necessary to Ô¨Ågure out, how large inhabitants cave can still be accomodated in each cave. Each cave C is of a polyhedral shape, i.e., is described by n linear inequalities C = {x ‚ààRd | aT i x ‚©Ωbi , i = 1, . . . , n}, where ai ‚ààRd, bi ‚ààR. Here aT i x denotes the standard scalar product of ai and x, i.e., aT i x := Pd j=1(ai)jxj. Input: The input contains several test cases. Each test case describes one cave. It begins with a line containing two integers n and d (1 ‚©Ωd ‚©Ω10, 1 ‚©Ωn ‚©Ω103) where n is the number of inequalities describing the cave and d is its dimension. Each subsequent line describes one inequality aT i x ‚©Ωbi and consist of d + 1 space separated integers (ai)1(ai)2 . . . (ai)dbi (‚àí210 ‚©Ω(ai)1, . . . , (ai)d, bi ‚©Ω210). It is guaranteed, that the norm ‚à•ai‚à•2 = qPd j=1((ai)j)2 of each ai is an integer. The input is terminated by a line containing a single value 0. Output: For each input, the output appears on a single and separate line. This line consists of a single integer r denoting the maximum integral radius of a d-dimensional ball, which Ô¨Åts into the cave. If the cave is an empty set, the word none is to be printed. If an arbitrarily large ball can be Ô¨Åt into the cave, the word inf should be printed. 3 4 5 1","Inball - solution The distance of the center point of a ball $x = (x_1, x_2, ..., x_d)$ to a plane is $D = \frac{|a_1 \cdot x_1 + a_2 \cdot x_2 + ... + a_d \cdot x_d - b|}{\sqrt{{a_1}^2 + ... + {a_d}^2}}$. This formula must be true for all the inequalities given by the problem that describe a plane in $d$ dimensions. Considering that $a_1 \cdot x_1 + a_2 \cdot x_2 + ... + a_d \cdot x_d \leq b$, the numerator is always negative, so it's always necessary to multiply it by $(-1)$ to make sure the absolute value gives a positive result. It's...","Computational Geometry (CGAL)","#include <iostream>
#include <algorithm>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int n;  //n = inequalities
    std::cin>>n;

    if(n == 0){
      break;
    }

    int d;  //d = dimensions
    std::cin>>d;

    Program lp (CGAL::SMALLER, false, 0, false, 0);

    //Variable that is the distance to the planes
    //All the other variables have index from 0 to d-1
    const int D = d;

    for(int i = 0; i < n; i++){

      //Sum of the square roots of the coefficients
      int sq_sum = 0;

      //The distance to a plane (in any dimensions) is:
      //D = |a_1 * x_1 + a_2 * x_2 + ... - b| / sqrt(||a||)

      //Given D * sqrt(||a||) = |y-b|, where y = a_1 * x_1 + a_2 * x_2 + ...
      //Considering that y <= b, we have D * sqrt(||a||) = -y+b
      //It's equal to D * sqrt(||a||) <= -y+b and D * sqrt(||a||) >= -y+b.
      //Considering that it's necessary to maximise D, the first one is chosen

      lp.set_l(D, true, 0);

      for(int j = 0; j < d; j++){
        int a;
        std::cin>>a;

        //Variable j, equation i
        lp.set_a(j, i, a);

        sq_sum += a*a;
      }

      lp.set_a(D, i, std::sqrt(sq_sum));

      int b;
      std::cin>>b;

      lp.set_b(i, b);
    }

    //Maximize the distance to the planes, so minimize the opposite
    lp.set_c(D, -1);

    Solution s = CGAL::solve_linear_program(lp, ET());

    if(s.is_unbounded()){
      std::cout<<""inf\n"";
    }else if(s.is_infeasible()){
      std::cout<<""none\n"";
    }else{
      std::cout<< -s.objective_value_numerator()/s.objective_value_denominator() <<""\n"";
    }
  }
}
"
"Kingdom Defence","given a map of the (directed) paths between the most important strategic locations in the kingdom of swamps. Every location has a number of soldiers available and every location needs a certain number of soldiers to defend itself. In order to display military presence, each path has to be travelled by soldiers a certain minimum number of times. Also, because soldiers on the move constantly need to supply themselves with food, each path can be traversed by soldiers at most a certain maximum number of times. Note that a single soldier may use the same path multiple times and each time counts as one traversal. You have to decide whether it is possible to satisfy all these requirements by moving battalions of soldiers around in the kingdom. Input: The first line of the input contains the number t ‚©Ω32 of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a single line containing two integers l p, separated by a space, denoting ‚Äì l, the number of locations (1 ‚©Ωl ‚©Ω500). ‚Äì p, the number of paths (1 ‚©Ωp ‚©Ωl2). ‚Ä¢ The next l lines each give the details of one location. The i-th such line contains two space-separated integers 1 ‚©Ωgi, di ‚©Ω106, the number of soldiers stationed at location i and the number of soldiers that location i needs to defend itself, respectively. Note that gi > 0 for all locations. ‚Ä¢ After that, there are p lines, each specifying one path in the kingdom. Each path is given by four integers 0 ‚©Ωfj, tj < l and 0 ‚©Ωcj ‚©ΩCj ‚©Ω106. The j-th path is one-way and goes from location fj to location tj (zero-based indexing, fj and tj can be equal!). The path needs to be traversed at least cj and by at most Cj times. 1 Output: For every test case output a single line containing the word yes, if the soldiers can be moved such that during the move enough military presence is displayed along every path and after moving every location is well defended, and the word no otherwise.","Kingdom Defence - solution Given the number of soldiers present and needed at a location, it's possible to find the demand and supply for each location (supply stored positively and demand stored negatively). Each path (the edge of a max flow graph) has capacity equal to the difference between the maximum and the minimum capacity of that path. The source location of the path has an increase in demand equal to the minimum capacity. The destination location of the path has an increase in supply equal to the minimum capacity. All the locations...","Max Flow / Min Cut","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
    boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int l, p; //l = locations, p = paths
    std::cin>>l>>p;

    std::vector<int> supply(l);  //Positive if supply, negative number if demand
    for(int i = 0; i < l; i++){
      int s, d;
      std::cin>>s>>d;

      supply[i] = s-d;
    }

    graph G(l);
    edge_adder adder(G);

    for(int i = 0; i < p; i++){
      int from, to, min_c, max_c;
      std::cin>>from>>to>>min_c>>max_c;

      //capacity of the edge is the difference between the maximum and the minimum capacity
      adder.add_edge(from, to, max_c-min_c);

      supply[from] -= min_c;  //Increase demand (decrease supply) of from
      supply[to] += min_c;  //Increase supply of to
    }

    const int source = l;
    const int sink = source+1;

    int tot_demand = 0;
    for(int i = 0; i < l; i++){
      //Connect supply to source and demand to sink
      if(supply[i] > 0){
        adder.add_edge(source, i, supply[i]);
      }else{
        tot_demand += -supply[i];
        adder.add_edge(i, sink, -supply[i]);
      }
    }

    long flow = boost::push_relabel_max_flow(G, source, sink);
    if(flow == tot_demand){
      std::cout<<""yes\n"";
    }else{
      std::cout<<""no\n"";
    }
  }
}
"
"Suez","given a full dossier containing posters of wanted thieves, burglars, murderers, as well as the vague description of an as of yet unnamed gentleman who is suspected to have stolen the record-breaking sum of ¬£55‚Äô000 from the Bank of England not more than a week ago. The detective wants to display all posters on a wall in his oÔ¨Éce. For that purpose there is a number of nails at Ô¨Åxed positions on the wall, where each nail can be used to hang up exactly one poster. A large number of these nails is already occupied with posters of those who have been brought to justice by Fix in the past. Luckily, the number of remaining unoccupied nails is exactly equal to the number of new posters that the detective wants to add. Needless to say, being the perfectionist that he is, Fix does not want any of the posters (either old or new) to overlap. Nor does he want to hang up any of the posters sideways or at an angle. It should also go without saying that the trophies from his past‚Äîthat is, the posters that are already on the wall‚Äîare to remain untouched. By decree AW-80d, all posters provided by Scotland Yard have the exact same format; they are h inches high and w inches wide. This holds for both the old posters and the new. However, Fix believes that maximizing the sum of perimeters of all new posters will also maximize his chance of recognizing one of the faces. He is thus willing to... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing four integers n m h w, separated by a space. They denote ‚Äì n, the number of new posters to be added to the wall (2 ‚©Ωn ‚©Ω30); ‚Äì m, the number of old posters already hanging on the wall (0 ‚©Ωm ‚©Ω103); ‚Äì h, the height of the posters as per AW-80d (0 < h < 27); ‚Äì w, the width of the posters as per AW-80d (0 < w < 27). 1 ‚Ä¢ The following n lines deÔ¨Åne the positions of the free nails on the wall. ‚Ä¢ The following m lines deÔ¨Åne the positions of the already occupied nails on the wall. Each position is described by two integers x y, separated by a space and such that |x|, |y| < 224. Here, x and y denote the coordinates in inches of the corresponding nail on the wall. You may assume that the n+m positions of all nails are such that it is possible to hang up a poster with size h-by-w centered at each nail without any overlap. Output: For each test case output on a separate line the maximum attainable sum of perimeters of the new posters in inches, rounded up to the nearest integer.","Suez - solution In this problem, the input values are fractions, so the input type and the type for the solver should be CGAL::Gmpq. First of all, it's necessary to set the constraints between new posters. It's necessary to consider that: - $x_1 + \frac{a_1 \cdot w}{2} \leq x_2 - \frac{a_2 \cdot w}{2}$ ‚Üí $\frac{w}{2} \cdot (a_1+a_2) \leq x_2 - x_1$ ‚Üí $a_1+a_2 \leq \frac{2 \cdot (x_2-x_1)}{w}$. The same applies for the y-axis. To choose the constraint for $a_1+a_2$ it's necessary to get the maximum between $\frac{2 \cdot |x_2-x_1|}{w}$ and...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpq.h>

typedef CGAL::Gmpq IT;
typedef CGAL::Gmpq ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

struct nail{
  int x;
  int y;
};

//The answer is a quotient of two quotients
long floor_to_long(const CGAL::Quotient<ET> &x){
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a + 1 <= x) a += 1;
  return a;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;

  while(t--){
    int n, m, h, w; //n = new posters, m = old posters, h = base height, w = base width
    std::cin>>n>>m>>h>>w;

    std::vector<struct nail> new_posters(n);
    //Save new posters
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      new_posters[i] = {x, y};
    }

    std::vector<struct nail> old_posters(m);
    //Save old posters
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      old_posters[i] = {x, y};
    }

    //Magnifications cannot be lower than 1
    Program lp (CGAL::SMALLER, true, 1, false, 0);

    int in_number = 0;  //Number of the current inequality
    for(int i = 0; i < n; i++){
      for(int j = i+1; j < n; j++){

        //The limits for new posters are (if x1 < x2):

        //x1 + a1*w/2 < x2 - a2*w/2
        //w/2 * (a1+a2) < x2 - x1
        //a1+a2 < 2*(x2-x1)/w

        //To avoid checking for x1 < x2, it's possible to take the absolute value
        //The same thing applies for the y axis

        int x_dist_2 = 2*(std::abs(new_posters[j].x - new_posters[i].x));
        int y_dist_2 = 2*(std::abs(new_posters[j].y - new_posters[i].y));

        lp.set_a(i, in_number,  1);
        lp.set_a(j, in_number,  1);

        //While growing, the posters may overlap first on the x axis or the y axis
        //For this reason, it's necessary to limit the growth to the axis that will be limited first
        //It's necessary to pick the biggest between 2*|x2-x1|/w and 2*|y2-y1|/h
        //(Do not pick the minimum. Think about the case where x2 = x1, that would lead to 0 as the limit)
        lp.set_b(in_number, std::max(IT(y_dist_2, h), IT(x_dist_2, w)));
        in_number++;
      }
    }

    //For each new poster, limit the growth to the closest old poster
    for(int i = 0; i < n; i++){
      //x1 + a1*w/2 < x2 - w/2
      //a1 < (x2 - x1 - w/2)*(2/w)
      //a1 < (2*(x2-x1) - w)/w
      //Absolute value of (x2-x1) to consider all cases automatically

      IT min_bound(1234567890);
      for(int j = 0; j < m; j++){
        int x_dist_2 = 2*(abs(new_posters[i].x - old_posters[j].x)) - w;
        int y_dist_2 = 2*(abs(new_posters[i].y - old_posters[j].y)) - h;

        //Chosing the max between x_dist_2 and y_dist_2 as above
        if(min_bound > std::max(IT(y_dist_2, h), IT(x_dist_2, w))){
          min_bound = std::max(IT(y_dist_2, h), IT(x_dist_2, w));
        }
      }
      if(m > 0){  //Avoid inserting an incorrect constraint
        lp.set_u(i, true, min_bound);
      }
    }

    for(int i = 0; i < n; i++){
      //Minimize the opposite to maximize the objective function
      lp.set_c(i, -2*(h+w));
    }

    Solution s = CGAL::solve_linear_program(lp, ET());

    std::cout<<-floor_to_long(s.objective_value())<<""\n"";

  }
}
"
"What is the Maximum","Your company often needs to solve simple optimization problems of two types. (1) max b ¬∑ y ‚àía ¬∑ x s.t. x, y ‚©æ0 x + y ‚©Ω4 4x + 2y ‚©Ωab ‚àíx + y ‚©Ω1 (2) min a ¬∑ x + b ¬∑ y + z s.t. x, y, z ‚©Ω0 x + y ‚©æ‚àí4 4x + 2y + z ‚©æ‚àíab ‚àíx + y ‚©æ‚àí1 For any values of parameters a and b, Ô¨Ånd the optimal value. Input: The input consist of several test sets. Each test set is on a separate line, constisting of three values p a b, where p is the type of the problem to solve (p ‚àà{1, 2}) and a, b are the values of the parameters (0 ‚©Ωa ‚©Ω100 and ‚àí100 ‚©Ωb ‚©Ω100). The input is terminated by a line containing only 0. Output: For each test set, write on a separate line the optimal value of the problem of type p with parameters a, b, rounded down to the next integer for the maximization problem, and rounded up to the next integer for the minimization problem. If there is no solution, write no and if there are solutions of arbitrarily high value (arbitrarily low for minimization), then output unbounded.","What is the Maximum - solution To improve readability, it's better to give a name to the variable indexes, for example, const int X = 0. The solver always minimizes the objective function. It's necessary to invert all the signs in the objective function to maximize it, then it's necessary to invert the sign of the objective value to have the right result.","Computational Geometry (CGAL)","#include <iostream>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

long floor_to_long(const CGAL::Quotient<ET> &x){
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return a;
}

long ceil_to_long(const CGAL::Quotient<ET> &x){
  double a = std::ceil(CGAL::to_double(x));
  while (a < x) a += 1;
  while (a-1 >= x) a -= 1;
  return a;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  while(true){
    int p;
    std::cin>>p;

    if(p == 0){
      break;
    }

    int a, b;
    std::cin>>a>>b;

    const int X = 0;
    const int Y = 1;
    const int Z = 2;

    if(p == 1){
      Program lp (CGAL::SMALLER, true, 0, false, 0);

      //x+y >= -4
      lp.set_a(X, 0, 1); lp.set_a(Y, 0, 1); lp.set_b(0, 4);

      //4x+2y <= ab
      lp.set_a(X, 1, 4); lp.set_a(Y, 1, 2); lp.set_b(1, a*b);

      //‚àíx+y <= 1
      lp.set_a(X, 2, -1); lp.set_a(Y, 2, 1); lp.set_b(2, 1);

      //Max (by - ax)  --> Min (-by + ax)
      lp.set_c(Y, -b); lp.set_c(X, a);

      Solution s = CGAL::solve_linear_program(lp, ET());

      if(s.is_unbounded()){
        std::cout<<""unbounded\n"";
      }else if(s.is_infeasible()){
        std::cout<<""no\n"";
      }else{
        std::cout<<floor_to_long(-s.objective_value())<<""\n"";
      }
    }else{
      Program lp (CGAL::SMALLER, false, 0, true, 0);

      //x+y <= -4 --> -x-y <= 4
      lp.set_a(X, 0, -1); lp.set_a(Y, 0, -1); lp.set_b(0, 4);

      //4x+2y+z >= -ab --> -4x-2y-z <= ab
      lp.set_a(X, 1, -4); lp.set_a(Y, 1, -2); lp.set_a(Z, 1, -1); lp.set_b(1, a*b);

      //‚àíx+y >= -1 --> x-y <= 1
      lp.set_a(X, 2, 1); lp.set_a(Y, 2, -1); lp.set_b(2, 1);

      //Min ax+by+z
      lp.set_c(X, a); lp.set_c(Y, b); lp.set_c(Z, 1);

      Solution s = CGAL::solve_linear_program(lp, ET());

      if(s.is_unbounded()){
        std::cout<<""unbounded\n"";
      }else if(s.is_infeasible()){
        std::cout<<""no\n"";
      }else{
        std::cout<<ceil_to_long(s.objective_value())<<""\n"";
      }
    }
  }
}
"
"Algocoon","The startup you created with your best friend is a great success. On impulse, you jointly decide to spend a big chunk of your profits on one of those ancient Greek sculptures depicting a group of mythological figures entangled in a complicated configuration. You are presented with several sculptures to choose from. Unfortunately, you can afford only one sculpture and both of you would like to take it home. A brilliant idea you have is to hire a stonecutter to cut the sculpture in two parts. Every sculpture consists of several figures, each of them equipped with (possibly large) number of limbs. Each limb reaches some other figure and has a cost that the cutter will charge for separating it. The deal is as follows: you will decide on how to cut the sculpture (i.e., which figures you take home). Both you and your partner need to get at least one figure. To share the cost, you pay for cutting the limbs of your figures and your friend for limbs of her figures. Your objective is to write a program that will go over all sculptures and for each of them find a cutting that minimizes your cost. Input: The first line contains 1 ‚©Ωt ‚©Ω30, the number of test cases. Each of the t sculptures is described as follows: ‚Ä¢ It starts with a line that contains two numbers n m, separated by a space. They denote ‚Äì 2 ‚©Ωn ‚©Ω200, the number of figures in the sculpture and ‚Äì 0 ‚©Ωm ‚©Ω5000, the total number of limbs between the figures. ‚Ä¢ m lines follow, each of them containing three numbers a b c, indicating that figure a has a limb that extends to figure b with cutting cost c (with 0 ‚©Ωa, b < n, a Ã∏= b and 1 ‚©Ωc ‚©Ω1000). Note that a figure can have several limbs extending to the same other figure. Output: For every test case output a single line with the total cost of an optimal cut.","Algocoon - solution The solution can be found by finding the minimum cut, dividing nodes from $0$ to $i-1$ in one part and nodes from $i$ to $n-1$ in the other. In the minimum cut, it's necessary to count only the costs of the edges in one of the two directions, not both. In this case, the solution may come from either one of the two directions (the one with the smallest minimum cut is the correct one), meaning that it's necessary to calculate two maximum flows for each possible division. To find the minimum cut, it's necessary to calculate...","Max Flow / Min Cut","#include <iostream>
#include <climits>
#include <algorithm>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
  boost::property<boost::edge_capacity_t, long,
    boost::property<boost::edge_residual_capacity_t, long,
      boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef boost::graph_traits<graph>::out_edge_iterator out_edge_it;
typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0; // reverse edge has no capacity!
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};


int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; //n = figures, m = limbs
    std::cin>>n>>m;

    graph G(n);
    edge_adder adder(G);

    std::vector<std::pair<int, int>> costs(n);
    for(int i = 0; i < m; i++){
      int a, b, c;
      std::cin>>a>>b>>c;  //From a to b with cost c

      adder.add_edge(a, b, c);
    }

    //Find the minimum cut (= maximum flow) for each possible division
    //It does not matter with node in S or T is chosen (but in T it's necessary
    //to choose the first one to have a division)
    //It's necessary to consider both directions
    long flow = LONG_MAX;
    for(int i = 1; i < n; i++) {
      flow = std::min(flow, boost::push_relabel_max_flow(G, 0, i));
      flow = std::min(flow, boost::push_relabel_max_flow(G, i, 0));
    }

    std::cout<<flow<<std::endl;
  }
}
"
"Canteen","given day should be served whenever possible. In order to help the canteen to plan accordingly, the students have preregistered. Due to the availability of workers and food, the canteen can only produce a limited amount of menus per day, and menu production costs can vary as well. To save costs, the chef has a brilliant (though not so tasty) idea: He might produce more menus than needed and store the leftovers in the freezer to serve them on any later day. If it is not possible to serve all the students the chef can decide who gets served and who does have to stay hungry as long as he serves as many students as possible. Since this makes planning quite difficult, you are hired by the chef to figure out whether it‚Äôs possible to satisfy AlgoUni‚Äôs demands at all and how much revenue (or loss) can be achieved by the canteen. Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing one integer n, 1 ‚©Ωn ‚©Ω1000, denoting the number of days for which the chef wants to plan ahead. The following prescribes the conditions for the canteen: ‚Ä¢ The second line contains 2n space seperated integers a1, c1, a2, c2, . . . , an, cn denoting for each day i the amount of menus 0 ‚©Ωai ‚©Ω300 that can be produced and the produc- tion cost per menu 0 ‚©Ωci ‚©Ω20. ‚Ä¢ The third line contains 2n space seperated integers s1, p1, s2, p2, . . . , sn, pn denoting for each day i the number of students 0 ‚©Ωsi ‚©Ω300 who want to eat at the canteen and the menu price 0 ‚©Ωpi ‚©Ω20 set by the university. ‚Ä¢ The last line defines the freezer volume and energy cost for each night. These are given by 2n‚àí2 space seperated integers v1, e1, v2, e2, . . . , vn‚àí1, en‚àí1 which denote the number of menus 0 ‚©Ωvi ‚©Ω300 which can be stored overnight from day i to day i + 1 as... Output: For each test case output a line containing the word possible, if the canteen can serve all the students of AlgoUniversity and impossible otherwise. For the rest of the line, print two integers S and P, the maximum number of students that can be served and the maximum profit (or minimum loss) the canteen can achieve. 1","Canteen - solution In the graph, there is a node for each day: - From the source to each day, the capacity is the number of menus that can be cooked, and the cost is the cost per menu. - From each day to the sink, the capacity is the number of students that need to be served, and the cost is $20-p$, where $p$ is the profit from selling a single menu. Using $-p$ would mean considering that selling a menu has a negative cost, so it lowers the minimum cost at the end (the goal is to spend as little as possible). It's necessary to add $20$ because...","Max Flow / Min Cut","#include <iostream>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>
#include <boost/graph/find_flow_cost.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor,
                boost::property <boost::edge_weight_t, long>>>>> graph;

typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}
    void add_edge(int from, int to, long capacity, long cost) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      auto w_map = boost::get(boost::edge_weight, G); // new!
      const edge_desc e = boost::add_edge(from, to, G).first;
      const edge_desc rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0; // reverse edge has no capacity!
      r_map[e] = rev_e;
      r_map[rev_e] = e;
      w_map[e] = cost;   // new assign cost
      w_map[rev_e] = -cost;   // new negative cost
    }
};


int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;  //n = number of days
    std::cin>>n;

    graph G(n);
    edge_adder adder(G);

    const int source = n;
    const int sink = source+1;

    for(int i = 0; i < n; i++){
      int a, c;  //a = amount of menus, c = cost per menu
      std::cin>>a>>c;

      //For each day it's possible to produce a menus with cost c
      adder.add_edge(source, i, a, c);
    }

    int tot_s = 0;
    for(int i = 0; i < n; i++){
      int s, p;  //s = number of students, p = price imposed
      std::cin>>s>>p;

      tot_s += s;

      //For each day, it's possible to serve at most s students, with a revenue of p for each menu (cost is -p)
      //Transform negative cost in a positive cost to use a more efficient function. At the end it's necessary to fix the result
      adder.add_edge(i, sink, s, 20-p);
    }

    for(int i = 0; i < n-1; i++){
      int v, e;  //v = max menus in freezer, e = energy cost per menu
      std::cin>>v>>e;

      //It's possible to transfer a maximum of v menus from one day to another with cost e per menu
      adder.add_edge(i, i+1, v, e);
    }

    //The flow is the amount of students served
    int students = boost::push_relabel_max_flow(G, source, sink);

    //Possible to use after transforming the negative costs
    boost::successive_shortest_path_nonnegative_weights(G, source, sink);

    //Profit is the negative of the remaining cost
    int profit = 20*students - boost::find_flow_cost(G);

    if(students >= tot_s){
      std::cout<<""possible "";
    }else{
      std::cout<<""impossible "";
    }

    std::cout<<students<<"" ""<<profit<<""\n"";
  }
}
"
"Idefix","given orders to root up all the trees in the nearby forest and to surround the village with blocks of flats that would later be filled with tenants from Rome, thus slowly forcing the Gauls to adapt to the superior Roman culture. Needless to say, the attempt has been thwarted swiftly and the Romans have been expelled by Ast√©rix and his friends. But most of the damage has been done already; the village is now surrounded by wasteland, littered with holes reminiscent of the mighty oak trees that once stood in their place. Perhaps the one who suffers the most is Id√©fix; the friendly dog and loyal companion of Ob√©lix is known for howling in distress whenever he sees a tree being injured. Apart from his love for trees, he enjoys chewing on bones and burying them in the ground for later use. Over the years, he has thus buried a large number of bones at various sites in the former forest. He now mourns the good old days when he was able to go for a Sunday afternoon walk‚Äîcovered in the shadows of the oak trees‚Äîvisiting and inspecting the sites where his bones are buried. To everyone‚Äôs great relief, the village druid Panoramix has come up with a new magic potion that will solve the problem. Any acorn that has been soaked in this potion will instantaneously produce a fully grown oak tree, when thrown into one of the holes in the former forest. For simplicity, as seen from above, we assume... Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing four integers n m s k, separated by a space. They denote ‚Äì n, the number of oak trees that will be planted (1 ‚©Ωn ‚©Ω4 ¬∑ 104); ‚Äì m, the number of bones buried in the ground (1 ‚©Ωm ‚©Ω4 ¬∑ 104); ‚Äì s = 4r2, where r is the normal radius of an oak tree (1 ‚©Ωs < 251); ‚Äì k, the minimum number of bones that Id√©fix would like to inspect (1 ‚©Ωk ‚©Ωm). 1 ‚Ä¢ The following n lines define the positions where the oak trees will be planted. ‚Ä¢ The following m lines define the positions where the bones are buried. Each position is described by two integers x y, separated by a space and such that |x|, |y| < 224. You may assume that the n positions corresponding to the oak trees are pairwise distinct. The same does however not hold for the m positions corresponding to the buried bones; that is, there may be more than one bone buried at the same position and there... Output: The output for each test case consists of a separate line containing two integers a q, separated by a space, where q = 4b2. The numbers a and b are as specified earlier. Remark Note that the numbers r and b are not necessarily integers.","Idefix - solution Save the location of the trees with their indexes. This allows for the creation of a triangulation where each vertex has its own index. Using the edge iterator found in the file _emst.cpp_ that allows to extract edges described by vertex indexes from the edges of the triangulation, create two arrays, one containing all the edges covered by the task 1 shadows (it must be $sqLength \leq 4 \cdot r^2$) and the other containing all the edges. Iterating through all the bones, find how many bones are covered by each tree in task 1....","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <algorithm>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <CGAL/Triangulation_face_base_2.h>
#include <boost/pending/disjoint_sets.hpp>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;

typedef CGAL::Triangulation_vertex_base_with_info_2<int, K> Vb;
typedef CGAL::Triangulation_face_base_2<K> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<K,Tds> Delaunay;

typedef K::Point_2 P;

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> graph;
typedef boost::graph_traits<graph>::vertex_descriptor vertex_desc;

typedef struct{
  int from;
  int to;
  long sq_len;
} edge_t;

struct compEdges{
  bool operator()(edge_t &e1, edge_t &e2){
    return e1.sq_len < e2.sq_len;
  }
};

typedef struct{
  P point;
  long sq_d;
} bone_t;

struct compBones{
  bool operator()(bone_t &b1, bone_t &b2){
    return b1.sq_d < b2.sq_d;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; long s; int k;  //n = trees, m = bones, s = 4*r^2, k = min bones
    std::cin>>n>>m>>s>>k;

    //Save the location of the trees
    std::vector<std::pair<P, int>> trees(n);
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      trees[i] = {P(x, y), i};
    }

    Delaunay tri;
    tri.insert(trees.begin(), trees.end());

    //Create a vector containing all the edges that are covered by a shadow
    //And a vector contain all the edges
    std::vector<edge_t> covered_edges;
    std::vector<edge_t> all_edges;

    for (auto e = tri.finite_edges_begin(); e != tri.finite_edges_end(); e++) {
      int i1 = e->first->vertex((e->second+1)%3)->info();
      int i2 = e->first->vertex((e->second+2)%3)->info();

      long sq_len = tri.segment(e).squared_length();

      //Covered if l/2 <= r, l^2 <= s
      if(sq_len <= s){
        covered_edges.push_back({i1, i2, sq_len});
      }
      all_edges.push_back({i1, i2, sq_len});
    }

    //TASK 1

    //Find how many bones are covered by each tree
    //If a bone is covered by multiple trees, it's not a problem to consider only the
    //closest tree because, if a bone is covered by two shadows, it's possible to move from one tree to the other

    std::vector<int> bones_per_tree(n, 0);
    std::vector<bone_t> bones(m);  //Each bone also contains the distance to its closest tree
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      auto nearest = tri.nearest_vertex(P(x, y));
      long sq_d = CGAL::squared_distance(P(x, y), nearest->point());

      //It may be possible that the bone is not covered by the shadow of the nearest tree
      if(sq_d <= s/4){
        bones_per_tree[nearest->info()]++;
      }
      bones[i] = {P(x, y), sq_d};
    }

    //Build the graph with edges convered by a shadow
    graph G(n);
    for(auto edge: covered_edges){
      boost::add_edge(edge.from, edge.to, G);
    }

    //Find the sub-forests that can be walked under a shadow (connected components)
    std::vector<int> cc_map(n);
    int ncc = boost::connected_components(G, boost::make_iterator_property_map(cc_map.begin(),
      boost::get(boost::vertex_index, G)));

    //Find how many bones are covered by each connected component
    std::vector<int> bones_per_cc(ncc, 0);
    for(int i = 0; i < n; i++){
      int tree_cc = cc_map[i];

      bones_per_cc[tree_cc] += bones_per_tree[i];
    }

    //Find the connected component with the maximum amount of trees
    int max_bones_covered = *std::max_element(bones_per_cc.begin(), bones_per_cc.end());

    //SECOND TASK
    std::sort(all_edges.begin(), all_edges.end(), compEdges());
    std::sort(bones.begin(), bones.end(), compBones());

    auto edge_it = all_edges.begin();
    auto bone_it = bones.begin();

    std::vector<int> new_bones_cc(n, 0);  //Store how many bones are covered in each cc at a time
    boost::disjoint_sets_with_storage<> new_cc(n);
    int max_bones = -1;
    long max_4sq_d = -1;
    bool found = false;

    while(!found){

      //Increase the radius to include more bones directly
      if(bone_it != bones.end()){
        int near_tree = tri.nearest_vertex(bone_it->point)->info();
        int cc_near_tree = new_cc.find_set(near_tree);

        //Increase the number of bones covered by the component where the nearest tree to the new bone is present
        new_bones_cc[cc_near_tree]++;

        max_4sq_d = std::max(max_4sq_d, 4*bone_it->sq_d);
        max_bones = std::max(max_bones, new_bones_cc[cc_near_tree]);

        if(max_bones >= k){
          found = true;
          break;
        }

        bone_it++;
      }

      //While there are more connections and
      //Either there are no more bones to be added directly or a new bone was added directly
      while(edge_it != all_edges.end() &&
        ((bone_it < bones.end() && edge_it->sq_len < 4*(bone_it->sq_d)) ||
        bone_it == bones.end())){

        int cc1 = new_cc.find_set(edge_it->from);
        int cc2 = new_cc.find_set(edge_it->to);

        if(cc1 != cc2){
          new_cc.link(cc1, cc2);

          //Update the number of bones covered by the components
          //It's not certain which will be the final component identifier, so update the value of both
          new_bones_cc[cc1] += new_bones_cc[cc2];
          new_bones_cc[cc2] = new_bones_cc[cc1];
        }

        max_4sq_d = std::max(max_4sq_d, edge_it->sq_len);
        max_bones = std::max(max_bones, new_bones_cc[cc1]);

        if(max_bones >= k){
          found = true;
          break;
        }

        edge_it++;
      }

      if(found){
        break;
      }
    }

    std::cout<<max_bones_covered<<"" ""<<max_4sq_d<<""\n"";
  }
}
"
"Placing Knights","given size with holes. How many knights can you place on the chessboard so that no two knights threaten each other? Input: The first line of the input contains the number of chessboards 1 ‚©Ωt ‚©Ω50. Each of the t chessboards is described as follows: ‚Ä¢ It starts with a line containing 1 ‚©Ωn ‚©Ω26, the length of each side of the chessboard in squares. ‚Ä¢ The next n lines each contain n integer values, separated by a space, denoting whether the corresponding chessboard field is present (1), or is a hole (0). Output: For every testcase you should output a single line with the maximum number of knights you can place on the chessboard so that no two threaten each other. (I.e. if a knight is placed on position [i, j] (ith row, jth column), there can be no knights at positions [i ‚àí1, j ‚àí2], [i ‚àí1, j + 2], [i + 1, j ‚àí2], [i + 1, j + 2], [i ‚àí2, j ‚àí1], [i ‚àí2, j + 1], [i + 2, j ‚àí1], [i + 2, j + 1]. It is disallowed to place knights on the holes or the outside of the chessboard.)","Placing Knights - solution Create a graph of size n*n that represents the board. It's an error to consider each field both as a possible starting position and a possible landing position. Some of them must be considered only as starting positions, and some of them only as landing positions. For this reason, if a field is not a hole, if (i+j)%2 == 1 the field is a landing position; otherwise, it is a starting position. This is true because, from an ""even"" starting position, the landing position will always be ""odd"". Connect the source to all...","Max Flow / Min Cut","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

class edge_adder {
  graph &G;

 public:
  explicit edge_adder(graph &G) : G(G) {}

  void add_edge(int from, int to, long capacity) {
    auto c_map = boost::get(boost::edge_capacity, G);
    auto r_map = boost::get(boost::edge_reverse, G);
    const auto e = boost::add_edge(from, to, G).first;
    const auto rev_e = boost::add_edge(to, from, G).first;
    c_map[e] = capacity;
    c_map[rev_e] = 0;
    r_map[e] = rev_e;
    r_map[rev_e] = e;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;  //n = side of the chessboard
    std::cin>>n;

    VVI table(n, VI(n));
    int tot_k = 0;
    for(int i = 0; i < n; i++){
      for(int j = 0; j < n; j++){
        int k;
        std::cin>>k;

        table[i][j] = k;

        if(k == 1){
          tot_k++;
        }
      }
    }

    graph G(n*n);
    edge_adder adder(G);

    //Connect all starting positions to source and all landing positions to sink
    const vertex_desc source = boost::add_vertex(G);
    const vertex_desc sink = boost::add_vertex(G);

    for(int i = 0; i < n; i++){
      for(int j = 0; j < n; j++){
        int k = table[i][j];
        int node = i*n + j;

        if(k == 1){  //If field is not a hole
          if((i+j)%2 == 0){
            adder.add_edge(source, node, 1);

            //Add an edge to all possible landing positions
            //If the landing field is not a hole

            //i-1, j-2
            if(i-1 >= 0 && j-2 >= 0 && table[i-1][j-2] == 1){
              int other = (i-1)*n + (j-2);
              adder.add_edge(node, other, 1);
            }

            //i-1, j+2
            if(i-1 >= 0 && j+2 < n && table[i-1][j+2] == 1){
              int other = (i-1)*n + (j+2);
              adder.add_edge(node, other, 1);
            }

            //i+1, j-2
            if(i+1 < n && j-2 >= 0 && table[i+1][j-2] == 1){
              int other = (i+1)*n + (j-2);
              adder.add_edge(node, other, 1);
            }

            //i+1, j+2
            if(i+1 < n && j+2 < n && table[i+1][j+2] == 1){
              int other = (i+1)*n + (j+2);
              adder.add_edge(node, other, 1);
            }

            //i-2, j-1
            if(i-2 >= 0 && j-1 >= 0 && table[i-2][j-1] == 1){
              int other = (i-2)*n + (j-1);
              adder.add_edge(node, other, 1);
            }

            //i-2, j+1
            if(i-2 >= 0 && j+1 < n && table[i-2][j+1] == 1){
              int other = (i-2)*n + (j+1);
              adder.add_edge(node, other, 1);
            }

            //i+2, j-1
            if(i+2 < n && j-1 >= 0 && table[i+2][j-1] == 1){
              int other = (i+2)*n + (j-1);
              adder.add_edge(node, other, 1);
            }

            //i+2, j+1
            if(i+2 < n && j+1 < n && table[i+2][j+1] == 1){
              int other = (i+2)*n + (j+1);
              adder.add_edge(node, other, 1);
            }
          }else{
            adder.add_edge(node, sink, 1);
          }
        }
      }
    }

    long flow = boost::push_relabel_max_flow(G, source, sink);
    //Maximum flow = Maximum Matching = Minimum Vertex Cover
    //Maximum Independent Set = Total Vertices - Minimum Vertex Cover
    std::cout<<tot_k-flow<<""\n"";
  }
}
"
"Real Estate Market","In Algoland the housing market is booming. Property prices are skyrocketing and ALGO (the All Land Governing Organization) decided to sell some of their sites to the highest bidder. They publicly announced all the M pieces of land that they want to sell and N potential buyers sub- mitted their bids. Every buyer is interested in buying at most one piece of land and submitted a bid for all of the M sites (but they might bid just one franc if they are really not interested in a piece and hope for a bargain). You now want to maximize ALGO‚Äôs profit and have to decide who gets which piece of land. But be aware of the state legislations! Depending on which state of Algoland the sites lie, you might not be allowed to sell all of them. To avoid hoarding by big real estate brokers, each of the S states in Algoland recently passed a new law that specifies a maximum number of sites that ALGO is allowed to sell in that state. Input: The first line of the input contains the number of test cases T. Each of the T test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers N M S, separated by a space and such that 1 ‚©ΩN ‚©Ω100, 1 ‚©ΩM ‚©Ω100 and 1 ‚©ΩS ‚©ΩM. N denotes the number of interested buyers, M the number of sites that ALGO owns and S the number of states in Algoland. ‚Ä¢ The second line contains S space separated integers. These numbers l1, . . . , lS denote the limits on the number of sites that can be sold in state i. We have 0 ‚©Ωli ‚©ΩN for all i. ‚Ä¢ The third line contains M space separated integers. These numbers s1, . . . , sM denote to which state each site belongs to. Site j belongs to state sj, so we have 1 ‚©Ωsj ‚©ΩS for all j. ‚Ä¢ The remaining N lines of each test case contain the bids, one potential buyer per line. The i-th of these lines contains the bids of the i-th potential buyer for all the sites represented as M numbers bi,1, . . . , bi,M. We have 1 ‚©Ωbi,j ‚©Ω100 for all i and j. Output: For each test case output a line with two integers c and p, the optimum number of sites sold and the maximum profit.","Real Estate Market - solution In a graph of size S+M+N: - Connect the source to each state. The edges should have a capacity equal to the number of properties that can be sold in that state (so there is a limit on how many properties can be sold in each state). The cost should be 0. - Connect each state to all the properties that are present in that state, with edges of capacity 1 and cost 0. - Connect each property to each buyer with capacity 1 (each buyer can buy a property only once) and a cost of 100 - bid. This is necessary because...","Max Flow / Min Cut","#include <iostream>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>
#include <boost/graph/find_flow_cost.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor,
                boost::property <boost::edge_weight_t, long>>>>> graph; // new! weightmap corresponds to costs

typedef traits::edge_descriptor edge_desc;
typedef traits::vertex_descriptor vertex_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}
    void add_edge(int from, int to, long capacity, long cost) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      auto w_map = boost::get(boost::edge_weight, G); // new!
      const edge_desc e = boost::add_edge(from, to, G).first;
      const edge_desc rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0; // reverse edge has no capacity!
      r_map[e] = rev_e;
      r_map[rev_e] = e;
      w_map[e] = cost;   // new assign cost
      w_map[rev_e] = -cost;   // new negative cost
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int T;
  std::cin>>T;
  while(T--){
    int N, M, S;  //N = buyers, M = properties, S = states
    std::cin>>N>>M>>S;

    graph G(S+M+N);
    edge_adder adder(G);

    const vertex_desc source = boost::add_vertex(G);
    const vertex_desc sink = boost::add_vertex(G);

    //States from 0 to S-1
    for(int i = 0; i < S; i++){
      int l;
      std::cin>>l;

      //Limit the amount of properties that can be bought in a state
      adder.add_edge(source, i, l, 0);
    }

    //Properties from S to S+M-1
    for(int i = S; i < S+M; i++){
      int s;
      std::cin>>s;

      //Each property is in a state
      adder.add_edge(s-1, i, 1, 0);
    }

    const int max_bid = 100;
    //Buyers from S+M to S+M+N-1
    for(int i = S+M; i < S+M+N; i++){
      //Each buyer buys one property
      adder.add_edge(i, sink, 1, 0);
      for(int j = S; j < S+M; j++){
        int b;
        std::cin>>b;

        //Shift up the bid
        adder.add_edge(j, i, 1, max_bid-b);
      }
    }

    int prop_sold = boost::push_relabel_max_flow(G, source, sink);
    boost::successive_shortest_path_nonnegative_weights(G, source, sink);
    int profit = prop_sold*max_bid - boost::find_flow_cost(G);

    std::cout<<prop_sold<<"" ""<<profit<<""\n"";
  }
}
"
"Clues","Holmes and Watson are out on the streets to keep an eye on various people and places, hoping to obtain clues regarding criminal activities. Each of them carries a radio set and they want to coordinate through it as soon as something interesting happens. As the area of interest is quite large, Holmes and Watson cannot maintain a direct connection throughout the investigation. Instead they setup a network of radio stations to route the communication. In the following we use the term clients to refer to radio sets and radio stations collectively. All clients have the same operation range r so that they can communicate with every client in distance at most r. For the actual communication there are four diÔ¨Äerent frequencies available. Any client can receive on all frequencies. But in order to avoid interferences, any two clients that are in range of each other must send on diÔ¨Äerent frequencies. Each of the two radio sets has one exclusive sending frequency assigned to it. This leaves two frequencies for the stations to work with. To keep the protocol simple, Holmes wants to assign one Ô¨Åxed frequency to each station so that the station sends on this frequency only. Is it possible to achieve such an assignment without generating any interferences? If so, which collections of clues can be routed within this network between Holmes and Watson? The radio sets are ‚Äúintelligent‚Äù in the... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers n m r, separated by a space and such that 1 ‚©Ωn, m ‚©Ω9 ¬∑ 104 and 0 < r < 224. Here n denotes the number of stations, m denotes the number of clues, and r denotes the operation range of the clients. ‚Ä¢ The following n lines deÔ¨Åne the positions s0, . . . , sn‚àí1 of the stations. You may assume that these positions are pairwise distinct. ‚Ä¢ The Ô¨Ånal m lines deÔ¨Åne the m clues. Each clue is deÔ¨Åned by two positions ai and bi, for i ‚àà{0, . . . , m‚àí1}, where ai describes the position of Holmes and bi describes the position of Watson at the moment when this clue is obtained. Each position is described by two integer coordinates x y, separated by a space and such that |x|, |y| < 224. Output: For each test case output a line with one character ‚Äúy‚Äù or ‚Äún‚Äù per clue, that is, a string c0c1 ¬∑ ¬∑ ¬∑ cm‚àí1 of m characters. For each i ‚àà{0, . . . , m ‚àí1}, the character ci is ‚Äúy‚Äù, if and only if clue i can be routed within this network, as deÔ¨Åned in the next paragraph. Denote the set of stations by S = {s0, . . . , sn‚àí1}. A network without interferences on S corresponds to a map f : S ‚Üí{0, 1} such that f(u) Ã∏= f(v), for all u, v with ||u ‚àív|| ‚©Ωr. A clue 1 can be routed from ai to bi, if there exists a network without interferences on S and there exist k ‚ààN and a sequence t0, . . . , tk, such that 1. t0 = ai, tk = bi, and tj ‚ààS, for j ‚àà{1, . . . , k ‚àí1}; 2. ||tj ‚àítj‚àí1|| ‚©Ωr, for all j ‚àà{1, . . . , k}; 3. If t1 Ã∏= bi (and, thus, tk‚àí1 Ã∏= ai), then t1 is the (unique) client from S that is closest to ai and tk‚àí1 is the (unique) client from S that is closest to bi.","Clues - solution Create the triangulation of the stations with vertices that also contain their index information. Using the edge iterator described in _emst.cpp_, save only the edges whose length is less than $r$ (to make the process less heavy, use the squared length and $r^2$). Using BFS, color the nodes with alternating colors if possible. Maintain an array with a cell for each node that contains $0$ if the node was never visited, $1$, or $2$ to express which frequency was assigned to that node. For each node, check if it already has a...","BFS","#include <iostream>
#include <vector>
#include <queue>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_vertex_base_with_info_2.h>
#include <CGAL/Triangulation_face_base_2.h>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/connected_components.hpp>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;

typedef CGAL::Triangulation_vertex_base_with_info_2<int, K> Vb;
typedef CGAL::Triangulation_face_base_2<K> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<K, Tds> Triangulation;

typedef K::Point_2 P;

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> graph;
typedef boost::graph_traits<graph>::out_edge_iterator out_edge_it;

typedef struct{
  int from;
  int to;
} edge_t;  //Edge in the triangulation

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    long n, m, r;  //n = stations, m = clues, r = range
    std::cin>>n>>m>>r;

    std::vector<std::pair<P, int>> stations(n);  //Store stations with an index
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      stations[i] = {P(x, y), i};
    }

    Triangulation tri;
    tri.insert(stations.begin(), stations.end());

    //Find all stations that can communicate
    std::vector<edge_t> near_stations;
    for (auto e = tri.finite_edges_begin(); e != tri.finite_edges_end(); ++e){
      int i1 = e->first->vertex((e->second+1)%3)->info();
      int i2 = e->first->vertex((e->second+2)%3)->info();

      //l <= r, l^2 <= r^2
      long sq_l = tri.segment(e).squared_length();
      if(sq_l <= r*r){
        near_stations.push_back({i1, i2}); //Connect only stations that can communicate
      }
    }

    graph G(n);
    for(auto e: near_stations){
      boost::add_edge(e.from, e.to, G);
    }

    //Use BFS to know if the network is valid
    //0 = not traversed
    //1 = frequency 1
    //2 = frequency 2
    std::vector<int> frequency(n, 0);
    bool interference = false;

    for(int i = 0; i < n; i++){

      //If the node was not already traversed
      if(frequency[i] != 0){
        continue;
      }

      //If an interference was not already found
      if(interference){
        break;
      }

      std::queue<int> q;

      frequency[i] = 1;
      q.push(i);

      while(!q.empty()){
        int current = q.front(); q.pop();

        out_edge_it oe_beg, oe_end;
        for (boost::tie(oe_beg, oe_end) = boost::out_edges(current, G); oe_beg != oe_end; oe_beg++){
          int other = boost::target(*oe_beg, G);

          if(frequency[other] == 0){
            //If other node was never traversed
            //Assign the other frequency
            frequency[other] = (frequency[current] == 1) ? 2 : 1;
            q.push(other);

          }else if(frequency[other] == frequency[current]){
            interference = true;

            //Empty the queue
            while(!q.empty()){
              q.pop();
            }

            break;
          }
        }
      }
    }

    if(!interference){
      //Store all the points with one frequency or the other
      std::vector<P> freq1;
      std::vector<P> freq2;

      for(int i = 0; i < n; i++){
        if(frequency[i] == 1){
          freq1.push_back(stations[i].first);
        }else{
          freq2.push_back(stations[i].first);
        }
      }

      //Although in the original triangulation there may be no interference
      //There may be the nodes n1--n2--n3, such that the coloring prevents interference
      //Between n1 and n2, and between n2 and n3

      //However, if the distance between n1 and n3 is less than r, they may interfere even
      //if in the coloring is acceptable in the original triangulation

      //Create triangulations of nodes colored in the same way and see if there is interference
      //when passing over other nodes

      Triangulation tri1;
      tri1.insert(freq1.begin(), freq1.end());

      for (auto e = tri1.finite_edges_begin(); e != tri1.finite_edges_end(); e++){

        //l <= r, l^2 <= r^2
        long sq_l = tri1.segment(e).squared_length();
        if(sq_l <= r*r){
          interference = true;
        }
      }

      Triangulation tri2;
      tri2.insert(freq2.begin(), freq2.end());

      for (auto e = tri2.finite_edges_begin(); e != tri2.finite_edges_end(); e++){

        //l <= r, l^2 <= r^2
        long sq_l = tri2.segment(e).squared_length();
        if(sq_l <= r*r){
          interference = true;
        }
      }
    }

    std::vector<int> component_map(n);
    boost::connected_components(G,
      boost::make_iterator_property_map(component_map.begin(),
        boost::get(boost::vertex_index, G)));

    for(int i = 0; i < m; i++){
      int x1, y1, x2, y2;
      std::cin>>x1>>y1>>x2>>y2;

      P a = P(x1, y1);
      P b = P(x2, y2);

      if(interference){
        std::cout<<""n"";
        continue;
      }

      long sq_d_direct = CGAL::squared_distance(a, b);

      if(sq_d_direct <= r*r){  //Try to see if a direct communication can exist
        std::cout<<""y"";
        continue;
      }

      auto v_a = tri.nearest_vertex(a);
      long sq_d_a = CGAL::squared_distance(a, v_a->point());

      auto v_b = tri.nearest_vertex(b);
      long sq_d_b = CGAL::squared_distance(b, v_b->point());

      //Too far from the network
      if(sq_d_a > r*r || sq_d_b > r*r){
        std::cout<<""n"";
        continue;
      }

      //If they are in the same valid connected component
      if(component_map[v_a -> info()] == component_map[v_b -> info()]){
        std::cout<<""y"";
      }else{
        std::cout<<""n"";
      }
    }

    std::cout<<""\n"";
  }
}
"
"Lannister","given his youngest son Tyrion charge of all the cisterns and drains at Casterly Rock, in an eÔ¨Äort to make him a more responsible family member. After a close inspection of the existing antiquated facilities, Tyrion decides to rebuild the system from scratch. We imagine the following situation in the standard x-y-plane, with horizontal x-axis pointing right (east), and vertical y-axis pointing up (north). That is, we ignore the issue of depth, meaning that all canals and pipes (as deÔ¨Åned below) are allowed to cross and even overlap. There is a number of houses at Casterly Rock that all need access to fresh water and a possibility to dispose of their sewage. Tyrion‚Äôs grand plan is to build two massive underground canals, one for fresh water and the other for the sewage. Each canal is to be made in the form of a straight line so as to maximize the Ô¨Çow capacity and minimize the risk of congestion. To simplify construction, the two canals are to meet and cross at a right angle (90 degrees). Once they are in place, every house is to be connected via two separate pipes, where each pipe starts at the corresponding house and ends at either one of the two canals. To minimize the chance of confusing pipes of diÔ¨Äerent types during installation, each fresh water pipe is to be built as a vertical straight line segment, and each sewage pipe as a horizontal one. Note that this further... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing three integers n m s, separated by a space. They denote 1 ‚Äì n, the number of noble houses (0 ‚©Ωn ‚©Ω500); ‚Äì m, the number of common houses (0 ‚©Ωm ‚©Ω500); ‚Äì s, the maximum allowable sum of lengths of all sewage pipes (‚àí1 ‚©Ωs < 250, where the special value ‚àí1 is to be interpreted as s = ‚àû). ‚Ä¢ The following n lines deÔ¨Åne the positions of the noble houses. ‚Ä¢ The following m lines deÔ¨Åne the positions of the common houses. Each position is described by two integers x y, separated by a space and such that |x|, |y| < 224. You may assume that these n + m ‚©æ3 positions are distinct and not all on a common line. Output: The output for each test case consists of a separate line. If a sewer canal cannot be built according to Cersei‚Äôs constraint, the output is ‚ÄúYuck!‚Äù. Otherwise, if Cersei‚Äôs constraint can be satisÔ¨Åed but not Tywin‚Äôs at the same time, the output is ‚ÄúBankrupt!‚Äù. Otherwise, if both Cersei‚Äôs and Tywin‚Äôs constraint can be satisÔ¨Åed, the output consists of the minimum attainable largest length over all fresh water pipes, rounded up to the next integer. You may assume that the rounded output number can be represented exactly as double.","Lannister - solution It's necessary to build a water canal that is non-vertical and a sewage canal that is non-horizontal, making sure that the two are perpendicular to each other. Water pipes that connect to the water canal are always vertical, and sewage pipes that connect to the sewage canal are always horizontal. This is a linear programming problem where it's necessary that the inequalities depend on the equation of the two lines that describe the canals. The water canal is described with the equation $a_w \cdot x + b_w \cdot y + c_w =...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>

typedef long IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;

typedef K::Point_2 P;

long ceil_to_long(const CGAL::Quotient<CGAL::Gmpz> & x){
  double a = std::ceil(CGAL::to_double(x));
  while (a < x) a += 1;
  while (a-1 >= x) a -= 1;
  return a;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; long s;  //n = nobles, m = commons, s = max sum of sewage pipes
    std::cin>>n>>m>>s;

    //Water canal -> Non-vertical: a_w * x + b_w * y + c_w = 0 (b_w != 0. Possible to just set b_w to a value different than 0)
    //Sewage canal -> Non-horizontal: a_s * x + b_s * y + c_s = 0 (a_s != 0. Possible to just set a_s to a value different than 0)
    //Water canal is perpendicular to the sewage canal
    //Water pipes -> Only vertical
    //Sewage pipes -> Only horizontal

    std::vector<P> nobles(n);
    long sum_nobles_x = 0;
    long sum_nobles_y = 0;
    for(int i = 0; i < n; i++){
      int x, y;
      std::cin>>x>>y;

      nobles[i] = P(x, y);
      sum_nobles_x += x;
      sum_nobles_y += y;
    }

    std::vector<P> commons(m);
    long sum_commons_x = 0;
    long sum_commons_y = 0;
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      commons[i] = P(x, y);
      sum_commons_x += x;
      sum_commons_y += y;
    }

    Program lp (CGAL::SMALLER, false, 0, false, 0);

    //Sewage canal: ax+by+c=0. Considering a != 0, then a = 1
    //Constants to LP variables
    const int b_s = 0;
    const int c_s = 1;

    int counter = 0;

    //DIVISION COMMONS AND NOBLES
    //Cersei -> Nobles on the left of sewage canal, commons on its right -> If not, ""Yuck!""

    //P(x, y) on the right if by+c <= -x. On the left if x+by+c >= 0 (-> -by-c <= x)
    for(int i = 0; i < n; i++){
      P h = nobles[i];

      lp.set_a(b_s, counter, h.y());
      lp.set_a(c_s, counter, 1);
      lp.set_b(counter, -h.x());

      counter++;
    }

    for(int i = 0; i < m; i++){
      P h = commons[i];

      lp.set_a(b_s, counter, -h.y());
      lp.set_a(c_s, counter, -1);
      lp.set_b(counter, h.x());

      counter++;
    }

    Solution sol = CGAL::solve_linear_program(lp, ET());

    if(sol.is_infeasible()){
      std::cout<<""Yuck!\n"";
      continue;
    }

    //SUM OF SEWAGE PIPES LESS THAN s
    //Tywin -> Sum of lengths of sewage pipes <= s -> If not, ""Bankrupt!""

    if(s != -1){
      //All sewage pipes are horizontal, meaning that their length is:
      //For nobles on the left: - b_s * y_house - c - x_house [with a_s = 1]
      //For commons on the right: x_house + b_s * y_house + c [with a_s = 1]
      //Meaning that all the nobles pipes are: - b * sum(y_house) - n*c - sum(x_house)
      //And that all the commons pipes are: b * sum(y_house) + m*c + sum(x_house)

      lp.set_a(b_s, counter, sum_commons_y - sum_nobles_y);
      lp.set_a(c_s, counter, m-n);
      lp.set_b(counter, s + sum_nobles_x - sum_commons_x);
      counter++;

      Solution sol = CGAL::solve_linear_program(lp, ET());

      if(sol.is_infeasible()){
        std::cout<<""Bankrupt!\n"";
        continue;
      }
    }

    //MINIMIZE LENGTH WATER PIPES
    //Water canal: ax+by+c=0. Considering b != 0, then b = 1
    //Constants to LP variables
    const int a_w = 2;
    const int c_w = 3;

    //Canals are perpendicular. b_s = -a_w -> b_s + a_w <= 0 && -b_s - a_w <= 0
    lp.set_a(b_s, counter, 1);
    lp.set_a(a_w, counter, 1);
    counter++;

    lp.set_a(b_s, counter, -1);
    lp.set_a(a_w, counter, -1);
    counter++;

    //Create a variable that limits the length of the water pipes in order to minimize it
    const int L = 4;
    lp.set_l(L, true, 0);

    //Vertical connection, so the the connection point is y = -a_w * x_house - c_w.
    //The distance is L = |y_house - y| = |y_house + a_w * x_house + c|
    //It's possible to use L >= y_house - y and L >= -y_house + y,
    //because one will be the correct one, and one will be negative (ignored)

    //Nobles
    for(int i = 0; i < n; i++){
      P h = nobles[i];

      //L >= y_house + a_w * x_house + c <-> a_w * x_house + c_w - L<= - y_house
      lp.set_a(a_w, counter, h.x());
      lp.set_a(c_w, counter, 1);
      lp.set_a(L, counter, -1);
      lp.set_b(counter, -h.y());
      counter++;

      //L >= -y_house - a_w * x_house - c_w <-> - a_w * x_house - c_w - L <= y_house
      lp.set_a(a_w, counter, -h.x());
      lp.set_a(c_w, counter, -1);
      lp.set_a(L, counter, -1);
      lp.set_b(counter, h.y());
      counter++;
    }

    //Commons
    for(int i = 0; i < m; i++){
      P h = commons[i];

      //L >= y_house + a_w * x_house + c <-> a_w * x_house + c_w - L<= - y_house
      lp.set_a(a_w, counter, h.x());
      lp.set_a(c_w, counter, 1);
      lp.set_a(L, counter, -1);
      lp.set_b(counter, -h.y());
      counter++;

      //L >= -y_house - a_w * x_house - c_w <-> - a_w * x_house - c_w - L <= y_house
      lp.set_a(a_w, counter, -h.x());
      lp.set_a(c_w, counter, -1);
      lp.set_a(L, counter, -1);
      lp.set_b(counter, h.y());
      counter++;
    }

    //Minimize the limiting length
    lp.set_c(L, 1);

    sol = CGAL::solve_linear_program(lp, ET());
    std::cout<<ceil_to_long(sol.objective_value())<<""\n"";
  }
}
"
"Rubeus Hagrid","‚ÄúAh, well, people can be stupid abou‚Äô their pets‚Äù, said Hagrid wisely. Buckbeak spat a few ferret bones onto Hagrid‚Äôs pillow. Harry Potter and the Prisoner of Azkaban by J. K. Rowling After several mishaps during his Care of Magical Creatures lectures, some of them ending in students getting seriously injured, Hagrid Ô¨Ånally opted for presenting tamer creatures next: niÔ¨Ñers. NiÔ¨Ñers are cute looking Ô¨ÇuÔ¨Äy creatures with a long snout similar to that of a platypus. They are attracted to shiny objects and thus primarily used by goblins to burrow for treasure. For the purpose of a lecture, Hagrid has buried a bunch of galleons made out of leprechaun gold into previously dug chambers below the ground. He has built a network of two-way tunnels of various lengths and has left a single entry point to this network on the surface. Each tunnel connects either two distinct chambers or the entry point and some chamber. The chambers and tunnels have been purposefully arranged so that from every chamber there is a unique sequence of tunnels leading up to the surface. Hagrid plans to introduce the niÔ¨Ñers to the class and then organize a competition. Each student is to choose a niÔ¨Ñer and release it into the underground network through the entry point on the surface with the goal to dig out as many galleons as possible. The student whose niÔ¨Ñer digs out the most galleons wins a huge slab of... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that consists of a single integer n denoting the number of chambers Hagrid has dug below the ground (2 ‚©Ωn ‚©Ω5 ¬∑ 104). 1 ‚Ä¢ The following line consists of n integers g1 g2 . . . gn, separated by a space, denoting the number of galleons buried in the i-th chamber (1 ‚©Ωgi < 231). ‚Ä¢ The following n lines deÔ¨Åne the tunnels. The i-th such line consists of three integers u v l, separated by a space, denoting the two chambers it connects (0 ‚©Ωu < v ‚©Ωn) and the length of the tunnel in meters (1 ‚©Ω‚Ñì‚©Ω28). You may assume that u is strictly closer to the surface than v, in terms of the number of tunnels needed to reach the entry point. If u = 0, the tunnel connects the entry point on the surface (labeled 0) to the chamber v. Output: For each test case output a single line with the maximum number of galleons a single niÔ¨Ñer can dig out once released into the underground network.","Rubeus Hagrid - solution Create a custom struct that contains the best number of galleons acquired starting from a chamber, the amount of time it took to do the whole outgoing trip starting from that chamber, and the number of chambers encountered (considering also the current chamber). Recursively: - Base case: if a chamber has no outgoing tunnels, return the number of galleons in the current cave, 0 as the time needed to traverse all outgoing tunnels (there aren't any), and 1 as the number of chambers traversed (this one). - Otherwise, for...","Tree DP + Greedy ordering","#include <iostream>
#include <vector>
#include <algorithm>

typedef struct{
  int to;
  int l;
} edge_t;

typedef struct{
  long galleons;  //Number of galleons collected
  int chambers;  //Chambers traversed starting from the current chamber (current chamber included)
  long return_time;  //Time needed to traverse all nodes starting from the current node
} path_t;

struct compPaths{
  //It's better to take p1 first and remove galleons from p2 according to the time needed to traverse p1
  //Or it's better to take p2 first
  bool operator()(path_t &p1, path_t &p2){
    return p2.chambers * p1.return_time < p1.chambers * p2.return_time;
  }
};

path_t solve(int current, std::vector<std::vector<edge_t>> &graph, std::vector<int> &galleons){
  if(graph[current].size() == 0){  //No outgoing edges
    return {galleons[current], 1, 0};
  }

  std::vector<path_t> paths;
  for(auto out: graph[current]){
    path_t possible_path = solve(out.to, graph, galleons);

    //Add to the path the time needed to enter that path
    //Remove the disappeared coins from travelling through the entering tunnel to the path
    paths.push_back(
      {possible_path.galleons - out.l * possible_path.chambers,
      possible_path.chambers,
      possible_path.return_time + out.l*2});
  }

  std::sort(paths.begin(), paths.end(), compPaths());

  long tot_galleons = galleons[current];
  int tot_chambers = 0;
  long tot_return_time = 0;

  for(auto p: paths){
    //Remove the galleons lost while travelling the other paths that start from the current node
    tot_galleons += (p.galleons - p.chambers * tot_return_time);

    tot_return_time += p.return_time;
    tot_chambers += p.chambers;
  }

  return {tot_galleons, tot_chambers+1, tot_return_time};
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;
    std::cin>>n;

    std::vector<int> galleons(n+1);
    for(int i = 0; i < n; i++){
      int g;
      std::cin>>g;

      galleons[i] = g;
    }

    std::vector<std::vector<edge_t>> graph(n+1);
    for(int i = 0; i < n; i++){
      int u, v, l;  //From u to v, with length l
      std::cin>>u>>v>>l;

      graph[u].push_back({v, l});
    }

    std::cout<<solve(0, graph, galleons).galleons<<""\n"";
  }
}
"
"San Francisco","Given only a limited number of moves, the goal of the game is to maximise the score, of course. The chief explains the rules of the game to Phileas. There is a unique starting hole, called Angvariationu-toke (a Sioux word for ‚Äòanother day‚Äô). The marble, called Canowicakte (a Sioux word for ‚Äòforest hunter‚Äô), starts at Angvariationu-toke. In each move, the player rolls the marble from the current hole to a neighboring hole through one of the incident canals, while respecting the direction of the engraved arrow. Doing so, (s)he scores as many points as the canal carries. A hole with no outgoing canal is called Weayaya (a Sioux word for ‚Äòsetting sun‚Äô) and from such a hole the player may take the marble back to Angvariationu-toke as a free action. Such a free action does not count as a move and it yields no score. The chief makes the bold claim that he can achieve a score of x in k moves. Phileas‚Äô goal is to beat the chief dramatically: either Ô¨Ånd the minimum number of moves in order to score at least as much as the chief, or prove that it is impossible to achieve the score of x in k moves. It may be noted that the same canal can be scored more than once. Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  The Ô¨Årst line contains four integers n m x k, separated by a space. They denote ‚Äì n, the number of holes in the game board (2 ‚©Ωn ‚©Ω103); ‚Äì m, the number of canals between the holes (1 ‚©Ωm ‚©Ω4 ¬∑ 103); ‚Äì x, the claimed score of the chief (1 ‚©Ωx ‚©Ω1014); 1 ‚Äì k, the maximum number of moves allowed (1 ‚©Ωk ‚©Ω4 ¬∑ 103). Hole 0 always corresponds to Angvariationu-toke.  The following m lines deÔ¨Åne the canals. Each line consists of three integers u v p, sepa- rated by a space, and such that 0 ‚©Ωu, v ‚©Ωn ‚àí1 and 0 ‚©Ωp < 231. This means that the arrow engraved in the canal points from u to v. The player can roll the marble from hole u to hole v, thereby scoring p points. Note that (1) there can be more than one canal from hole u to hole v and (2) possibly u = v. Output: For each test case output one line containing a single integer that denotes the minimum number of moves to get at least x points. If it is not possible to score at least x points in k moves, output ‚ÄòImpossible‚Äô.","San Francisco - solution It's not necessary to create a full BGL graph, but a vector of vectors of integers is enough. After reading the input (pay attention to the fact that the claimed score is too large for an integer), search for the node with no outgoing edges, which is the return hole. Create a DP table of size $n \times (k+1)$. For each node $i$, it will store the maximum amount of points that can be done starting from that node and doing $j$ moves. The table is initialized by setting $0$ when $j = 0$, meaning that, from any node...","Dynamic Programming","#include <iostream>
#include <vector>
#include <algorithm>

typedef struct{  //The source node is the index in a vector
  int to;
  long p;
} edge_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    long n, m, x, k; //n = holes, m = canals, x = claimed score, k = max moves
    std::cin>>n>>m>>x>>k;

    std::vector<std::vector<edge_t>> graph(n);
    for(int i = 0; i < m; i++){
      int u, v, p;
      std::cin>>u>>v>>p;

      graph[u].push_back({v, p});
    }

    //Find which one is the end hole and connect it to the start with 0 points
    int end_v = -1;
    for(int i = 0; i < n; i++){
      if(graph[i].size() == 0){
        end_v = i;
        graph[i].push_back({0, 0});
        break;
      }
    }

    //dp[i][j] best amount of points starting from node i with j moves remaining
    std::vector<std::vector<long>> dp(n, std::vector<long>(k+1, -1));

    //Cannot do any points if there are no more moves possible
    for(int i = 0; i < n; i++){
      dp[i][0] = 0;
    }

    for(int j = 1; j <= k; j++){
      for(int i = 0; i < n; i++){

        //If it's the last hole, take the same point
        //as can be done from the beginning with the same number of remaining moves
        if(i == end_v){
          dp[i][j] = dp[0][j];
        }

        //Try to see which one is the best route to take from the current position
        for(edge_t e: graph[i]){
          dp[i][j] = std::max(dp[i][j], dp[e.to][j-1] + e.p);
        }
      }
    }

    //Check if, starting from the hole 0, it's possible to achieve enough points.
    //If so, find how many moves are necessary
    bool found = false;
    for(int i = 0; i <= k; i++){
      if(dp[0][i] >= x){
        std::cout<<i<<""\n"";
        found = true;
        break;
      }
    }

    if(!found){
      std::cout<<""Impossible\n"";
    }
  }
}
"
"Surveillance Photograph","Given the map of the relevant part of London and the locations of police stations and pho- tographs, help Dr. Watson to Ô¨Ågure out how many photographs can be collected while preserving the security precautions. Hopefully it will be enough to convince the jury. . . Input: The Ô¨Årst line of the input contains the number t ‚©Ω60 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains four integers n m k l, separated by a space and such that 1 ‚©Ωn ‚©Ω500, 0 ‚©Ωm ‚©Ω104, and 1 ‚©Ωk, ‚Ñì‚©Ω500. Here n denotes the number of intersections, m the number of streets, k the number of police stations and ‚Ñìthe number of photographs. ‚Ä¢ The following line deÔ¨Ånes the locations of the police stations. Each of the k locations is described by an integer x ‚àà{0, . . . , n ‚àí1}, denoting the intersection at which the station is situated. ‚Ä¢ In the same way, the following line deÔ¨Ånes the ‚Ñìlocations of the photographs. ‚Ä¢ Each of the following m lines contains two integers x y, separated by a space and such that x, y ‚àà{0, . . . , n‚àí1} and x Ã∏= y. It indicates that there is a (one-way) street that leads from intersection x to intersection y. Note that there may be multiple police stations and photographs at a single intersection. Fur- thermore... Output: For each test case output the maximum number of photographs that can be collected subject to the constraints in the description. 1","Surveillance Photograph - solution Divide each vertex into two vertices in a BGL graph for max flow. Then, connect the source to the even vertices of the police stations and the odd vertices of the police stations to the sink (capacity is 1); connect each even vertex of an intersection where there is a photograph to its paired odd vertex (capacity is 1). This also handles cases where there are photographs and police stations at the same intersection. For each road, connect the even vertices of each intersection with infinite capacity. This...","Max Flow / Min Cut","#include <iostream>
#include <climits>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, k, l;  //n = intersections, m = streets, k = p stations, l = photos
    std::cin>>n>>m>>k>>l;

    graph G(2*n);
    edge_adder adder(G);

    const vertex_desc source = boost::add_vertex(G);
    const vertex_desc sink = boost::add_vertex(G);

    //Divide each vertex into two

    //Connect one part of each station to the source and one to the sink
    //From the source a policeman can go out, and return with a photo to the sink
    for(int i = 0; i < k; i++){
      int x;
      std::cin>>x;

      adder.add_edge(source, 2*x, 1);
      adder.add_edge(2*x+1, sink, 1);
    }

    //Use each photo intersection once for each photo
    //This considers also the special case when there are photos in the same intersection
    //As a police station (immediately taken if possible)
    for(int i = 0; i < l; i++){
      int x;
      std::cin>>x;

      adder.add_edge(2*x, 2*x+1, 1);
    }

    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      //Either go through the even path that consider the roads all clear
      //Or go through the odd path  where photos are collected and roads can be used only once
      adder.add_edge(2*x, 2*y, INT_MAX);
      adder.add_edge(2*x+1, 2*y+1, 1);
    }

    long flow = boost::push_relabel_max_flow(G, source, sink);
    std::cout << flow << ""\n"";
  }
}
"
"Asterix and the Chariot Race","given city costs. Due to the limitations on his budget, he cannot aÔ¨Äord to repair the roads in all the cities. Rather, he needs to decide on a subset of cities such that repairing the roads in these cities saves every city from disgrace. In addition, the total reparation costs (sum of the costs for the chosen cities) are to be minimized. Otherwise, exile into Cyrenaica2 awaits... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows.  It starts with a line that consists of an integer n denoting the number of cities through which the race takes place (1 ‚©Ωn ‚©Ω105).  The following n ‚àí1 lines deÔ¨Åne the stages of the race. Each line consists of two integers i j, separated by a space, denoting a stage of the race that starts at city i and ends at city j (where i, j ‚àà{0, . . . , n ‚àí1}).  The following line deÔ¨Ånes the costs of repairing the roads in the cities. It consists of n integers c0 . . . cn‚àí1, separated by a space (0 ‚©Ωci ‚©Ω214, for all i ‚àà{0, . . . , n ‚àí1}). Here ci denotes the cost of repairing all the roads in city i, for i ‚àà{0, . . . , n ‚àí1}. 1nowadays known as Monza 2nowadays eastern coastal region of Lybia 1 Output: For each test case output a single line that consists of a single integer denoting the minimum total reparation costs so that every city is saved from disgrace.","Asterix and the Chariot Race - solution Each city may be in three different states (each associated with a cost): fixed directly; fixed indirectly, meaning that a neighboring city is fixed and the current one is not; or maybe not fixed, meaning that the city is not fixed directly and there is no guarantee that the current city is fixed by a neighboring city. Recursively, given a city: - If there are no outgoing paths, the cost to fix the city directly is the one given by the problem; the cost to fix the city indirectly is equal to the cost to...","Tree DP (3-state)","#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

typedef struct{
  long direct_repair;   //Cost to have the city fixed directly
  long indirect_repair;  //Cost to have the city broken, but fixed by a neighbor
  long maybe_repair;  //Cost if the city *may* be broken, and it is not certain a neighbor fixed it
} city_t;

city_t solve(int current, VVI &graph, VI &costs){
  if(graph[current].size() == 0){  //There are no outgoing cities

    //It's necessary to have costs[i] as the cost of indirect fix, otherwise
    //the city would be considered indirectly fixed for free
    return {costs[current], costs[current], 0};
  }

  long current_direct_rep = costs[current];
  long tot_out_repaired = 0;
  long add_price = INT_MAX;

  for(auto out: graph[current]){  //For each outgoing city
    city_t rep_out = solve(out, graph, costs);

    //Check which is the least expensive way to have the outgoing city already fixed
    long out_repaired = std::min(rep_out.direct_repair, rep_out.indirect_repair);
    tot_out_repaired += out_repaired;

    //Consider the best option between having this node fix the outgoing node and the outgoing node being fixed by someone else
    current_direct_rep += std::min(out_repaired, rep_out.maybe_repair);

    //Check how much would it cost more to be sure that the current node is fixed by an outgoing city
    add_price = std::min(add_price, rep_out.direct_repair - out_repaired);
  }

  //current_direct_rep = fix the current node. Outgoing nodes may be already fixed or not
  //tot_out_repaired + add_price = all the outgoings are fixed, and the additional cost grants that the current is indirectly fixed
  //tot_out_repaired = all the outgoings are fixed, but maybe indirectly. This means that the current one may be broken
  return {current_direct_rep, tot_out_repaired + add_price, tot_out_repaired};
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n; //n = cities;
    std::cin>>n;

    VVI graph(n);
    for(int i = 0; i < n-1; i++){
      int x, y;
      std::cin>>x>>y;

      graph[x].push_back(y);
    }

    VI costs(n);
    for(int i = 0; i < n; i++){
      int c;
      std::cin>>c;

      costs[i] = c;
    }

    city_t repair = solve(0, graph, costs);
    std::cout<<std::min(repair.direct_repair, repair.indirect_repair)<<""\n"";
  }
}
"
"Dean Thomas","given Dementor was last observed. The fugitives operate under the assumption that the Dementor stays within distance at most d from ‚Ñìduring daytime, and that this maximum roaming distance increases to 2d at night. Even with their Patronuses, the fugitives need to stay away from the Dementors in order to avoid their despairing effect. Let pi denote any fugitive. During daytime, with their Patronus around, person pi is safe when they are at distance at least si from any potential Dementor location. At night, without the Patronus, the minimum safe distance increases to 2si. Which of the fugitives can find a safe spot to spend the night? A safe spot for a person can be their initial location or another point that they can move to from their initial location with their Patronus during daytime. However, while moving and throughout the night, the person must always stay at a safe distance from any potential Dementor location. Any number of people can use the same safe spot. Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ The first line contains three integers n m d, separated by a space. They denote 1witches and wizards whose parents do not possess magical power 1 ‚Äì n, the number of Dementors (1 ‚©Ωn ‚©Ω4 ¬∑ 104); ‚Äì m, the number of fugitives (1 ‚©Ωm ‚©Ω9 ¬∑ 104); and ‚Äì d, the largest distance of a Dementor from its last observed position during daytime (1 ‚©Ωd < 250). ‚Ä¢ The following n lines define the last observed positions of the Dementors. Each position is described by two integer coordinates x y, separated by a space and such that |x|, |y| < 250. You may assume that these positions are pairwise distinct. ‚Ä¢ The next m lines describe the relevant information about the fugitives. The i-th line contains three integers x y s, separated by a space and such that 1 ‚©Ωs and |x|, |y|, s < 250. Here x and y define the initial position of person pi, and s defines the safe distance si that person pi... Output: For each test case, output one line with a single character ‚Äúy‚Äù or ‚Äún‚Äù for each fugitive, that is, a string c0c1 ¬∑ ¬∑ ¬∑ cm‚àí1 of m characters. For each i ‚àà{0, . . . , m ‚àí1}, the character ci is ‚Äúy‚Äù if and only if there exists a safe spot to spend the night for person pi, as explained above.","Dean Thomas - solution Create a triangulation with the dementors' positions. Each face of the triangulation should contain a pair of pieces of information, where the first value is a boolean that is used to know if the current face was already considered, and the second value contains the safe distance squared. It's also necessary to create a priority queue that contains pairs, where the first value of the pair is the safe distance squared of a face, and the second value is the face itself. For each finite face of the triangulation, calculate...","Max Flow / Min Cut","#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>

#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>
#include <CGAL/Triangulation_face_base_with_info_2.h>

typedef CGAL::Exact_predicates_exact_constructions_kernel EPEC;  //Use exact for very big numbers

typedef std::pair<bool, EPEC::FT> Info;
typedef CGAL::Triangulation_vertex_base_2<EPEC> Vb;
typedef CGAL::Triangulation_face_base_with_info_2<Info, EPEC> Fb;
typedef CGAL::Triangulation_data_structure_2<Vb, Fb> Tds;
typedef CGAL::Delaunay_triangulation_2<EPEC, Tds> Triangulation;

typedef EPEC::Point_2 P;
typedef EPEC::FT FT;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    long n, m, d;  //n = dementors, m = fugitives, d = moving distance dementors daytime
    std::cin>>n>>m>>d;

    std::vector<P> dementors(n);
    for(int i = 0; i < n; i++){
      long x, y;
      std::cin>>x>>y;

      dementors[i] = P(x, y);
    }

    Triangulation tri;
    tri.insert(dementors.begin(), dementors.end());

    //It's necessary to have the faces ordered by their safe distance in order to consider the worst case scenario
    //Store a pair with the first element the value that needs to be ordered to have automatic ordering in the priority queue
    std::priority_queue<std::pair<FT, Triangulation::Face_handle>> q;
    for (auto f_it = tri.finite_faces_begin(); f_it != tri.finite_faces_end(); f_it++){

      //The safest spot inside a face is the point in the Voronoi diagram that is the dual of the face
      //Being the spot equally far from all the vertices of the face triangle, it's the safest spot
      //To calculate the distance to any dementor, it's possible to chose any vertex in the face triangle
      FT safe_inside_face = CGAL::squared_distance(f_it->vertex(0)->point(), tri.dual(f_it));

      //For now consider the Voronoi dual as the safest spot to be
      f_it->info() = {false, safe_inside_face};

      for(int i = 0; i < 3; i++){
        auto neighbor = f_it->neighbor(i);

        if(!tri.is_infinite(neighbor)){  //Consider only direct exits for now
          continue;
        }

        //For the faces near the infinite space, decide if it's safer to remain inside the face
        //or to exit in the infinite space.
        //Safest means being the least close to any dementor at any time
        f_it->info().second = std::max(f_it->info().second, tri.segment(f_it, i).squared_length());
      }

      q.push({f_it->info().second, f_it});
    }

    while(!q.empty()){
      auto current_face = q.top().second;
      q.pop();

      if(!current_face->info().first){  //Face already computed

        //Update the neighbors
        for (int i = 0; i < 3; i++) {
          auto neighbor = current_face->neighbor(i);

          if (tri.is_infinite(neighbor)){
            continue;
          }

          if(!neighbor->info().first){

            //Find which is the most limiting distance when choosing to go from neighbor to the current face
            //The limiting factor may be going from the neighbor to the current face, or the current face itself
            FT limit_neighbor_to_current = std::min(tri.segment(current_face, i).squared_length(), current_face->info().second);

            //Find if the neighbor is already safer, or it's better to go to the current face
            neighbor->info().second = std::max(neighbor->info().second, limit_neighbor_to_current);

            q.push({neighbor->info().second, neighbor});
          }
        }
        current_face->info().first = true;
      }
    }

    for(int i = 0; i < m; i++){
      long x, y, s;
      std::cin>>x>>y>>s;
      P fugitive(x, y);

      //Calculate which is the safe radius. It is equivalent to (s+d)^2, but it has no overflow errors
      FT r = CGAL::squared_distance(P(0, 0), P(s + d, 0));

      //Fugitive is already too close
      if(CGAL::squared_distance(fugitive, tri.nearest_vertex(fugitive)->point()) < r){
        std::cout<<""n"";
        continue;
      }

      auto f = tri.locate(fugitive);
      if(tri.is_infinite(f)){
        std::cout << ""y"";

      }else if (f->info().second < 4*r){  //During the night, the safe spot must be 2*(d+s) from dementors
        std::cout << ""n"";

      }else{
        std::cout << ""y"";
      }
    }

    std::cout<<""\n"";
  }
}
"
"India","Twenty days after their departure from London, Phileas Fogg and his travel companion Jean Passepartout reach Bombay and set foot on Indian soil. To arrive in India a bit early, Fogg did pay some large amount of money to accelerate their steamboat and thus Fogg‚Äôs former fortune is slowly shrinking. But traveling through India should be quick and cheap thanks to a new railway section straight to Calcutta. Or at least so they thought... Unfortunately, the train tracks from Bombay to Calcutta are still incomplete. A Ô¨Åfty mile long segment in the middle from Kholby to Allahabad is missing. Fifty miles are too far for Fogg and Passepartout to just walk, because they brought many more suitcases with them than they can possibly carry themselves. So Fogg asked around and found some guides that are willing to transport his luggage using elephants, at least for parts of their missing journey. For each guide, Fogg learned in which city the guide lives. Each guide trained all his elephants to bring goods to a single other city. Elephants are very clever, hence each elephant knows how to walk to this other city on his own. Unfortunately, the elephants can not Ô¨Ånd the way back to their guide though and therefore can only be used to walk their route at most once. Fogg also learned how much each guide charges per elephant and how many elephants each guide owns. Each elephant can carry at most... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains Ô¨Åve integers c g b k a, separated by a space. They denote ‚Äì c, the number of cities p0, . . . , pc‚àí1 in India (2 ‚©Ωc ‚©Ω103); ‚Äì g, the number of guides in India (0 ‚©Ωg ‚©Ω5 ¬∑ 103); ‚Äì b, the total budget that Fogg is willing to spend on luggage transportation by ele- phants (0 ‚©Ωb ‚©Ω109); ‚Äì k, the number of the city pk where Kholby is located (0 ‚©Ωk ‚©Ωc ‚àí1); ‚Äì a, the number of the city pa where Allahabad is located (0 ‚©Ωa ‚©Ωc ‚àí1 and k Ã∏= a). ‚Ä¢ The following g lines deÔ¨Åne the guides in India. Each line contains four integers x y d e, separated by a space and such that 0 ‚©Ωx ‚©Ωc ‚àí1, 0 ‚©Ωy ‚©Ωc ‚àí1, 1 ‚©Ωd ‚©Ω103, and 1 ‚©Ωe ‚©Ω103. Such a line describes a guide that owns e elephants and is willing to send them with one suitcase per elephant from city px to city py at a cost of d per elephant. Note: Several guides may be willing to transport suitcases between... Output: For each test case output one line with a single integer that denotes the maximum number of suitcases that Phileas Fogg can afford to have transported from Kholby to Allahabad without exceeding his budget.","India - solution There is a lot of time, so it's possible to do a binary search on the number of suitcases transported, considering that the maximum number of suitcases that can be transported is equal to the total number of elephants. In the binary search, create a graph for maximum flow and minimum cost. Connect the source to the first city and the last city to the sink with a capacity equal to the middle value between low and high. Calculate the flow and the cost. If the flow is less than the number of suitcases that the iteration tried to...","Max Flow / Min Cut","#include <iostream>
#include <climits>
#include <algorithm>
#include <vector>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>
#include <boost/graph/find_flow_cost.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor,
                boost::property <boost::edge_weight_t, long>>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}
    void add_edge(int from, int to, long capacity, long cost) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      auto w_map = boost::get(boost::edge_weight, G); // new!
      const edge_desc e = boost::add_edge(from, to, G).first;
      const edge_desc rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0; // reverse edge has no capacity!
      r_map[e] = rev_e;
      r_map[rev_e] = e;
      w_map[e] = cost;   // new assign cost
      w_map[rev_e] = -cost;   // new negative cost
    }
};

typedef struct{
  int x;
  int y;
  int d;
  int e;
} guide_t;

long get_cost(std::vector<guide_t> &guides, int current_luggages, int c, int k, int a){
  graph G(c+2);
  edge_adder adder(G);

  for(guide_t guide: guides){
    adder.add_edge(guide.x, guide.y, guide.e, guide.d);
  }

  const int source = c;
  const int sink = c+1;

  adder.add_edge(source, k, current_luggages, 0);
  adder.add_edge(a, sink, current_luggages, 0);

  int flow = boost::push_relabel_max_flow(G, source, sink);
  boost::successive_shortest_path_nonnegative_weights(G, source, sink);
  int cost = boost::find_flow_cost(G);

  //It may be possible for the cost to be low only because not all suitcases are sent
  //If so, increase the cost to make it try less suitcases next time
  if(flow < current_luggages){
    cost = INT_MAX;
  }

  return cost;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int c, g, b, k, a;  //c = cities, g = guides, b = budget, k = start, a = end
    std::cin>>c>>g>>b>>k>>a;

    graph G(c);
    edge_adder adder(G);

    int max_luggages = 0;
    std::vector<guide_t> guides(g);
    for(int i = 0; i < g; i++){
      int x, y, d, e;
      std::cin>>x>>y>>d>>e;

      guides[i] = {x, y, d, e}; //Guide i has e elephants that go from x to y, with cost d for each one
      max_luggages += e;
    }

    //There is a looooot of time, so it's possible to do binary search on
    //the number of luggages that can be used.
    //For each try, add or remove luggages depending if the cost is lower or higher than the budget

    //The maximum number of suitcases that can be transported is equal to the number of elephants
    long low = 0, high = max_luggages;
    long res = -1;

    while(low <= high){
      long mid = (low+high)/2;

      int cost = get_cost(guides, mid, c, k, a);

      if(cost > b){
        high = mid-1;

      }else if(cost < b){
        low = mid+1;
        res = std::max(res, mid);

      }else{
        res = mid;
        break;
      }
    }

    std::cout<<res<<""\n"";
  }
}
"
"Legions","Knowing that the Gaulish village is temporarily out of magic potion, Julius Caesar has sent all his troops to attack in an attempt to subdue the rebels. In a desperate move, Ast√©rix and Panoramix venture into the woods to gather the missing ingredients to prepare a new batch of the potion. Having found all the ingredients, they realize that they are now completely surrounded by Roman legions. Fortunately, the Romans seem to be oblivious to their advantage, and so Ast√©rix and Panoramix stay hidden in the woods. Every legion lies in a straight line formation and is waiting for the signal to attack. There are so many soldiers that from the perspective of Ast√©rix and Panoramix, every legion appears as (an unbounded number of soldiers arranged in) a straight line. Ast√©rix and Panoramix know that they need to get back to the village before the attack begins or the consequences will be dire. Their only option is to make a fire and brew the potion right there in the woods. They have all the ingredients ready. However, the moment they start making the fire, the Romans will notice the smoke and every single soldier will immediately run straight towards them. All soldiers within the same legion run at the same speed. However, soldiers in different legions may run at different speeds. Knowing the position and speed of the legions, Ast√©rix and Panoramix need to choose the location where to... Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing three integers xs ys n, separated by a space. They denote ‚Äì (xs, ys), the initial location of Ast√©rix and Panoramix (|xs|, |ys| ‚©Ω224); ‚Äì n, the number of legions (1 ‚©Ωn ‚©Ω2 ¬∑ 103). ‚Ä¢ The following n lines define the legions. Each legion is described by four integers a b c v, separated by a space. They denote ‚Äì a, b, c, the coefficients of the equation ax + by + c = 0 of the straight line where the legion is positioned (|a|, |b|, |c| ‚©Ω224; you may suppose that ‚àö a2 + b2 > 0 is an integer); 1 ‚Äì v, the speed of the legion (1 ‚©Ωv ‚©Ω28), meaning that every soldier in this legion moves a distance of v per second. You may assume that the n straight lines that represent legions are pairwise distinct and that the initial location of Ast√©rix and Panoramix does not lie on any of these lines. You may also assume that any ray emanating from (xs, ys)... Output: The output for each test case consists of a separate line that contains a single integer that denotes the maximum preparation time in seconds among all reachable locations, rounded down to the nearest integer.","Legions - solution The goal is to maximize the time needed to reach the target point while, at the same time, making sure that the starting point and the target point are on the same side of each line. It's necessary to create a LP solver with variables $p_x$ and $p_y$ to describe the target position and a variable $t$ to describe the time needed to reach that point, starting from each line. The main expression can be written as $t \cdot v \cdot \sqrt{a^2+b^2} = |a \cdot p_x + b \cdot p_y + c|$. For each line of soldiers, calculate if the...","Computational Geometry (CGAL)","#include <iostream>
#include <algorithm>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

typedef long IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    long x, y, n;  //(x, y) = starting position. n = number of legions
    std::cin>>x>>y>>n;

    const int px = 0;
    const int py = 1;
    const int prep = 2;

    Program lp (CGAL::SMALLER, false, 0, false, 0);

    for(int i = 0; i < n; i++){
      long a, b, c, v;
      std::cin>>a>>b>>c>>v;

      long k = std::sqrt(a*a+b*b);

      //The target point P being reachable from (x, y) means that no legion is between the starting point and P.
      //This means that they are on the same side of the line

      //If relative position is greater than 0, the absolute value can be removed without any other change
      //The equation will be: time * v * sqrt(...) <= a*x+b*y+c.
      //The distance must have an upper limit because it need to be maximized
      if(a*x + b*y + c >= 0){
        lp.set_a(prep, i, v*k);
        lp.set_a(px, i, -a);
        lp.set_a(py, i, -b);

        lp.set_b(i, c);
      }else{   //Invert the signs in the absolute value
        lp.set_a(prep, i, v*k);
        lp.set_a(px, i, a);
        lp.set_a(py, i, b);

        lp.set_b(i, -c);
      }
    }
    //Time needs to be positive
    lp.set_l(prep, true, 0);

    //Maximize time
    lp.set_c(prep, -1);

    Solution s = CGAL::solve_linear_program(lp, ET());
    //Division is good enough to find lower bound
    std::cout << -s.objective_value_numerator()/s.objective_value_denominator() << ""\n"";
  }
}
"
"Phantom Menace","Your task is to block all possible escape routes (from any given starting location to any given destination) with battleships. A battleship can be placed on any astronomical object and blocks all escape routes that use this astronomical object. Furthermore, the Trade Federation wants to use as few battleships as possible. Since you have no choice but to help the Trade Federation, let us hope that the starship‚Äôs hyperdrive will enable Queen Amidala, Qui-Gon Jinn and Obi- Wan Kenobi to break through the blockade... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains four integers n m s d, separated by a space and such that 4 ‚©Ωn ‚©Ω103, m ‚©Ω2 ¬∑ 104 and 2 ‚©Ωs, d ‚©Ωn. Here n denotes the number of astronomical objects, m the number of links between astronomical objects, s the number of given starting locations and d the number of given destinations. ‚Ä¢ The following m lines deÔ¨Åne the links between astronomical objects (0-based). Each link is described by two integers i j, separated by a space and such that 0 ‚©Ωi, j ‚©Ωn ‚àí1, meaning that the starship can travel from object i to object j (but not necessarily vice versa). ‚Ä¢ Two lines follow. The Ô¨Årst contains a list of s space separated integers i, 0 ‚©Ωi ‚©Ωn ‚àí 1, denoting the given set of starting locations S. The second contains a list of d space separated integers j, 0 ‚©Ωj ‚©Ωn ‚àí1, denoting the given set of destinations D. You may assume that all starting... Output: For each test case output a line with one integer k that is the minimum number of battleships needed to block all escape routes, as deÔ¨Åned below. 1 An escape route from S to D is a sequence v0, . . . , v‚Ñìwith v0 ‚ààS and v‚Ñì‚ààD such that for all 0 ‚©Ωi ‚©Ω‚Ñì‚àí1 there is a link from the astronomical object vi to the astronomical object vi+1. A group of k ‚©æ0 battleships can block all possible escape routes from S to D, if there is a set {p0, . . . , pk‚àí1} of k astronomical objects such that for every escape route v0, . . . , v‚Ñìthere exist i, j ‚ààN with vi = pj (that is, a battleship is positioned at the astronomical object vi). Note that it is possible to place battleships on starting locations and destinations.","Phantom Menace - solution Represent each vertex with two vertices. For each edge, connect the odd part of the source vertex to the even part of the target vertex. Connect the source of the MaxFlow to the even parts of the vertices of the starting planets. Connect the odd parts of the vertices of the destination planets to the sink of the MaxFlow. For each vertex, connect its even part to its odd part. Find the maximum flow that will be equal to the minimum cut. By representing each vertex with an edge, the minimum cut will go through the...","Max Flow / Min Cut","#include <iostream>
#include <climits>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef traits::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      const auto e = boost::add_edge(from, to, G).first;
      const auto rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0; // reverse edge has no capacity!
      r_map[e] = rev_e;
      r_map[rev_e] = e;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, s, d;  //n = astro objects, m = links, s = starting loc, d = destinations
    std::cin>>n>>m>>s>>d;

    graph G(2*n);
    edge_adder adder(G);

    //Connect the two parts of each vertex
    for(int i = 0; i < n; i++){
      adder.add_edge(2*i, 2*i+1, 1);
    }

    //Connect odd part of the source vertex to the even part of the target vertex
    for(int i = 0; i < m; i++){
      int x, y;
      std::cin>>x>>y;

      adder.add_edge(2*x+1, 2*y, 1);
    }

    const vertex_desc source = boost::add_vertex(G);
    const vertex_desc sink = boost::add_vertex(G);

    //Connect source to even part of the starting vertices
    for(int i = 0; i < s; i++){
      int x;
      std::cin>>x;

      adder.add_edge(source, 2*x, INT_MAX);
    }

    //Connect odd part of the destination vertices to the sink
    for(int i = 0; i < d; i++){
      int x;
      std::cin>>x;

      adder.add_edge(2*x+1, sink, INT_MAX);
    }

    //By dividing in two the vertices, it's like doing a min cut on the vertices
    long flow = boost::push_relabel_max_flow(G, source, sink);
    std::cout << flow << ""\n"";
  }
}
"
"New York","The morning after missing his connection from New York to Liverpool, Phileas finds himself walking along the banks of the Hudson river looking for ships that are about to depart. He is already losing hope when he notices a trading ship preparing for departure‚Äîthe Henrieta. He rushes straight to the captain, a peculiar person under the name of Andrew Speedy, and enquires about the journey, departure time, destination, etc. After some convincing (involving a non-trivial amount of money), Captain Speedy agrees to take Phileas and his party aboard. However, the currents are strong at this time of the year and the weather is unkind. Before setting sail, Captain Speedy insists to have a proper schedule for the journey in place. The journey across the Atlantic Ocean passes through a sequence of critical points. New York is the origin, critical point 0, and the remaining critical points 1, . . . , n ‚àí1, are scattered across the ocean. From every critical point, there may be several routes to sail to other critical points, or‚Äîif no such route exists‚Äîthe critical point is considered to be secure and the journey may continue without obstructions from there on. Every route can be sailed in one direction only, never backwards. A sequence s0, . . . , s‚Ñì‚àí1 of critical points such that there is a route from sj‚àí1 to sj, for all j ‚àà{1, . . . , ‚Ñì‚àí1}, is called a trip of length ‚Ñì. The routes are... Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers n m k, separated by a space. They denote ‚Äì n, the number of critical points (1 ‚©Ωn ‚©Ω105); ‚Äì m, the optimal trip length for a single day (2 ‚©Ωm ‚©Ω104); ‚Äì k, the maximum risk Captain Speedy is willing to take (0 ‚©Ωk ‚©Ω104). ‚Ä¢ The following line defines the temperature at the critical points. It contains n integers h0 . . . hn‚àí1, separated by a space, and such that 0 ‚©Ωhi < 231, for i ‚àà{0, . . . , n ‚àí1}. Here hi denotes the temperature at the i-th critical point. 1 ‚Ä¢ The following n‚àí1 lines define the routes. Each line consists of two integers u v, separated by a space, and such that u, v ‚àà{0, . . . , n ‚àí1}. This means that there exists a route to sail from the critical point u to the critical point v. Output: For each test case output a single line with a sequence of all critical points, separated by a space and listed in increasing order, for which there exists a feasible trip starting there. If there is no such critical point, output a single line with ‚ÄòAbort mission‚Äô.","New York - solution The problem can be solved using a sliding window on a tree. It's necessary to have a deque to store the current path, a multiset to store all the temperatures of the current path, and a vector or a set to store the valid starting points. Recursively: - Add a new point to the path and consider its temperature. - If the path is too long, remove (and store) the first point in the path. To do so, it's necessary to use erase(iterator) and not erase(value) because the latter erases all the occurrences (to find the correct...","Two pointers / Sliding window","#include <iostream>
#include <vector>
#include <deque>
#include <set>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

void solve(int next, std::deque<int> &path, std::multiset<int> &path_temps, VI &temps, VVI &graph, VI &starts, int m, int k){

  int removed = -1;

  //The path may be too long at this point
  if((int)path.size() == m){
    removed = path.front();
    path.pop_front();

    //Cannot use erase(value) because it deletes all instances
    path_temps.erase(path_temps.find(temps[removed]));
  }

  path.push_back(next);
  path_temps.insert(temps[next]);

  //Check if the path is valid
  if((int)path.size() == m){
    //The first element of a multiset is the smallest, the last the largest
    int max = *path_temps.rbegin();
    int min = *path_temps.begin();

    if(max-min <= k){
      starts.push_back(path.front());
    }
  }

  //Explore children recursively
  for(int p: graph[next]){
    solve(p, path, path_temps, temps, graph, starts, m, k);
  }

  //At this point, it's necessary to restore the original state of the path
  //This allows to not need a copy for each recursive call
  path_temps.erase(path_temps.find(temps[next]));
  path.pop_back();

  //Restore first element of path.
  if(removed != -1){
    path_temps.insert(temps[removed]);
    path.push_front(removed);
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, k; //n = points, m = length, k = max risk
    std::cin>>n>>m>>k;

    VI temps(n);
    for(int i = 0; i < n; i++){
      int h;
      std::cin>>h;

      temps[i] = h;
    }

    VVI graph(n);
    for(int i = 0; i < n-1; i++){
      int u, v;
      std::cin>>u>>v;

      graph[u].push_back(v);
    }

    VI starts;
    std::deque<int> path;
    std::multiset<int> path_temps;

    solve(0, path, path_temps, temps, graph, starts, m, k);

    //Reorder the start positions
    std::set<int> ordered_starts;
    ordered_starts.insert(starts.begin(), starts.end());

    if(ordered_starts.size() == 0){
      std::cout<<""Abort mission\n"";
    }else{
      for(int s: ordered_starts){
        std::cout<<s<<"" "";
      }
      std::cout<<""\n"";
    }
  }
}
"
"Pied Piper","‚ÄúDer Rattenf√§nger zog demnach ein Pfeifchen heraus und pfiff, da kamen alsobald die Ratten und M√§use aus allen H√§usern hervorgekrochen und sammelten sich um ihn herum.‚Äù ‚ÄúThe rat-catcher produced a small pipe and whistled. Soon, rats and mice came creeping out from all the houses and gathered around him.‚Äù Deutsche Sagen by Jacob Grimm (1785‚Äì1863) and Wilhelm Grimm (1786‚Äì1859) When word of the dire rat infestation plaguing the city of Hamelin reached the ears of the Pied Piper, he heeded the call for aid without hesitation. The prospect of the bountiful reward of one gold penny per rat eliminated, offered by the honorable mayor, proved sufficient inducement for the benevolent Piper to put his musical talent to use to lure the vermin from their lair. Upon his arrival at the city gate, he is greeted by the mayor, who lays before the Piper a map of Hamelin in intricate detail. The map shows a total of n public squares, numbered from 0 to n ‚àí1, scattered across the city. The public square at the entrance of the city, where the Piper currently stands, is public square 0. The map also indicates that there are m one-way streets in Hamelin, each of which leads from some public square to another and has a number of rats residing on it. A sequence of public squares s0, . . . , s‚Ñìand a sequence of streets r0, . . . , r‚Ñì‚àí1 such that ri leads from si to si+1 for each i ‚àà{0, . . . , ‚Ñì‚àí1}, is... Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains two integers n m, separated by a space. They denote ‚Äì n, the number of public squares (4 ‚©Ωn ‚©Ω500); and 1 ‚Äì m, the number of one-way streets connecting two public squares (4 ‚©Ωm ‚©Ω4 ¬∑ 104). ‚Ä¢ The following m lines define the streets and the number of rats on them. Each line consists of three integers u v f separated by a space, such that u, v ‚àà{0, . . . , n ‚àí1} with u Ã∏= v, and 1 ‚©Ωf ‚©Ω105, indicating that there exists a street leading from public square u to public square v with f rats on it. It is guaranteed that there is no street from 0 to n ‚àí1 and there is no street from n ‚àí1 to 0. Furthermore, for each u, v ‚àà{0, . . . , n ‚àí1}, there is at most one street from u to v. Output: The output for each test case consists of a separate line containing a single integer that denotes the maximum number of rats on the streets in an acceptable plan.","Pied Piper - solution It's necessary to create a DP table dp[i][j] with dimensions $n \times n$ (where $n$ is the number of squares). dp[i][j] contains the highest number of rats that can be gathered going from 0 to i and going back from j to 0. The final answer will be dp[n-1][n-1]. It's necessary to populate the table, considering all the squares dp[i][0] that are reachable from square 0 (outgoing edges) and all the squares dp[0][j] that can reach square 0 (incoming edges). All the cells with the default value will be skipped because they...","Dynamic Programming","#include <iostream>
#include <vector>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;

typedef struct{
  int other;
  int rats;
} street_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m;  //n = squares, m = streets
    std::cin>>n>>m;

    std::vector<std::vector<street_t>> graph(n);
    std::vector<std::vector<street_t>> inv_graph(n);
    for(int i = 0; i < m; i++){
      int u, v, f;
      std::cin>>u>>v>>f;

      graph[u].push_back({v, f});
      inv_graph[v].push_back({u, f});
    }

    //dp[i][j] contains the highest amount of rats that can be taken going from 0 to i
    //and from j to 0. The final answer is dp[n-1][n-1]

    //This means I have to try all the possible combinations that reach n-1 going through i
    //And return back though j
    VVI dp(n, VI(n, 0));

    //It's necessary to populate the starting point because non-populated cells will be skipped because unreachable

    //Populate all the squares that can be reached from 0 while going forward
    for(street_t s: graph[0]){
      dp[s.other][0] = s.rats;
    }

    //Populate all the squares that can reach 0 while going backward
    for(street_t s: inv_graph[0]){
      dp[0][s.other] = s.rats;
    }

    //Try all the possible cells
    for(int i = 0; i < n; i++){
      for(int j = 0; j < n; j++){

        //Consider only the cells that were populated, that means that they are
        //reachable (going forward or backward)
        if(dp[i][j] != 0){

          //Try all the landing positions going forward from i
          for(auto out_i: graph[i]){

            //Consider only the landing positions with a square ID higher than the starting
            //point for the backward path. This avoids using the same square both ways
            if(out_i.other > j || out_i.other == n-1){
              dp[out_i.other][j] = std::max(dp[out_i.other][j], dp[i][j] + out_i.rats);
            }
          }

          //Try all the landing positions going backward from j
          for(auto in_j: inv_graph[j]){

            //Consider only the landing positions with a square ID higher than the starting
            //point for the forward path. This avoids using the same square both ways
            if(in_j.other > i || in_j.other == n-1){
              dp[i][in_j.other] = std::max(dp[i][in_j.other], dp[i][j] + in_j.rats);
            }
          }
        }
      }
    }

    std::cout<<dp[n-1][n-1]<<""\n"";
  }
}
"
"Return of the Jedi","During the Star Wars, the Rebels showed an incredible amount of courage and diligence, but they lacked an efÔ¨Åcient organization of their intelligence. Recently the Jedi developed a tech- nology to build a direct information transmission channel between two planets. Such a channel can then be used to transmit information between the two planets in both directions. Using this technology Luke Skywalker wants to construct a network that allows to transmit‚Äîeither directly or indirectly via other planets‚Äîinformation from every planet in the galaxy to every other planet. A network with this property we call a warp network. For a particular pair of plan- ets the cost of building a direct channel between them depends on several parameters, such as distance, the number of army units of the Galactic Empire between the planets, cosmic dust, and so on. As the rebels are short on resources to spend, Luke asks a fellow rebel, Princess Leia, to come up with a cost effective warp network. Princess Leia proposes the following method: enumerate all planets with numbers 1, . . . , n, sorted by increasing importance. (We assume that no two planets have the same importance.) In this way each planet receives a unique number. The method proceeds in n steps. In the Ô¨Årst step, the network consists of the planet Tatooine only (the home planet of Luke and Darth Vader). Then repeat the following process n... Input: The Ô¨Årst line of the input contains the number t ‚©Ω15 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains two integers n i, separated by a space and such that 3 ‚©Ωn ‚©Ω103 and 1 ‚©Ωi ‚©Ωn. Here n denotes the number of planets and i denotes the index of Tatooine. ‚Ä¢ The following n ‚àí1 lines describe the costs for building transmission channels. The j-th line, for j ‚àà{1, . . . , n ‚àí1}, contains n ‚àíj integer numbers between 1 and 220, where the 1If two or more planets are eligible to be added to the network because the cost of doing so is the same, then select the most important planet among them. If the selected planet has two or more channels of lowest cost that would connect it to the existing network, build the channel among those that leads to the most important planet. 1 k-th number, for k ‚àà{1, . . . , n ‚àíj}, denotes the cost for building a transmission channel between planets j and j + k. Output: For each test case output a line with one integer that is the minimum cost of a warp network that is different from the network constructed by Princess Leia‚Äôs method.","Return of the Jedi - solution The solution involves finding the second-best MST. Method 1 Create an undirected weighted graph using BGL. At the same time, save in a separate matrix (using vectors) all the costs of the edges. After finding the MST using the BGL function, create a matrix (using vectors) that contains all the undirected edges of the MST. At the same time, mark if an edge is inside the MST and calculate the cost of the MST. Using DFS, calculate for each pair of nodes $u$ and $v$ in the MST the most expensive edge in the MST...","DFS","#include <iostream>
#include <vector>
#include <algorithm>
#include <climits>

#include <boost/pending/disjoint_sets.hpp>

typedef struct{
  int from;
  int to;
  int cost;
} edge_t;

//Cheaper edges first
struct compEdges{
  bool operator()(edge_t &e1, edge_t &e2){
    return e1.cost < e2.cost;
  }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, tatooine; //n = planets, tatooine = its index
    std::cin>>n>>tatooine;

    std::vector<edge_t> edges;
    for(int j = 0; j < n; j++){
      for(int k = j+1; k < n; k++){
        int x;
        std::cin>>x;

        edges.push_back({j, k, x});
      }
    }

    std::sort(edges.begin(), edges.end(), compEdges());

    //Best cost of the second MST
    int best_cost = INT_MAX;

    //Skip one edge at a time
    for(int to_skip = 0; to_skip < n-1; to_skip++){

      //Add edges until all nodes are connected, starting from the cheapest edges
      //Consider edges only if they connect two differenct connected components
      boost::disjoint_sets_with_storage<> mst(n);
      int n_components = n;

      int tot_cost = 0;
      bool skipped = false;

      for(int j = 0; j < (int)edges.size() && n_components > 1; j++){
        edge_t e = edges[j];

        int c1 = mst.find_set(e.from);
        int c2 = mst.find_set(e.to);

        if (c1 != c2) {
          //It's the same thing trying to skip, one by one, all the edges in the first MST
          //And using another edge to connect the connected components that would have been connected
          //By the skipped edge
          if(!skipped && n-n_components == to_skip){
            skipped = true;

          }else{
            tot_cost += e.cost;
            mst.link(c1, c2);
            n_components--;
          }
        }
      }

      best_cost = std::min(best_cost, tot_cost);
    }

    std::cout<<best_cost<<""\n"";
  }
}
"
"Rumpelstitskin","‚ÄúHeute back ich, Morgen brau ich, √úbermorgen hol ich der K√∂nigin ihr Kind; Ach, wie gut ist, da√ü niemand wei√ü, da√ü ich Rumpelstilzchen hei√ü!‚Äù ‚ÄúToday I bake, tomorrow I brew, The day after that the queen‚Äôs child comes in; And oh! I am glad that nobody knew that the name I am called is Rumpelstiltskin!‚Äù Kinder‚Äì und Hausm√§rchen by Jacob Grimm (1785‚Äì1863) and Wilhelm Grimm (1786‚Äì1859) After many years, Rumpelstilzchen is living on a group of islands. One day he decides to spin as much gold as he can in one night at the islands. He discovers that he can spin one yarn of superior gold if he uses one sack of wheat straw and one sack of barley straw. However, wheat straw is only available in the castle of the kingdom to the west of the islands and barley straw in only available in the castle of the kingdom to the east of the islands. The queen‚Äôs father, the miller, wants to repay Rumpelstilzchen for helping his daughter and agrees to transport the straw from both kingdoms to the islands for free. The miller transports the straw during the day, and Rumpelstilzchen can spin gold during the night. The miller has two independent transportation networks. The transportation networks consist of roads between cities, and shipping routes connecting cities of the two kingdoms to the islands. The two transportation networks do not have any cities in common, and there are no roads connecting... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows:  It starts with a single line containing nine integers n pG pH eG eH fG fH sG sH, sepa- rated by a space. For X ‚àà{G, H}, they denote ‚Äì n, the number of islands (1 ‚©Ωn ‚©Ω500); ‚Äì pX, the number of cities in the network X (1 ‚©ΩpX ‚©Ω103); 1 ‚Äì eX, the number of edges of X (1 ‚©ΩeX ‚©Ω5 ¬∑ 103); ‚Äì fX, the number of edges from X to the islands (1 ‚©ΩfX ‚©Ω2 ¬∑ 103); and ‚Äì sX, the number of sacks of straw available in the castle of X (1 ‚©ΩsX ‚©Ω103).  The following line contains n integers a0 ... an‚àí1, separated by a space. They denote the preference score of the spinning wheel on each of the n islands (0 ‚©Ωai ‚©Ω210).  The following eG+eH lines deÔ¨Åne the edges of G (Ô¨Årst) and H (second). Each line contains three integers u v c, separated by a space, that deÔ¨Åne a one-way road of capacity c from city u to city v in the respective network (0 ‚©Ωu < pX, 0 ‚©Ωv < pX, u Ã∏= v, 0 ‚©Ωc ‚©Ω224).  The next fG... Output: The output for each test case consists of a separate line containing two integers y s, separated by a space. They denote y, the maximum number of yarns of superior gold that Rumpelstilzchen can spin during the night; and s, the corresponding maximum total preference score of the used spinning wheels for that number of yarns of superior gold.","Rumpelstitskin - solution It's not possible to have the two networks meet on a single island because it's not possible to have a flow out of an island equal to exactly 0 or 2 (without it being 1). For this reason, it's necessary to have a flow from one network to the other, going through the islands. The source is connected to the castle of network A with a certain amount of sacks usable, and then network A is constructed. The islands are represented using two nodes. Network A connects to the even node. There is an edge of capacity 1 (each...","Max Flow / Min Cut","#include <iostream>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>
#include <boost/graph/find_flow_cost.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor,
                boost::property <boost::edge_weight_t, long>>>>> graph; // new! weightmap corresponds to costs

typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}
    void add_edge(int from, int to, long capacity, long cost) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      auto w_map = boost::get(boost::edge_weight, G);
      const edge_desc e = boost::add_edge(from, to, G).first;
      const edge_desc rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
      w_map[e] = cost;
      w_map[rev_e] = -cost;
    }
};

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;  //n = islands
    int pA, pB;  //cities in network X
    int eA, eB;  //edges in network X
    int fA, fB;  //edges from X to the islands
    int sA, sB;  //sacks in the network X
    std::cin>>n>>pA>>pB>>eA>>eB>>fA>>fB>>sA>>sB;

    //Represent each island with two nodes,
    //connected with an edge of capacity 1 (a spinner can be used only once)
    //and cost the opposite of the preference (shifted up to use the best algorithm)
    graph G(2*n+pA+pB+2);
    edge_adder adder(G);

    const int source = 2*n+pA+pB;
    const int sink = source+1;

    //All the resources are contained in the castles of the two kingdoms
    adder.add_edge(source, 2*n, sA, 0);
    adder.add_edge(2*n+pA, sink, sB, 0);

    //Islands from 0 to 2n-1
    for(int i = 0; i < n; i++){
      int a;
      std::cin>>a;

      //Can use each island only once
      adder.add_edge(2*i, 2*i+1, 1, 1024 - a);
    }

    //Network A: from 2*n to 2*n+pA-1
    for(int i = 0; i < eA; i++){
      int u, v, c;
      std::cin>>u>>v>>c;

      adder.add_edge(2*n+u, 2*n+v, c, 0);
    }

    //Network B: from 2*n+pA to 2*n+pA+pB-1
    //The flow will go from network A to network B through the islands, so it's necessary to invert the verse of the edges
    for(int i = 0; i < eB; i++){
      int u, v, c;
      std::cin>>u>>v>>c;

      adder.add_edge(2*n+pA+v, 2*n+pA+u, c, 0);
    }

    //From network A to islands
    for(int i = 0; i < fA; i++){
      int u, v, c;
      std::cin>>u>>v>>c;

      adder.add_edge(2*n+u, 2*v, c, 0);
    }

    //From the islands to network B
    for(int i = 0; i < fB; i++){
      int u, v, c;
      std::cin>>u>>v>>c;

      adder.add_edge(2*v+1, 2*n+pA+u, c, 0);
    }

    int flow = boost::push_relabel_max_flow(G, source, sink);
    boost::successive_shortest_path_nonnegative_weights(G, source, sink);
    int cost = boost::find_flow_cost(G);

    std::cout<<flow<<"" ""<<1024*flow - cost<<""\n"";
  }
}
"
"Worldcup","Given all the constraints above, maximize the total proÔ¨Åt, which is simply the sum of all proÔ¨Åts made for each pair (w, s). Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains three integers n m c, separated by a space. They denote, respectively, the number n of warehouses (1 ‚©Ωn ‚©Ω200), the number m of stadiums (1 ‚©Ωm ‚©Ω20), and the number c of contour lines (0 ‚©Ωc ‚©Ω106). 1International Federation of Association Football. 2These are the lines that you typically see on a topographic map, to identify points with the same elevation. 1 ‚Ä¢ The following n lines describe the warehouses w1, . . . , wn. Each line contains four integers x y s a, separated by a space and such that |x|, |y| < 224, 0 ‚©Ωs ‚©Ω105 and 0 ‚©Ωa ‚©Ω100. Here, (x, y) denotes the position of the corresponding warehouse, s denotes its supply, and a denotes the alcohol content (in %) of the brand of Beer stored there. ‚Ä¢ The following m lines describe the stadiums s1, . . . , sm. Each line contains four integers x y d u, separated by a space and such that... Output: For each test case the corresponding output appears on a separate line. If it is possible to comply with your contract, the output is the maximum achievable total proÔ¨Åt in CHF, rounded down to the next integer (the rounding is towards ‚àí‚àû; for instance, ‚àí4.5 is rounded to ‚àí5). Otherwise, the output is RIOT!.","Worldcup - solution Even though there are a lot of variables (a maximum of $4000$), the number of inequalities is low enough to allow for the use of LP. Save the revenues multiplied by $100$, in order to use only integers in the solver. This means that, when crossing a contour, it's necessary to reduce the revenue by $1$ and not by $0.01$, and that, at the end, it's necessary to divide the result by $100$. In this problem, the fourth test case says that there are a maximum of 100 contours that contain at least a warehouse or a stadium, while...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Delaunay_triangulation_2.h>

typedef CGAL::Exact_predicates_inexact_constructions_kernel K;
typedef CGAL::Delaunay_triangulation_2<K> Triangulation;

typedef K::Point_2 P;

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

typedef struct{
  int index;
  P point;
  int s;  //supply liters
  int a;  //alcohol %
} warehouse_t;

typedef struct{
  int index;
  P point;
  int d;  //demand liters
  int u;  //limit liters*100
} stadium_t;

typedef struct{
  P point;
  long sq_r;
} contour_t;

long round_down(const CGAL::Quotient<ET> &input_val){
  double num = std::floor(CGAL::to_double(input_val));
  while (num > input_val) num -= 1;
  while (num+1 <= input_val) num += 1;
  return (long) num;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, c;  //n = warehouses, m = stadiums, c = contour lines
    std::cin>>n>>m>>c;

    std::vector<P> all_points;

    std::vector<warehouse_t> warehouses(n);
    for(int i = 0; i < n; i++){
      int x, y, s, a;
      std::cin>>x>>y>>s>>a;

      warehouses[i] = {i, P(x, y), s, a};
      all_points.push_back(P(x, y));
    }

    std::vector<stadium_t> stadiums(m);
    for(int i = 0; i < m; i++){
      int x, y, d, u;
      std::cin>>x>>y>>d>>u;

      stadiums[i] = {i, P(x, y), d, 100*u};
      all_points.push_back(P(x, y));
    }

    std::vector<std::vector<long>> revenue(n, std::vector<long>(m));
    for(int i = 0; i < n; i++){
      for(int j = 0; j < m; j++){
        int r;
        std::cin>>r;

        revenue[i][j] = 100*r;  //Multiplied by 100 to have integer revenue. Additional cost will be -1 and not -0.01
      }
    }

    //In the test case 4 description it says that there are at most 100 contours with at least one thing inside
    //Remove unneded contour lines, which are the ones without anything inside
    Triangulation tri;
    tri.insert(all_points.begin(), all_points.end());

    std::vector<contour_t> lines;
    for(int i = 0; i < c; i++){
      long x, y, r;
      std::cin>>x>>y>>r;

      //Keep only the contour lines with a building inside
      auto nearest_building = tri.nearest_vertex(P(x, y));
      long sq_d = CGAL::squared_distance(nearest_building->point(), P(x, y));
      long sq_r = r*r;
      if(sq_d < sq_r){
        lines.push_back({P(x,y), sq_r});
      }
    }

    //Adjust revenues
    for(contour_t con: lines){
      for(auto w: warehouses){
        bool w_inside = CGAL::squared_distance(w.point, con.point) < con.sq_r;
        for(auto s: stadiums){
          bool s_inside = CGAL::squared_distance(s.point, con.point) < con.sq_r;

          //Check if the stadium and the warehouse are on the same side of the contour line
          if(s_inside != w_inside){
            revenue[w.index][s.index] -= 1;
          }
        }
      }
    }

    Program lp (CGAL::SMALLER, true, 0, false, 0);

    //Each variable defines how many beers are sent from w_i to s_j
    //The variable index is w_i*m+s_j

    int counter = 0;

    //Consider the supply of each warehouse
    for(int w = 0; w < n; w++){
      for(int s = 0; s < m; s++){
        int var = w*m+s;  //Liters from w to s

        //Sum all the shipments from warehouse w_i to the different stadiums
        lp.set_a(var, counter, 1);
      }
      lp.set_b(counter, warehouses[w].s);
      counter++;
    }

    //Exact demand
    for(int s = 0; s < m; s++){
      //For each stadium
      //The first two inequalities set the beer amount
      //The third inequlity sets the alcohol limit

      for(int w = 0; w < n; w++){
        int var = w*m+s;  //Liters from w to s

        //Sum of the shipments less than or equal to the maximum
        lp.set_a(var, counter, 1);

        //Sum of the shipments more than or equal to the maximum
        lp.set_a(var, counter+1, -1);

        //Limit the amount of alcohol
        lp.set_a(var, counter+2, warehouses[w].a);
      }
      lp.set_b(counter, stadiums[s].d);
      lp.set_b(counter+1, -stadiums[s].d);
      lp.set_b(counter+2, stadiums[s].u);

      counter += 3;
    }

    //Maximize the profit (minimize the opposite)
    for(int w = 0; w < n; w++){
      for(int s = 0; s < m; s++){
        int var = w*m+s;
        lp.set_c(var, -revenue[w][s]);
      }
    }

    Solution sol = CGAL::solve_linear_program(lp, ET());

    if(sol.is_infeasible()){
      std::cout<<""RIOT!\n"";
    }else{
      std::cout<<round_down(-sol.objective_value()/100)<<""\n"";
    }
  }
}
"
"Augean Stables","‚ÄúThe Ô¨Çies, Ô¨Ålth, and stench were overwhelming and seemed to aÔ¨Äect everyone but King Augeas.‚Äù The Mythology of the Night Sky by David E. Falkner For his Ô¨Åfth labor, Hercules has been tasked to clean up King Augeas‚Äô Ô¨Ålthy stables in a single day. These stables have not been cleaned in over thirty years and over three thousand cattle heads live there. As such, the assignment is considered humiliating‚Äîrather than impressive, like the previous labors‚Äîand also impossible. The stables are divided into n individual stalls. The i-th stall currently contains a certain amount fi of Ô¨Ålth, which needs to be reduced to a smaller amount of at most ci for the stall to be considered clean. With no wish to humiliate himself by either carrying the dung out of the stalls by hand or by failing at this immense task completely, Hercules identiÔ¨Åes three crucial positions on the walls of the stables where he plans to knock holes and then let water Ô¨Çow through, carrying all of the accumulated Ô¨Ålth with it. Figuring out the ideal size of the three holes‚Äîso that enough water Ô¨Çows through each stall to wash it clean‚Äîis the task at hand. For each stall, Hercules notes down three numbers ki, ‚Ñìi, mi. He estimates that the amount of Ô¨Ålth removed from the i-th stall can be expressed as the weighted sum h1ki + h2‚Ñìi + h3mi, where h1, h2, h3 are freely selectable real numbers between 0 and 1 that measure the... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing one integer n, where n denotes the number of individual stalls in the stables (1 ‚©Ωn ‚©Ω100). ‚Ä¢ The following n lines deÔ¨Åne the individual stalls. The i-th such line contains Ô¨Åve integers f c k l m, separated by a space. They denote the initial amount fi of Ô¨Ålth in the i-th 1 stall (0 ‚©Ωfi < 225), the maximum allowable amount ci of Ô¨Ålth for it to be considered clean (0 ‚©Ωci ‚©Ωfi), and the numbers ki, ‚Ñìi, mi as explained above (|ki|, |‚Ñìi|, |mi| < 225). ‚Ä¢ The following line contains 24 integers a1 a2 . . . a24, separated by a space, where ai denotes the additional amount of water Ô¨Çow redirected from the river Alpheius if Hercules spends an additional i-th hour working on the corresponding trench (0 ‚©Ωai < 225). ‚Ä¢ The following line contains 24 integers p1 p2 . . . p24, separated by a space, where pi denotes the additional amount of water Ô¨Çow... Output: For each test case the corresponding output appears on a separate line. If even after working for 24 hours on each trench (i.e., after 2 √ó 24 = 48 hours in total) there remains a stall that is not clean, the output is ‚ÄúImpossible!‚Äù. Otherwise, the output is the smallest (integral) number of hours required to work on both trenches such that the stalls can be made clean.","Augean Stables - solution It's necessary to use LP with a particular technique when deciding how much to work. This is necessary because it's not possible to have the number of hours worked as a variable because the multiplications would make the problem not linear. Pay attention to the fact that $h_1$, $h_2$, and $h_3$ are the same for all the stables, not one for each stable. To limit the number of combinations to try, start with a base configuration where it's only possible to increase the number of hours worked on a canal (for example...","Computational Geometry (CGAL)","#include <iostream>
#include <vector>
#include <algorithm>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpz.h>

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

typedef struct{
  int f;  //Start filth
  int c;  //Max allowed filth
  long k;
  long l;
  long m;
} stall_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;  //n = stables
    std::cin>>n;

    std::vector<stall_t> stalls(n);
    for(int i = 0; i < n; i++){
      int f, c, k, l, m;
      std::cin>>f>>c>>k>>l>>m;

      stalls[i] = {f, c, k, l, m};
    }

    //Consider also the case where working 0 hours gives 0 more water
    std::vector<long> waterA(25);
    for(int i = 1; i < 25; i++){
      int a;
      std::cin>>a;

      waterA[i] = a + waterA[i-1];
    }

    //Consider also the case where working 0 hours gives 0 more water
    std::vector<long> waterB(25, 0);
    for(int i = 1; i < 25; i++){
      int b;
      std::cin>>b;

      waterB[i] = b + waterB[i-1];
    }

    //Constants for the LP solver
    const int h1 = 0;
    const int h2 = 1;
    const int h3 = 2;

    //Start with a configuration that allows one value only to grow and the other only to shrink
    //This allows to have only one behaviour in case of feasibility or infeasibility
    int workA = 0;
    int workB = 24;

    int min_hours = INT_MAX;
    while(workA <= 24 && workB >= 0){
      //Increasing the number of hours worked on A made the total number of hours worked worse
      if(workA + workB >= min_hours){
        workB--;
        continue;
      }

      //Solve the current configuration
      Program lp (CGAL::SMALLER, true, 0, true, 1);
      for(int i = 0; i < n; i++){
        int k = stalls[i].k + waterA[workA]*waterA[workA];
        int l = stalls[i].l + waterB[workB]*waterB[workB];
        int m = stalls[i].m + waterA[workA]*waterB[workB];

        lp.set_a(h1, i, -k);
        lp.set_a(h2, i, -l);
        lp.set_a(h3, i, -m);
        lp.set_b(i, stalls[i].c - stalls[i].f);
      }

      Solution s = CGAL::solve_linear_program(lp, ET());

      if(s.is_infeasible()){
        //Work more hours. Because of the starting configuration, it's possible to work more only on A
        workA++;
      }else{
        min_hours = std::min(min_hours, workA + workB);

        //Work less hours. Because of the starting configuration, it's possible to work less only on B
        workB--;
      }
    }

    if(min_hours == INT_MAX){
      std::cout<<""Impossible!\n"";
    }else{
      std::cout<<min_hours<<""\n"";
    }
  }
}
"
"Casino Royale","Your task is to come up with a travel schedule by selecting a subset of missions to be executed. The non-selected missions are deferred. The goal is to maximize the sum of priorities of the executed missions, while respecting the speciÔ¨Åed limit on the number of agents simultaneously on the train between any two consecutive stops. (Agents that enter the train at a station do not interfere with those leaving the train at that station.) Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a line that contains three integers n m l, separated by a space. They denote ‚Äì n, the number of train stops t0, t1, . . . , tn‚àí1 (2 ‚©Ωn ‚©Ω3 ¬∑ 102). ‚Äì m, the number of missions (1 ‚©Ωm ‚©Ω105). ‚Äì ‚Ñì, the maximum number of agents that can be on the train between any two consec- utive stops (1 ‚©Ω‚Ñì‚©Ω102). ‚Ä¢ The following m lines describe the missions. Each mission is described by three integers x y q, separated by a space and such that 0 ‚©Ωx < y ‚©Ωn‚àí1 and 1 ‚©Ωq ‚©Ω27. This means that the assigned agent wants to travel from tx to ty and that the mission has priority q. Output: For each test case output a line with one integer k that is the maximum achievable priority, deÔ¨Åned as follows. A priority k is achievable, if there is a set of missions whose priorities sum up to k and such that no more than ‚Ñìagents are on the train between any two consecutive stops.","Casino Royale - solution Connect all the stations with a capacity equal to the maximum number of people allowed in a train and a cost that is the maximum priority. This is necessary to carry on unused flow from one station to another. It's not possible to use $0$ as the cost because, otherwise, it would be better to not do missions. Connect the start and end stations of each mission with a flow of $1$. The cost is the cost shift (maximum priority) multiplied by all the stations skipped, minus the priority of that mission. Considering that the...","Max Flow / Min Cut","#include <iostream>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/push_relabel_max_flow.hpp>
#include <boost/graph/successive_shortest_path_nonnegative_weights.hpp>
#include <boost/graph/find_flow_cost.hpp>

typedef boost::adjacency_list_traits<boost::vecS, boost::vecS, boost::directedS> traits;
typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS, boost::no_property,
    boost::property<boost::edge_capacity_t, long,
        boost::property<boost::edge_residual_capacity_t, long,
            boost::property<boost::edge_reverse_t, traits::edge_descriptor,
                boost::property <boost::edge_weight_t, long>>>>> graph;

typedef traits::vertex_descriptor vertex_desc;
typedef boost::graph_traits<graph>::edge_descriptor edge_desc;

class edge_adder {
  graph &G;

  public:
    explicit edge_adder(graph &G) : G(G) {}

    void add_edge(int from, int to, long capacity, long cost) {
      auto c_map = boost::get(boost::edge_capacity, G);
      auto r_map = boost::get(boost::edge_reverse, G);
      auto w_map = boost::get(boost::edge_weight, G);
      const edge_desc e = boost::add_edge(from, to, G).first;
      const edge_desc rev_e = boost::add_edge(to, from, G).first;
      c_map[e] = capacity;
      c_map[rev_e] = 0;
      r_map[e] = rev_e;
      r_map[rev_e] = e;
      w_map[e] = cost;
      w_map[rev_e] = -cost;
    }
};

typedef struct {
  int from;
  int to;
  int priority;
} mission_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m, l; //n = train stops, m = missions, l = max in train
    std::cin>>n>>m>>l;

    graph G(n);
    edge_adder adder(G);

    const int source = n;
    const int sink = n-1;  //The sink is the last station

    //Connect the source to the first station
    adder.add_edge(source, 0, l, 0);

    int max_priority = 128;

    for(int i = 0; i < n-1; i++){
      //Connect the stations to allow carry on unused capacity
      //The cost cannot be zero otherwise the function would prefer not doing missions
      adder.add_edge(i, i+1, l, max_priority);
    }

    for(int i = 0; i < m; i++){
      int x, y, q;
      std::cin>>x>>y>>q;

      //Doing a mission skips (y-x) stations and collects q points
      adder.add_edge(x, y, 1, (y-x)*max_priority - q);
    }

    //Possible to use after transforming the negative costs
    boost::successive_shortest_path_nonnegative_weights(G, source, sink);

    //The base cost comes from using the empty trains: (n-1) connections, l passengers
    int k = l*(n-1)*max_priority - boost::find_flow_cost(G);

    std::cout<<k<<""\n"";
  }
}
"
"DHL","You have recently been employed by the IT department of DHL. Your first assignment is to help them optimise the parcel collection process in the warehouse. To simplify, we model the problem as follows. There are two stacks of n parcels each, one containing very bulky items (stack A) and the other very heavy items (stack B). The volumes of the parcels on stack A are denoted by integers a1, . . . , an, where ai is the volume of i-th parcel from the bottom. For example, a1 is the volume of the parcel on the bottom of A, and an of the parcel on the top. Similarly, the weights of the parcels on stack B are denoted by integers b1, . . . , bn, again from bottom to top. A machine that manipulates parcels can only access the parcel of the top of each stack. Each time a truck comes to collect parcels, the machine loads a certain number of parcels from both A and B. For example, the machine can load the top two parcels from A (pick up the top one, load it, pick up the next one, load it) and the top three parcels from B. After that the truck leaves and a new one comes. This process is repeated until there are no more parcels left. Due to a malfunction in the software, the machine must load at least one parcel from A and one from B each time, otherwise it breaks and you get fired! In particular, both stacks must become empty in the same round. The cost of one loading is equal to (Sa ‚àíka) ¬∑... Input: The first line of the input contains the number of test cases t ‚©Ω30. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that contains one integer n, denoting the number of parcels on each of the tracks (1 ‚©Ωn ‚©Ω1000). ‚Ä¢ The following line contains n integers a1 . . . an, separated by a space, where ai denotes the volume of i-th parcel in A from the bottom (1 ‚©Ωai ‚©Ω100). ‚Ä¢ The following line contains n integers b1 . . . bn, separated by a space, where bi denotes the weight of i-th parcel in B from the bottom (1 ‚©Ωbi ‚©Ω100). Output: For every test case the corresponding output appears on a separate line. It consists of one integer, the smallest possible sum of costs required to load all parcels without getting fired. 1","DHL - solution Method 1 Keep in mind that this method is not fast enough for the last test case, which, however, is worth only 1 point. To limit the amount of computation to do, it's possible to store, in the array of the piles, the sum of the value that comes from taking all the top $i$ boxes (from the first box on the top to the one considered). This allows to find in $O(1)$ the sum of the values of a subset of boxes with a difference. Create a DP table dp[i][j] that represents the minimum cost when there are i boxes A left and j boxes B...","Dynamic Programming","///3
#include <iostream>
#include <vector>
#include <climits>

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n;  //n = parcels
    std::cin>>n;

    //Values are represented from the bottom, but it's necessary to take from the top
    std::vector<int> values_A(n);
    for(int i = 0; i < n; i++){
      int a;
      std::cin>>a;

      values_A[i] = a;
    }

    std::vector<int> values_B(n);
    for(int i = 0; i < n; i++){
      int b;
      std::cin>>b;

      values_B[i] = b;
    }

    std::vector<std::vector<int>> memo(n+1, std::vector<int>(n+1, INT_MAX));

    memo[0][0] = 0;

    for(int i = 1; i <= n; i++){
      for(int j = 1; j <= n; j++){
        memo[i][j] = std::min(memo[i-1][j], memo[i][j-1]);
        memo[i][j] = std::min(memo[i][j], memo[i-1][j-1]);

        memo[i][j] += (values_A[i-1]-1)*(values_B[j-1]-1);
      }
    }

    std::cout<< memo[n][n] <<""\n"";
  }
}
"
"Fighting Pits of Meeren","Your task is to compute the maximum possible overall excitement, that is the maximum sum of individual excitements over all rounds, one can enforce with a given queue of fighters. 1 Input: The first line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line that consists of three integers n k m, separated by a space. They denote ‚Äì n, the number of fighters standing in the queue (1 ‚©Ωn ‚©Ω5 ¬∑ 103); ‚Äì k, the number of different types of fighters (2 ‚©Ωk ‚©Ω4); ‚Äì m, the number of fighters the audience can remember last being sent through each of the entrances (2 ‚©Ωm ‚©Ω3). ‚Ä¢ The following n lines define the fighters. The i-th such line consists of an integer x, x ‚àà{0, 1, . . . , k ‚àí1}, denoting the type of the i-th fighter in the queue. Output: For each test case output a single line that consists of a single integer denoting the maximum overall excitement one can achieve given the current queue of fighters.","Fighting Pits of Meeren - solution Store the fighters backwards (starting from $n-1$ to $0$) in order to go through the queue in an easier order. Add 1 to each fighter type because 0 should be reserved for ""no fighter"". Create a DP table $n \times 25 \times 25 \times 25$. Given dp[a][b][c][d], a is used to denote the current fighter processed, b encodes the last two fighters coming from the north, c encodes the last two fighters coming from the south, and d denotes the difference in the number of entrances between the north gate and the south...","Dynamic Programming","#include <iostream>
#include <vector>
#include <climits>
#include <set>
#include <cmath>

typedef std::vector<int> VI;
typedef std::vector<VI> VVI;
typedef std::vector<VVI> VVVI;
typedef std::vector<VVVI> VVVVI;

typedef struct {
  int f1;  //Most recent
  int f2;
  int f3;
} fighters_queue_t;

//Num of distinct fighters considering the last m fighters
int num_distinct(fighters_queue_t &q, int m){

    //Very fast way to find how many distinct fighters people remember
    //Remove 1 to not count the absence of a fighter
    if (m == 2){
      return std::set<int>({0, q.f1, q.f2}).size() - 1;
    }else{
      return std::set<int>({0, q.f1, q.f2, q.f3}).size() - 1;
    }
}

int solve(VVVVI &dp, int n, int m, VI &fighters, fighters_queue_t &north, fighters_queue_t &south, int diff){

    if (std::abs(diff) >= 12){  //2^12 = 4096 > 3000, avoid negative excitement
      return INT_MIN;
    }

    if (n == -1){  //No more fighters remaining
      return 0;
    }

    //Encode last two fighters
    int encode_north = 5 * north.f1 + north.f2;
    int encode_south = 5 * south.f1 + south.f2;

    //Difference can be negative
    int shifted_diff = diff + 12;

    if (dp[n][encode_north][encode_south][shifted_diff] != -1){
      return dp[n][encode_north][encode_south][shifted_diff];
    }

    int next_f = fighters[n];

    //Create the two new possible queues of last fighters depending on which entrace is chosen
    fighters_queue_t new_north = {next_f, north.f1, north.f2};
    fighters_queue_t new_south = {next_f, south.f1, south.f2};

    //Excitement in this round
    int exc_if_north = num_distinct(new_north, m)*1000 - int(std::pow(2, std::abs(diff+1)));
    int exc_if_south = num_distinct(new_south, m)*1000 - int(std::pow(2, std::abs(diff-1)));

    //Find best value depending on which entrance is the chosen one
    int best = INT_MIN;
    if (exc_if_north >= 0){  //Excitement in each round must be positive
      best = exc_if_north + solve(dp, n-1, m, fighters, new_north, south, diff+1);
    }

    if (exc_if_south >= 0){
      best = std::max(best, exc_if_south + solve(dp, n-1, m, fighters, north, new_south, diff-1));
    }

    dp[n][encode_north][encode_south][shifted_diff] = best;
    return best;
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, k, m;  //n = fighters, k = types of fighters, m = remember
    std::cin>>n>>k>>m;

    //Store fighters backwards in order to start from index 0 when going through the queue
    VI fighters(n);
    for(int i = n-1; i >= 0; i--){
      int x;
      std::cin>>x;

      //Add 1 to the fighter type to use 0 as ""no fighter""
      fighters[i] = x+1;
    }

    //dp[a][b][c][d] where:
    //* a denotes the current fighter being processed
    //* b encodes the last two fighters coming from the north
    //* c encodes the last two fighters coming from the south
    //* d denotes the difference in entrance between the north and the south
    ////Size choosen for the worst case scenario
    VVVVI dp(n, VVVI(25, VVI(25, VI(25, -1))));

    //It's necessary to consider that there can be 5 different fighters (no fighter + max_k)
    //At maximum the spectators can remember 3 fighters. Considering that the third one is
    //the one newly inserted, it's possible to just store the previous two by encoding them using x*5+y

    //The excitement cannot be negative. Considering that the maximum excitement for a turn can be
    //only 3000 (last 3 * 1000), |p-q| < 12 to have a positive number. For this reason it's possible
    //to store the difference using only 25 cells (with a up-shift for negative numbers)

    //Fighter with value 0 means no fighter
    fighters_queue_t empty = {0, 0, 0};
    std::cout<< solve(dp, n-1, m, fighters, empty, empty, 0) <<""\n"";
  }
}
"
"Schneewittchen","‚ÄúSpieglein, Spieglein, an der Wand, wer ist die Sch√∂nste im ganzen Land?‚Äù ‚ÄúLooking-glass upon the wall, who is fairest of us all?‚Äù Kinder‚Äì und Hausm√§rchen by Jacob Grimm (1785‚Äì1863) and Wilhelm Grimm (1786‚Äì1859) Once upon a time, there was a beautiful princess named Snow-white. But alas, poor Snow-white was in grave danger. The wicked Queen, who was jealous of Snow-white‚Äôs beauty, had a magic mirror that told her where the child was. The Queen set out to kill Snow-white. Fortunately, Snow-white had the seven dwarfs, who were determined to keep her safe. And so, they hatched a plan. They would build a new magic mirror for the Queen, one that would not divulge the whereabouts of Snow-white, and secretly exchange the mirrors the next night. Thus, the Queen would no longer be able to Ô¨Ånd Snow-white, and the child would be safe once more. So they went about to acquire the raw materials for the mirror. Perchance, these could be mined from the nearby mountain. The dwarfs knew this mountain like the back of their hands. There were n mines, one of which was the entry of the mountain. For each mine the dwarfs knew the exact amount of each of the m minerals available there. The mines were connected by railway tracks. Each track connected two mines, and from each mine there was a unique sequence of tracks to reach the entry. To collect the minerals they transported them to the entry using... Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows. ‚Ä¢ It starts with a line containing two integers n m, separated by a space. They denote ‚Äì n, the number of mines (1 ‚©Ωn ‚©Ω103) and ‚Äì m, the number of minerals (1 ‚©Ωm ‚©Ω5). ‚Ä¢ The following n lines describe the mines. The Ô¨Årst line corresponds to the entry. Each line contains m + 1 integers d r0 ... rm‚àí1, separated by a space. They denote d, the danger threshold (‚àí1 ‚©Ωd < 228), and rj, the quantity of mineral j available (0 ‚©Ωrj < 220). If d ‚©æ0, then the corresponding mine is dangerous. In a dangerous mine, no minerals are available (r0 = . . . = rm‚àí1 = 0). You may assume that at most 20 mines are dangerous and that the entry is not. 1 ‚Ä¢ The following n ‚àí1 lines describe the railway tracks. Each line contains two integers u v, separated by a space, indicating a railway track between mine u and mine v (0 ‚©Ωu, v < n). You may assume that v lies on the (unique) path from u to the... Output: For each test case the corresponding output appears on a separate line. If the dwarfs can obtain all the minerals required, the output is the price they had to pay, rounded down to the next integer. Otherwise, the output is Impossible!.","Schneewittchen - solution While reading the input, it's necessary to associate with the _mine index_ (from $0$ to $n-1$) of the dangerous mines a _dangerous mine index_ (from $0$ to $\text{nr\_dangerous\_mines}-1$). This allows later to have variables in the LP problem with a lower identifier. The graph must be constructed backward compared to what is given to allow going down the mines. Firstly, it's necessary to find all the downstream mines, given the entrance or a dangerous mine. A downstream mine of $x$ is a mine that can be reached using...","DFS","#include <iostream>
#include <vector>

#include <boost/graph/adjacency_list.hpp>

#include <CGAL/QP_models.h>
#include <CGAL/QP_functions.h>
#include <CGAL/Gmpq.h>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS> graph;
typedef boost::graph_traits<graph>::out_edge_iterator out_edge_it;

typedef int IT;
typedef CGAL::Gmpz ET;

typedef CGAL::Quadratic_program<IT> Program;
typedef CGAL::Quadratic_program_solution<ET> Solution;

typedef struct{
  int d;  //Dangerous threshold
  std::vector<int> resources;  //Amounts of each type of mineral
} mine_t;

typedef struct{
  int required;
  int supply;
  int price;
} mineral_t;

long floor_to_long(const CGAL::Quotient<ET> &x){
  double a = std::floor(CGAL::to_double(x));
  while (a > x) a -= 1;
  while (a+1 <= x) a += 1;
  return (long)a;
}

//Given a dangerous mine or the entrance, find all the mines downstream until
//the first dangerous mine (that will be included) or the end of the mine in that path

//It's necessary to include also the other dangerous mines firstly encountered in order to
//consider automatically their downstream (after halving)
void find_downstream(int current_mine, int current_dangerous, graph &G, std::vector<std::vector<int>> &mines_downstream, std::vector<mine_t> &mines){

  mines_downstream[current_dangerous].push_back(current_mine);

  //Update the mine whose downstream will be considered
  if(mines[current_mine].d != -1){
    current_dangerous = current_mine;
  }

  out_edge_it out_e, out_eend;
  for(boost::tie(out_e, out_eend) = boost::out_edges(current_mine, G); out_e != out_eend; out_e++){
    find_downstream(boost::target(*out_e, G), current_dangerous, G, mines_downstream, mines);
  }
}

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    int n, m; //n = number of mines, m = different types of minerals
    std::cin>>n>>m;

    std::vector<mine_t> mines(n);

    //If the mine is dangerous, associate its mine index with a dangerous index
    //This allows to have only a few variables in the LP solver
    std::map<int, int> dangerous_index;
    int dangerous_counter = 2;

    for(int i = 0; i < n; i++){
      int d;
      std::cin>>d;
      mines[i].d = d;

      if(d != -1){
        dangerous_index[i] = dangerous_counter++;
      }

      for(int j = 0; j < m; j++){
        int r;
        std::cin>>r;
        mines[i].resources.push_back(r);
      }
    }

    graph G(n);

    for(int i = 0; i < n-1; i++){
      int u, v;
      std::cin>>u>>v;

      boost::add_edge(v, u, G);  //Inverted the mines' order to have railways going away from the entrance
    }

    std::vector<mineral_t> minerals(m);
    for(int i = 0; i < m; i++){
      int c, s, p;
      std::cin>>c>>s>>p;

      minerals[i] = {c, s, p};
    }

    std::vector<std::vector<int>> mines_downstream(n);
    find_downstream(0, 0, G, mines_downstream, mines);

    //There are:
    //- A variable for each dangerous mine (or entrance), for each mineral:
    //--- Each variable contains the amount of that mineral that *goes out* of that dangerous mine
    //--- This means that it may be necessary to multiply it by 2 in order to see what enters the mine
    //--- Variables from the entrance go from 0 to m-1
    //- A variable to represent the bought amount for each mineral (from m to 2m-1)
    Program lp(CGAL::SMALLER, true, 0, false, 0);

    int counter = 0;
    for(int i = 0; i < n; i++){
      if(i == 0 || mines[i].d != -1){  //If the mine is the entrance or dangerous

        for(int j = 0; j < m; j++){  //For each mineral
          int mineral_sum = 0;  //Sum of the current mineral

          //ingoing_materials <= downstream_materials + from_other_dangerous
          for(int k = 0; k < (int) mines_downstream[i].size(); k++){
            int mine_downstream_index = mines_downstream[i][k];

            if(mines[mine_downstream_index].d == -1){  //Sum the minerals downstream from non-dangerous mines
              mineral_sum += mines[mine_downstream_index].resources[j];
            }else{
              lp.set_a(dangerous_index[mine_downstream_index]*m+j, counter, -1);  //Get the resources after halving in downstream dangerous mine
            }
          }

          if(i != 0){
            lp.set_a(dangerous_index[i]*m+j, counter, 2);  //Multiply by 2 because the variable contains the value after halving
          }else{
            lp.set_a(j, counter, 1);  //For the entrance there is no halving
          }
          lp.set_b(counter, mineral_sum);
          counter++;
        }

        if(i != 0){
          //Make sure not to go over the danger threshold
          for(int j = 0; j < m; j++){
            lp.set_a(dangerous_index[i]*m+j, counter, 2);  //Ingoing = 2*outgoing
          }
          lp.set_b(counter, mines[i].d);
          counter++;
        }
      }
    }

    for(int j = 0; j < m; j++){

      lp.set_a(m+j, counter, 1);  //Minerals to purchase
      lp.set_b(counter, minerals[j].supply);
      counter++;

      //purchase + gather >= required
      lp.set_a(m+j, counter, -1);  //Minerals to purchase
      lp.set_a(j, counter, -1);  //Minerals at the entrance
      lp.set_b(counter, -minerals[j].required);
      counter++;

      lp.set_c(m+j, minerals[j].price);  //Minimize the cost
    }

    Solution s = CGAL::solve_linear_program(lp, ET());

    if (s.is_optimal()){
      std::cout<<floor_to_long(s.objective_value())<<std::endl;
    }else{
      std::cout<<""Impossible!""<<std::endl;
    }
  }
}
"
"On Her Majesty's Secret Service","Your task is to compute the minimum advance warning time, such that every agent can enter a shelter before the avalanche launch. To reach a shelter the agents can use slopes and ski lifts. But moving around takes time. Time is also required to enter a shelter, which involves a protocol including a retina scan and voice recognition tests. At every shelter, the entering protocol can be performed by at most one agent at a time. If an agent wants to enter a shelter while another agent is still in protocol there, (s)he has to wait. Finally, the capacity of each shelter is limited. Therefore, careful coordination is required to decide who hides where. . . Input: The Ô¨Årst line of the input contains the number t ‚©Ω30 of test cases. Each of the t test cases is described as follows: ‚Ä¢ It starts with a line that contains six integers n m a s c d, separated by a space. They denote ‚Äì n, the number of relevant positions p0, . . . , pn‚àí1 around Schilthorn (1 ‚©Ωn ‚©Ω103). ‚Äì m, the number of slopes and ski lifts around Schilthorn (0 ‚©Ωm ‚©Ω5 ¬∑ 103). ‚Äì a, the number of secret agents (1 ‚©Ωa ‚©Ω102). ‚Äì s, the number of shelters (1 ‚©Ωs ‚©Ω102). ‚Äì c, the capacity of each shelter (1 ‚©Ωc ‚©Ω2). ‚Äì d, the time (in seconds) an agent needs to perform the entering protocol at a shelter (1 ‚©Ωd ‚©Ω103). ‚Ä¢ The following m lines describe the slopes and ski lifts around Schilthorn. Each line contains four entities w x y z, separated by a space, where w ‚àà{S, L} is a character and x, y, z are integers with 0 ‚©Ωx, y ‚©Ωn‚àí1 and 1 ‚©Ωz ‚©Ω104. If w = S, then the line describes a slope that an agent can use to ski from px to py in z seconds (in this direction only). Otherwise, w = L and the line... Output: For each test case, output a line with one integer t, the minimum number of seconds needed until all agents safely entered a shelter. You may assume that there always exists a way such that all the agents can reach and enter a shelter.","On Her Majesty's Secret Service - solution Firstly, it's necessary to create a weighted directed graph containing all the nodes (including agents and shelters), the slopes, and the lifts, which are represented by two edges in the two directions. For each agent, find how much time it takes for it to reach the different shelters using Dijkstra. If the time is not INT_MAX, that means that the agent cannot reach such a shelter. Create an edge that connects the agent to the shelter that considers both the time needed to reach the shelter and the...","Maximum Matching","#include <iostream>
#include <vector>
#include <climits>
#include <algorithm>

#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/dijkstra_shortest_paths.hpp>
#include <boost/graph/max_cardinality_matching.hpp>

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::undirectedS> un_graph;

typedef boost::adjacency_list<boost::vecS, boost::vecS, boost::directedS,
  boost::no_property, boost::property<boost::edge_weight_t, long>> graph;

typedef boost::property_map<graph, boost::edge_weight_t>::type weight_map;
typedef boost::graph_traits<graph>::edge_descriptor edge_desc;
typedef boost::graph_traits<graph>::vertex_descriptor  vertex_desc;

typedef struct{
  int x;
  int y;
  long dist;
} edge_t;

int main(){
  std::ios_base::sync_with_stdio(false);

  int t;
  std::cin>>t;
  while(t--){
    //n = relevant position, m = slopes and ski lifts, a = agents
    //s = shelters, c = capacity, d = enter time
    int n, m, a, s, c, d;
    std::cin>>n>>m>>a>>s>>c>>d;

    graph G(n);
    weight_map weights = boost::get(boost::edge_weight, G);

    edge_desc e;
    for(int i = 0; i < m; i++){
      char w; int x, y, z;
      std::cin>>w>>x>>y>>z;

      if(w == 'S'){
        e = boost::add_edge(x, y, G).first;
        weights[e] = z;
      }else{
        //With a lift it's possible to go both ways
        e = boost::add_edge(x, y, G).first;
        weights[e] = z;

        e = boost::add_edge(y, x, G).first;
        weights[e] = z;
      }
    }

    std::vector<int> agents(a);
    for(int i = 0; i < a; i++){
      int x;
      std::cin>>x;

      agents[i] = x;
    }

    std::vector<int> shelters(s);
    for(int i = 0; i < s; i++){
      int x;
      std::cin>>x;

      shelters[i] = x;
    }

    //Find all the possible routes from an agent to a shelter
    //Double route and shelter if capacity is 2
    std::vector<edge_t> edges;
    for(int i = 0; i < a; i++){
      std::vector<int> dist_map(n);

      boost::dijkstra_shortest_paths(G, agents[i],
        boost::distance_map(boost::make_iterator_property_map(
          dist_map.begin(), boost::get(boost::vertex_index, G))));

      for(int j = 0; j < s; j++){
        long dist = dist_map[shelters[j]];

        if(dist == INT_MAX){
          continue;
        }

        //It may be possible to add a double link to a shelter if it allows a second agent to reach it in time
        for(int k = 1; k <= c; k++) {
          //agents -> from 0 to a-1
          //shelters -> from a to a+2*s-1
          edges.push_back({i, a + (k-1)*s + j, dist + k*d});
        }
      }
    }

    //Create iteratively a graph with only edges that allows
    //an agent to enter the shelter (movement+password) in less than t
    long low = 0; long high = INT_MAX;
    while(low <= high){
      long mid = (low+high)/2;

      //In the new graph there are a node for each agent, and a node for each shelter
      //It's necessary to multiply the shelters by c to consider also the case when multiple agents use the same shelter
      un_graph best(a+c*s);

      for(edge_t path: edges){
        if(path.dist <= mid){
          boost::add_edge(path.x, path.y, best);
        }
      }

      //Find if all agents can have a shelter
      std::vector<vertex_desc> mate_map(a+c*s);

      //Create a cadinality matching to see if there is at lest a path between an agent and a shelter
      boost::edmonds_maximum_cardinality_matching(best,
        boost::make_iterator_property_map(mate_map.begin(), boost::get(boost::vertex_index, best)));

      int matching_size = boost::matching_size(best,
        boost::make_iterator_property_map(mate_map.begin(), boost::get(boost::vertex_index, best)));

      if(matching_size == a){  //There is a path for each agent
        high = mid-1;
      }else{  //The timing is too strict, it's necessary to increase it
        low = mid+1;
      }
    }

    std::cout<<low<<""\n"";
  }
}
"
