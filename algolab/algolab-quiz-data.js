// Exercise data with real problem descriptions and solutions from AlgoLab 2023
const exercises = [
    {
        name: "Dominoes",
        week: "Week 01",
        methods: "Greedy",
        complexity: "O(n)",
        description: "Given a vector of positive integers representing domino heights, determine how many dominoes will fall starting from the left.",
        solution: "The key idea is to store the data about how many dominoes can be toppled from the current position.",
        cppFile: "dominoes.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Even Pairs",
        week: "Week 01",
        methods: "Combinatorics, Prefix sum",
        complexity: "O(n)",
        description: "Count the number of subarrays with even sum in a vector of integers.",
        solution: "Use prefix sums and combinatorics: count pairs of indices where cumulative sums are both even or both odd using binomial coefficient n*(n-1)/2.",
        cppFile: "even_pairs.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Even Matrices",
        week: "Week 01",
        methods: "Prefix sum, Combinatorics",
        complexity: "O(n^3)",
        description: "Count all submatrices with even sum in a 2D matrix.",
        solution: "Use 2D prefix sums to count submatrices. For each pair of rows, compute prefix sums and count even/odd occurrences.",
        cppFile: "even_matrices.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Build the Sum",
        week: "Week 01",
        methods: "Basic",
        complexity: "O(n)",
        description: "Simple problem to compute sums and verify I/O handling.",
        solution: "Read numbers and compute their sum. Basic warm-up problem.",
        cppFile: "build_the_sum.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Beach Bars",
        week: "Week 02",
        methods: "Sliding Window",
        complexity: "O(n log n)",
        description: "Find the best location for a beach bar that maximizes parasols within distance 100, minimizing the maximum walking distance.",
        solution: "It is a sliding window problem, moving the bar position from one end to the other of the beach while counting the number of parasols and the maximum distance to a parasol inside the current window. It is necessary to save in a vector all the locations with the same best characteristics. The best location has the maximum amount of parasols with the minimum maximum walking distance.",
        cppFile: "beach_bars.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Burning Coins",
        week: "Week 02",
        methods: "Dynamic Programming, Game Theory",
        complexity: "O(n^2)",
        description: "Two players alternately take coins from either end of a line. Maximize your score assuming both play optimally.",
        solution: "Use dynamic programming with game theory. For each subarray, compute the maximum difference the current player can achieve by choosing optimally from either end.",
        cppFile: "burning_coins.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Deck of Cards",
        week: "Week 02",
        methods: "Sliding Window",
        complexity: "O(n)",
        description: "Find the shortest consecutive subsequence of cards with sum exactly equal to k.",
        solution: "Use sliding window with two pointers. Expand window when sum is too small, contract when sum is too large. Track minimum length when sum equals k.",
        cppFile: "deck_of_cards.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "The Great Game",
        week: "Week 02",
        methods: "Dynamic Programming, Game Theory",
        complexity: "O(n * m)",
        description: "Two players move a token on a directed graph. Sherlock wants to minimize moves to reach target, Moriarty wants to maximize. Determine the number of moves.",
        solution: "Use dynamic programming on the graph. For Sherlock's turns, take minimum of successor moves; for Moriarty's turns, take maximum. Both play optimally.",
        cppFile: "the_great_game.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Lord Voldemort",
        week: "Week 02",
        methods: "Binary Search, Greedy",
        complexity: "O(n log n)",
        description: "Place segments of given lengths on a line such that they cover at least m Horcruxes. Minimize the radius of the largest segment.",
        solution: "Binary search on the radius. For each radius, greedily check if we can cover at least m Horcruxes with segments of that size.",
        cppFile: "lord_voldemort.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Buddy Selection",
        week: "Week 03",
        methods: "Maximum Matching, BGL",
        complexity: "O(n^2)",
        description: "Match students into pairs based on common hobbies. Find if a perfect matching exists where each pair shares at least f hobbies.",
        solution: "It is necessary to find new connections with more than f common hobbies. To quickly check how many common hobbies two students have, it's possible to sort the arrays containing the hobbies and then check one by one the strings. If there are enough common hobbies, add an edge. Find maximum matching using Edmond's algorithm. If the matching size is half the number of students, division is not optimal.",
        cppFile: "buddy_selection.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Important Bridges",
        week: "Week 03",
        methods: "BGL, Bridge Finding",
        complexity: "O(V + E)",
        description: "Find all bridges in an undirected graph - edges whose removal disconnects the graph.",
        solution: "Use BGL to find articulation points and bridges. A bridge is an edge that is not part of any cycle.",
        cppFile: "important_bridges.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Ant Challenge",
        week: "Week 03",
        methods: "BGL, Dijkstra",
        complexity: "O((V + E) log V)",
        description: "Find shortest paths for different ant species on a graph, where each species has different edge weights.",
        solution: "Run Dijkstra's algorithm for each ant species with their specific edge weights. Compare paths to determine optimal routes.",
        cppFile: "ant_challenge.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "First steps with BGL",
        week: "Week 03",
        methods: "BGL, Kruskal, Dijkstra",
        complexity: "O((V + E) log V)",
        description: "Introduction to Boost Graph Library - compute shortest paths and minimum spanning trees.",
        solution: "Use BGL's built-in algorithms: Kruskal for MST, Dijkstra for shortest paths. Practice with BGL data structures and algorithms.",
        cppFile: "first_steps_with_bgl.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "James Bond's sovereigns",
        week: "Week 03",
        methods: "BGL, Dijkstra, MST",
        complexity: "O((V + E) log V)",
        description: "Find paths and minimum spanning trees in a weighted graph representing MI6's network.",
        solution: "Combine Dijkstra for shortest paths with Kruskal/Prim for MST. Handle multiple queries efficiently.",
        cppFile: "James_Bonds_sovereigns.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Hit",
        week: "Week 04",
        methods: "CGAL, Geometry",
        complexity: "O(n)",
        description: "Determine if a ray intersects any of n segments in 2D.",
        solution: "Use CGAL's geometric primitives to check ray-segment intersection. Handle edge cases for parallel rays and segments.",
        cppFile: "hit.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "First Hit",
        week: "Week 04",
        methods: "CGAL, Geometry",
        complexity: "O(n log n)",
        description: "Given a ray and n segments, find the first segment that the ray hits.",
        solution: "The key idea is to store the data about how many dominoes can be toppled from the current position.",
        cppFile: "first_hit.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Antenna",
        week: "Week 04",
        methods: "CGAL, Min Circle",
        complexity: "O(n)",
        description: "Find the smallest circle that encloses all given points.",
        solution: "Use CGAL's min_circle_2 algorithm to find the smallest enclosing circle. Handle degenerate cases.",
        cppFile: "antenna.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Hiking Maps",
        week: "Week 04",
        methods: "CGAL, Geometry, Sliding Window",
        complexity: "O(n^2)",
        description: "Find the minimum number of consecutive triangular map pieces that cover a hiking path.",
        solution: "Use CGAL to check if points are inside triangles. Apply sliding window to find minimum consecutive maps covering all path points.",
        cppFile: "hiking_maps.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "The Iron Islands",
        week: "Week 04",
        methods: "CGAL, Delaunay Triangulation",
        complexity: "O(n log n)",
        description: "Connect islands using Delaunay triangulation to minimize maximum edge length in the waterways network.",
        solution: "Build Delaunay triangulation of island positions. Use triangulation edges to construct optimal network connections.",
        cppFile: "the_iron_islands.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Moving Books",
        week: "Week 05",
        methods: "Greedy",
        complexity: "O(n log n)",
        description: "Friends with different strengths move boxes of different weights. Minimize the number of rounds to move all boxes.",
        solution: "Sort friends by strength and boxes by weight in descending order. Greedily assign heaviest possible boxes to strongest available friends in each round.",
        cppFile: "moving_books.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Asterix the Gaul",
        week: "Week 05",
        methods: "Split and List, Binary Search",
        complexity: "O(2^(n/2) * log(2^(n/2)))",
        description: "Find if we can achieve exactly required strength using subset of potion gulps, where moves cost varies.",
        solution: "Use meet-in-the-middle: split potions into two halves, enumerate all subsets of each half, then binary search to find combinations that sum to target.",
        cppFile: "asterix_the_gaul.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Severus Snape",
        week: "Week 05",
        methods: "Dynamic Programming, Prefix Sum",
        complexity: "O(n^2)",
        description: "Combine potions with different properties (power and happiness) to achieve minimum thresholds with minimum number of potions.",
        solution: "Use DP with prefix sums. For each position, track minimum potions needed to achieve power and happiness thresholds.",
        cppFile: "severus_snape.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Boats",
        week: "Week 05",
        methods: "Greedy, Interval Scheduling",
        complexity: "O(n log n)",
        description: "Place boats with given lengths at preferred positions on a river such that they don't overlap. Maximize the number of boats.",
        solution: "Sort boats by position. Greedily place each boat as far left as possible without overlapping previous boats.",
        cppFile: "boats.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Planet Express",
        week: "Week 05",
        methods: "BGL, Dijkstra",
        complexity: "O((V + E) log V)",
        description: "Find shortest path in a graph with teleportation network. Some edges have 0 cost (teleports).",
        solution: "Model as graph with special 0-cost edges for teleports. Use Dijkstra to find shortest path considering teleportation network.",
        cppFile: "planet_express.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Tiles",
        week: "Week 06",
        methods: "Max Flow, Bipartite Matching",
        complexity: "O(V * E^2)",
        description: "Cover a grid with 1x2 tiles. Some cells are blocked. Determine if all free cells can be covered.",
        solution: "For every space, if it's an 'x', skip that space. If the space is even (i+j even), make it a starting position with edge to source capacity 1. Try placing 4 possible tiles connecting to landing spaces. If space is odd, connect to sink capacity 1. Max flow must equal half the number of free spaces.",
        cppFile: "tiles.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "London",
        week: "Week 06",
        methods: "Max Flow",
        complexity: "O(V * E^2)",
        description: "Form a ransom note using letter pairs from newspaper clippings (front and back of paper pieces).",
        solution: "All pairs of letters that newspaper pieces can form are stored in an array of size 26*26. Create max flow graph: source to each pair with capacity = occurrences; each pair connects to its two letters; each letter connects to sink with capacity = required count in note. Note is possible if flow equals number of letters needed.",
        cppFile: "london.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Coin Tossing Tournament",
        week: "Week 06",
        methods: "Max Flow",
        complexity: "O(V * E^2)",
        description: "Verify if a tournament scoreboard is plausible given match results (some known, some unknown).",
        solution: "Create graph for max flow with nodes for rounds and players. Source to each round (capacity 1). From each round, if winner known, edge to that player; if unknown, edges to both players. Each player to sink with capacity = their claimed score. Scoreboard plausible if max flow = number of matches and total score = number of matches.",
        cppFile: "coin_tossing_tournament.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Knights",
        week: "Week 06",
        methods: "Max Flow, Independent Set",
        complexity: "O(V * E^2)",
        description: "Place maximum number of knights on a board with holes such that no two knights attack each other.",
        solution: "Create graph of size n*n. If (i+j) mod 2 == 1, field is landing position; otherwise starting position. Connect source to starting positions, landing positions to sink. For each starting position, connect to valid landing positions. Max flow = max matching = min vertex cover. Maximum independent set = total fields - min vertex cover.",
        cppFile: "knights.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Motorcycles",
        week: "Week 06",
        methods: "CGAL, Geometry",
        complexity: "O(n^2)",
        description: "Motorcycles start at different positions and drive in straight lines at different slopes. Determine which motorcycles never get blocked by others.",
        solution: "Use CGAL to compute ray intersections. For each motorcycle, check if it intersects with others before reaching infinity. Track which motorcycles remain visible.",
        cppFile: "motorcycles.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Bistro",
        week: "Week 07",
        methods: "CGAL, Delaunay Triangulation",
        complexity: "O(n log n)",
        description: "For each new restaurant location, find the distance to the nearest existing restaurant.",
        solution: "Create a triangulation containing the locations of existing restaurants. For each new restaurant location, determine the nearest point in the triangulation and find the squared distance to that point.",
        cppFile: "bistro.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Germs",
        week: "Week 07",
        methods: "CGAL, Delaunay Triangulation",
        complexity: "O(n log n)",
        description: "Bacteria colonies grow at constant rate. Determine when first collision occurs (with dish border or other colony).",
        solution: "Calculate time at which each germ dies: Try all dish borders (distance between germ and border). Try all close pairs defined by triangulation edges (squared distance / 4). Order all minimum squared death radii. Calculate times using t = sqrt(sqrt(r^2) - 0.5). Return first, median, and last times.",
        cppFile: "germs.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "H1N1",
        week: "Week 07",
        methods: "CGAL, Delaunay Triangulation, Widest Path",
        complexity: "O(n log n)",
        description: "People need to escape from infected persons. Find safe routes maintaining maximum distance from infected locations.",
        solution: "From a face, find way out by traversing edges whose length is adequate (widest path problem). For each face, store maximum radius allowing escape route. Initialize infinite faces with infinite width, finite faces with 0. Use modified Dijkstra with priority queue to populate widest paths. For each user, check if face's widest path is wide enough.",
        cppFile: "h1n1.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "GoldenEye",
        week: "Week 07",
        methods: "CGAL, Delaunay Triangulation, Disjoint Sets",
        complexity: "O(n log n)",
        description: "Jammers create circular interference zones. Find minimum power needed to complete missions between two points avoiding jammer coverage.",
        solution: "Create triangulation with jammer positions. Find which missions can be done with power p by checking connected components of safe graph. To find minimum power for all missions, order edges by length and use disjoint sets. For each mission, update minimum power to allow start/end positions under jammers (power = 4 * d^2), then connect components.",
        cppFile: "goldeneye.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Octopussy",
        week: "Week 07",
        methods: "Greedy, Binary Heap",
        complexity: "O(n log n)",
        description: "Bombs arranged in binary tree structure. Each bomb has explosion time. Can defuse one bomb per second. Determine if all bombs can be defused.",
        solution: "Each bomb stores ordered vector of bombs to defuse before current one (union of vectors from left and right children). Order returned vector (defuse bombs that explode sooner first). For each bomb in order, defuse recursively. If not enough time, set explosion flag. Alternative: for bombs on top of others, set defusal time to min of below bomb's time and above bomb's time minus 1.",
        cppFile: "octopussy.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Inball",
        week: "Week 08",
        methods: "Linear Programming, CGAL",
        complexity: "O(n * d)",
        description: "Find the largest ball that fits inside a d-dimensional polytope defined by linear inequalities.",
        solution: "Distance of center point x to a plane is D = |a1*x1 + ... + ad*xd - b| / sqrt(a1^2 + ... + ad^2). Since a1*x1 + ... + ad*xd <= b, numerator is always negative, multiply by -1. Transform to inequality: sqrt(a1^2 + ... + ad^2) * D <= -a1*x1 - ... - ad*xd + b. D cannot be negative, set lower bound to 0. Maximize D (minimize -D).",
        cppFile: "inball.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Kingdom Defence",
        week: "Week 08",
        methods: "Max Flow, Min-Cost Max-Flow",
        complexity: "O(V * E^2)",
        description: "Distribute soldiers among locations with supply/demand constraints and path capacity constraints (both min and max).",
        solution: "Given soldiers present and needed at location, find demand and supply. Each path has capacity = max_capacity - min_capacity. Source location has demand increase = min_capacity. Destination has supply increase = min_capacity. Locations with positive supply connect to source, negative supply (demand) connect to sink. Check if flow equals total demand.",
        cppFile: "kingdom_defence.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Diet",
        week: "Week 08",
        methods: "Linear Programming",
        complexity: "O(n * m)",
        description: "Choose quantities of foods to meet nutritional constraints (min/max for each nutrient) while minimizing cost.",
        solution: "For each nutrient, two inequalities: q1*c_i,1 + ... + qj*c_i,j <= max_i and -q1*c_i,1 - ... - qj*c_i,j <= -min_i (multiply by -1 to standardize direction). Objective function minimizes q1*p1 + ... + qj*pj where pj is price of food j.",
        cppFile: "diet.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Suez",
        week: "Week 08",
        methods: "Linear Programming, CGAL",
        complexity: "O(n^2)",
        description: "Place rectangular posters of variable size on a wall without overlapping existing posters or each other.",
        solution: "Input values are fractions, use CGAL::Gmpq. For new poster constraints: a1+a2 <= max(2*|x2-x1|/w, 2*|y2-y1|/h). For new-old poster constraints: a1 <= max(2*|x2-x1|-w)/w, (2*|y2-y1|-h)/h) taking minimum across all old posters. Minimize (a1-a2-...-an) * (-2*(h+w)).",
        cppFile: "suez.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "What is the Maximum",
        week: "Week 08",
        methods: "Linear Programming",
        complexity: "O(n)",
        description: "Simple LP maximization problem to verify LP solver setup.",
        solution: "Solver always minimizes objective function. Invert all signs in objective function to maximize, then invert sign of result to get correct answer.",
        cppFile: "what_is_the_maximum.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab"
    },
    {
        name: "Clues",
        week: "Week 10",
        methods: "CGAL, Delaunay Triangulation, BFS, Graph Coloring",
        complexity: "O(n log n)",
        description: "Radio stations must use different frequencies if within range r. Two Sherlock locations must be connectable without interference.",
        solution: "Create triangulation of stations with vertex indices. Save edges with length < r. Using BFS, color nodes with alternating frequencies if possible. Check for interference within same frequency using separate triangulations. If two mission points are close enough and on same connected component without interference, answer is 'y'.",
        cppFile: "clues.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Graph Coloring + Triangulation",
        keyInsight: "Bipartite graph coloring for frequency assignment, triangulation for interference checking"
    },
    {
        name: "Lannister",
        week: "Week 10",
        methods: "Linear Programming, CGAL",
        complexity: "O(n)",
        description: "Build perpendicular water and sewage canals separating nobles and commons, minimizing total pipe length.",
        solution: "Water canal non-vertical (bw=1), sewage non-horizontal (as=1). Place nobles left of sewage (as*xn+bs*yn+cs<=0), commons right (-as*xc-bs*yc-cs<=0). Set as=1. Check feasibility. For sewage pipes, sum lengths considering direction. For water pipes, minimize L where L>=|yh+aw*xh+cw| using L>=t and L>=-t. Ensure perpendicularity: bs+aw=0.",
        cppFile: "lannister.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Linear Programming with Geometric Constraints",
        keyInsight: "Model perpendicular lines and minimize total distance using LP"
    },
    {
        name: "From Russia with Love",
        week: "Week 03 PotW",
        methods: "Dynamic Programming, Game Theory",
        complexity: "O(n^2)",
        description: "Multiple players take coins from either end of a line. You go on specific turns. Maximize your score assuming others minimize your gains.",
        solution: "This is an upgraded Burning Coins problem with multiple players. Use 2D DP table where dp[i][j] = best result for coins i to j. Differentiate between your turns (maximize) and others' turns (they minimize your gains). Use modulo to track whose turn it is, or use boolean array to mark player turns.",
        cppFile: "from_russia_with_love.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Multi-player Game Theory DP",
        keyInsight: "Distinguish between maximizing your gains and others minimizing them"
    },
    {
        name: "Defensive Line",
        week: "Week 04 PotW",
        methods: "Dynamic Programming, Two Pointers",
        complexity: "O(n * m)",
        description: "Match m attackers to continuous non-overlapping subsequences of n defenders, where each subsequence sums to exactly k.",
        solution: "First use two pointers to find all valid subsequences (continuous defenders summing to k). Create array marking where valid subsequences end. Then use DP: dp[i][j] = max attackers using first j defenders with i subsequences. If subsequence ends at j, consider dp[i-1][j-length] + 1.",
        cppFile: "defensive_line.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Two Pointers + DP Combination",
        keyInsight: "Find valid subsequences first, then DP to select non-overlapping ones"
    },
    {
        name: "Shopping Trip",
        week: "Week 06",
        methods: "Max Flow",
        complexity: "O(V * E^2)",
        description: "Multiple friends want to buy different items from stores. Each friend-store-item combination has constraints. Find if all items can be purchased.",
        solution: "Model as max flow problem. Create nodes for friends, stores, and items. Source connects to friends (capacity = items they can carry). Friends connect to stores they can visit. Stores connect to items they sell. Items connect to sink (capacity = quantity needed). Check if max flow equals total items needed.",
        cppFile: "shopping_trip.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Max Flow with Multiple Layers",
        keyInsight: "Multi-layer flow network: friends → stores → items"
    },
    {
        name: "Tracking",
        week: "Week 06 PotW",
        methods: "Dijkstra, BFS, Graph",
        complexity: "O((V + E) log V)",
        description: "Track a person's movement through a river network. Given partial observations, find possible paths and timing.",
        solution: "Build graph of river segments. Use Dijkstra or BFS to find shortest paths between observation points. Track timing constraints to determine feasible paths. Consider current speeds and river flow directions.",
        cppFile: "tracking.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Constrained Path Finding",
        keyInsight: "Combine shortest paths with timing constraints"
    },
    {
        name: "Radiation",
        week: "Week 07",
        methods: "Delaunay Triangulation, Binary Search",
        complexity: "O(n log n)",
        description: "Place radiation sensors to detect all threats. Find minimum power needed to cover all critical points.",
        solution: "Use Delaunay triangulation to find nearest neighbor relationships. Binary search on power level. For each power, check if all points are covered using triangulation edges. Balance between local coverage and global connectivity.",
        cppFile: "radiation.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Geometric Coverage + Binary Search",
        keyInsight: "Triangulation for proximity, binary search for optimal power"
    },
    {
        name: "Attack of the Clones",
        week: "Week 05",
        methods: "Greedy, Interval Scheduling",
        complexity: "O(n log n)",
        description: "Circular timeline with segments. Select maximum non-overlapping segments on a circle.",
        solution: "Convert circular problem to linear by duplicating timeline. Sort segments by end time. Greedily select non-overlapping segments, considering wrap-around on the circle. Try different starting points to find maximum.",
        cppFile: "attack_of_the_clones.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Circular Interval Scheduling",
        keyInsight: "Handle circular nature by considering all starting points"
    },
    {
        name: "Asterix in Switzerland",
        week: "Week 10",
        methods: "Min-Cost Max-Flow, Cycle Canceling",
        complexity: "O(V * E^2 * log V)",
        description: "Optimize debt settlement in a network. Find minimum cost flow that balances all debts.",
        solution: "Model as min-cost max-flow. Create nodes for debtors and creditors. Source connects to debtors with debt amount. Creditors connect to sink with credit amount. Use cycle canceling algorithm to find minimum cost flow that settles all debts.",
        cppFile: "asterix_in_switzerland.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Min-Cost Max-Flow",
        keyInsight: "Debt settlement = min-cost flow problem"
    },
    {
        name: "Hand",
        week: "Week 11",
        methods: "Greedy, Sorting",
        complexity: "O(n log n)",
        description: "Card game where you play cards optimally to maximize score. Cards have values and constraints.",
        solution: "Sort cards by value or constraints. Greedily select cards that maximize score while respecting game rules. Consider both immediate value and future possibilities.",
        cppFile: "hand.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Greedy Card Game Optimization",
        keyInsight: "Sort by strategic value, not just card value"
    },
    {
        name: "Lestrade",
        week: "Week 11",
        methods: "BFS, Graph, Dynamic Programming",
        complexity: "O(V + E)",
        description: "Detective needs to visit crime scenes in specific order. Find optimal path through city graph.",
        solution: "Model as graph traversal with ordering constraints. Use BFS to find shortest paths between required locations. DP to determine optimal visiting order considering distance and timing constraints.",
        cppFile: "lestrade.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Constrained Graph Traversal",
        keyInsight: "BFS + DP for ordered locations"
    },
    {
        name: "Fleetrace",
        week: "Week 11 PotW",
        methods: "Min-Cost Max-Flow, Linear Programming",
        complexity: "O(V * E^2)",
        description: "Optimize boat race strategy. Assign boats to races minimizing cost while maximizing wins.",
        solution: "Model as min-cost max-flow or linear programming. Create network for boat-race assignments. Minimize cost while ensuring flow constraints represent race requirements. Alternative: LP formulation with assignment variables.",
        cppFile: "fleetrace.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Assignment Problem (Min-Cost Flow or LP)",
        keyInsight: "Multiple solution approaches: flow networks or LP"
    },
    {
        name: "Car Sharing",
        week: "Week 12",
        methods: "Min-Cost Max-Flow",
        complexity: "O(V * E^2)",
        description: "Optimize car-sharing bookings. Maximize revenue while satisfying time and location constraints.",
        solution: "Model as min-cost max-flow with time-expanded network. Nodes represent car-time-location states. Edges represent trips (with revenue as negative cost) and waiting. Source provides cars, sink collects cars at end.",
        cppFile: "car_sharing.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Time-Expanded Network Flow",
        keyInsight: "Expand graph in time dimension for temporal constraints"
    },
    {
        name: "Hong Kong",
        week: "Week 12",
        methods: "Sliding Window, Dynamic Programming",
        complexity: "O(n * k)",
        description: "Optimize trading strategy over time. Buy and sell with limited transactions and timing constraints.",
        solution: "Use dynamic programming to track best profit with k transactions. Sliding window to consider optimal buy/sell times. State: dp[day][transactions_used] = max profit. Transition: buy, sell, or hold.",
        cppFile: "hong_kong.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "DP Trading Problem",
        keyInsight: "Track transactions remaining as DP state"
    },
    {
        name: "Marathon",
        week: "Week 13",
        methods: "Max Flow, Graph Splitting",
        complexity: "O(V * E^2)",
        description: "Marathon runners on graph. Ensure no congestion at nodes. Find if all runners can complete race.",
        solution: "Split each node into in-node and out-node connected by edge with capacity. This enforces node capacity constraints. Runners flow from starts to finishes. Check if max flow equals number of runners.",
        cppFile: "marathon.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Max Flow with Node Capacities",
        keyInsight: "Split nodes to enforce capacity constraints"
    },
    {
        name: "Evolution",
        week: "Week 13",
        methods: "Dynamic Programming, Tree",
        complexity: "O(n^2)",
        description: "Evolution tree where species evolve. Find optimal evolution path maximizing fitness.",
        solution: "DP on tree structure. For each node, compute best evolution path from root. Consider age constraints and fitness values. State: dp[node] = best fitness ending at this species.",
        cppFile: "evolution.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Tree DP",
        keyInsight: "DP on tree with ancestor-descendant constraints"
    },
    {
        name: "Punch",
        week: "Week 13",
        methods: "Greedy, Geometry",
        complexity: "O(n log n)",
        description: "Punch through walls at optimal angles. Minimize effort while reaching target.",
        solution: "Model walls as geometric objects. Use greedy approach to select optimal punch angles. Consider ray-geometry intersections to find minimum effort path through obstacles.",
        cppFile: "punch.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Computational Geometry + Greedy",
        keyInsight: "Geometric ray casting with optimization"
    },
    {
        name: "Sith",
        week: "Week 13",
        methods: "Dynamic Programming, Bitmask",
        complexity: "O(n * 2^n)",
        description: "Choose Sith lords optimally. Each choice affects future options. Maximize power.",
        solution: "Use bitmask DP to track chosen Sith. State: dp[mask] = max power with this subset chosen. Transition: try adding each unchosen Sith considering conflicts and bonuses.",
        cppFile: "sith.cpp",
        officialLink: "https://codeexpert.ethz.ch/algolab",
        problemType: "Bitmask DP",
        keyInsight: "Track subset of chosen elements with bitmask"
    }
];
