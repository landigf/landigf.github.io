<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algolab Problem Map</title>
  <style>
    :root {
      --bg: #000000;
      --panel: #0a0a0a;
      --card: #1a1a1a;
      --accent: #ffffff;
      --accent-soft: #f5f5f7;
      --text-main: #f5f5f7;
      --text-secondary: #86868b;
      --text-muted: #6e6e73;
      --tag-bg: #1d1d1f;
      --border: #2c2c2e;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text",
        "Helvetica Neue", Helvetica, Arial, sans-serif;
      background: #000000;
      color: var(--text-main);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    #app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 24px 32px;
      border-bottom: 1px solid var(--border);
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 2rem;
      font-weight: 600;
      letter-spacing: -0.02em;
      color: var(--text-main);
    }

    header p {
      margin: 8px 0 0;
      font-size: 1rem;
      color: var(--text-secondary);
      font-weight: 400;
    }

    .header-actions {
      display: flex;
      gap: 12px;
      margin-top: 16px;
      flex-wrap: wrap;
    }

    .quiz-btn {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      padding: 12px 28px;
      border-radius: 10px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .quiz-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
    }

    .stats-summary {
      display: flex;
      gap: 20px;
      padding: 12px 20px;
      background: var(--card);
      border-radius: 10px;
      border: 1px solid var(--border);
      align-items: center;
    }

    .stat-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9rem;
    }

    .stat-value {
      font-weight: 600;
      color: var(--accent);
    }

    main.layout {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .tree-panel {
      width: 32%;
      min-width: 280px;
      max-width: 440px;
      border-right: 1px solid var(--border);
      background: var(--panel);
      padding: 24px;
      overflow-y: auto;
    }

    .list-panel {
      flex: 1;
      padding: 24px 32px;
      overflow-y: auto;
      background: var(--bg);
    }

    .tree-panel h2,
    .list-panel h2 {
      margin: 0 0 16px;
      font-size: 1.1rem;
      letter-spacing: -0.01em;
      font-weight: 600;
      color: var(--text-main);
    }

    .tree-description {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 20px;
      line-height: 1.5;
    }

    /* Tree nodes */

    #tree {
      margin-top: 8px;
    }

    .tree-node {
      position: relative;
      margin: 8px 0;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: 12px;
      background: var(--card);
      border: 1px solid var(--border);
    }

    .tree-node-inner {
      border-radius: 12px;
      padding: 12px 16px;
      background: transparent;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .tree-node .node-title {
      font-size: 0.95rem;
      font-weight: 500;
      color: var(--text-main);
    }

    .tree-node .node-subtitle {
      font-size: 0.85rem;
      color: var(--text-secondary);
      font-weight: 400;
    }

    .tree-node .node-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .tree-node:hover {
      background: var(--tag-bg);
      border-color: #3a3a3c;
      transform: translateX(2px);
    }

    .tree-node.selected {
      background: var(--accent);
      border-color: var(--accent);
      transform: translateX(2px);
    }

    .tree-node.selected .node-title,
    .tree-node.selected .node-subtitle,
    .tree-node.selected .node-meta {
      color: #000;
    }

    .tree-node::before {
      content: "";
      position: absolute;
      left: -14px;
      top: 50%;
      width: 10px;
      height: 1px;
      background: var(--border);
      opacity: 0.5;
    }

    .tree-node.depth-0::before {
      display: none;
    }

    /* Filters */

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 24px;
      align-items: center;
    }

    .filters input[type="search"] {
      flex: 1 1 220px;
      padding: 10px 16px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text-main);
      font-size: 0.95rem;
      outline: none;
      transition: all 0.2s;
    }

    .filters input[type="search"]:focus {
      border-color: var(--text-secondary);
      background: var(--panel);
    }

    .filters select {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text-main);
      font-size: 0.9rem;
      outline: none;
      cursor: pointer;
      transition: all 0.2s;
    }

    .filters select:hover {
      border-color: var(--text-secondary);
    }

    .tech-filter-label {
      font-size: 0.8rem;
      color: var(--text-secondary);
      width: 100%;
      margin-top: 8px;
    }

    .global-flip-btn {
      padding: 10px 20px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text-main);
      font-size: 0.9rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      margin-left: auto;
    }

    .global-flip-btn:hover {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    .global-flip-btn.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    #tech-filter {
      width: 100%;
      max-height: 100px;
      overflow-y: auto;
      margin-top: 8px;
      border-radius: 10px;
      padding: 8px;
      background: var(--panel);
      border: 1px solid var(--border);
    }

    #tech-filter label {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--text-main);
      margin: 4px 6px 4px 0;
      padding: 6px 12px;
      border-radius: 8px;
      background: var(--card);
      cursor: pointer;
      transition: all 0.2s;
      border: 1px solid var(--border);
    }

    #tech-filter label:hover {
      background: var(--tag-bg);
    }

    #tech-filter input[type="checkbox"] {
      accent-color: var(--accent);
      cursor: pointer;
      width: 16px;
      height: 16px;
    }

    /* Problem list */

    #problem-list {
      margin-top: 8px;
    }

    .problem-card {
      background: var(--card);
      border-radius: 16px;
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--border);
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .problem-card:hover {
      border-color: var(--text-secondary);
      transform: translateY(-2px);
    }

    .problem-header {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      align-items: flex-start;
    }

    .problem-title {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text-main);
      letter-spacing: -0.01em;
    }

    .problem-model {
      margin-top: 4px;
      font-size: 0.9rem;
      color: var(--text-secondary);
      font-weight: 400;
    }

    .problem-meta {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-top: 8px;
    }

    .tag-row {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .tag {
      font-size: 0.8rem;
      padding: 4px 10px;
      border-radius: 6px;
      background: var(--tag-bg);
      color: var(--text-main);
      white-space: nowrap;
      border: 1px solid var(--border);
    }

    .tag-week {
      background: #1a1a1a;
      border-color: #2c2c2e;
    }

    .tag-size {
      background: #1a1a1a;
      border-color: #2c2c2e;
    }

    .tag-complexity {
      background: #1a1a1a;
      border-color: #2c2c2e;
    }

    .problem-links {
      margin-top: 10px;
      font-size: 0.85rem;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .problem-links a {
      color: var(--text-main);
      text-decoration: none;
      transition: opacity 0.2s;
    }

    .problem-links a:hover {
      opacity: 0.7;
    }

    .notes {
      margin-top: 12px;
      font-size: 0.85rem;
    }

    .notes textarea {
      width: 100%;
      min-height: 70px;
      max-height: 200px;
      border-radius: 10px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      background: var(--panel);
      color: var(--text-main);
      font-size: 0.85rem;
      resize: vertical;
      font-family: inherit;
      transition: all 0.2s;
    }

    .notes textarea:focus {
      outline: none;
      border-color: var(--text-secondary);
    }

    .empty-state {
      margin-top: 16px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    @media (max-width: 900px) {
      main.layout {
        flex-direction: column;
      }
      .tree-panel {
        width: 100%;
        max-width: none;
        border-right: none;
        border-bottom: 1px solid var(--border);
      }
    }

    /* Tab Navigation Styles */
    .tab-navigation {
      display: flex;
      gap: 12px;
      margin-top: 24px;
      border-top: 1px solid var(--border);
      padding-top: 20px;
    }

    .tab-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 12px 24px;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 10px;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
    }

    .tab-btn:hover {
      background: var(--card);
      border-color: var(--text-secondary);
    }

    .tab-btn.active {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: flex;
    }

    /* Graph View Styles */
    #graph-view {
      flex-direction: column;
      padding: 32px;
      min-height: calc(100vh - 200px);
      background: var(--bg);
    }

    #graph-container {
      flex: 1;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 16px;
      position: relative;
      overflow: hidden;
      min-height: 700px;
    }

    #graph-canvas {
      width: 100%;
      height: 100%;
      cursor: grab;
    }

    #graph-canvas:active {
      cursor: grabbing;
    }

    .graph-legend {
      display: flex;
      gap: 24px;
      padding: 20px;
      background: var(--card);
      border-radius: 12px;
      margin-bottom: 20px;
      flex-wrap: wrap;
      border: 1px solid var(--border);
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.95rem;
      color: var(--text-main);
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }

    .graph-controls {
      position: absolute;
      top: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .graph-control-btn {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text-main);
      width: 44px;
      height: 44px;
      border-radius: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 1.2rem;
      font-weight: 500;
    }

    .graph-control-btn:hover {
      background: var(--accent);
      color: #000;
      border-color: var(--accent);
      transform: scale(1.05);
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Algolab Problem Map</h1>
      <p>
        Pattern-match problems to techniques. Use global flip to switch between story names and underlying models.
      </p>
      
      <!-- Header Actions -->
      <div class="header-actions">
        <a href="algolab-quiz.html" class="quiz-btn">
          üéØ Start Practice Quiz
        </a>
        <div class="stats-summary" id="exercise-stats">
          <div class="stat-item">
            <span>üìù</span>
            <span><span class="stat-value" id="total-exercises">24</span> exercises</span>
          </div>
          <div class="stat-item">
            <span>‚úÖ</span>
            <span><span class="stat-value" id="completed-exercises">0</span> mastered</span>
          </div>
          <div class="stat-item">
            <span>üî•</span>
            <span><span class="stat-value" id="quiz-streak">0</span> streak</span>
          </div>
        </div>
      </div>
      
      <!-- Tab Navigation -->
      <div class="tab-navigation">
        <button class="tab-btn active" data-tab="list-view">
          üìã List View
        </button>
        <button class="tab-btn" data-tab="graph-view">
          üó∫Ô∏è Graph View
        </button>
      </div>
    </header>

    <!-- List View Tab (Current Implementation) -->
    <main class="layout tab-content active" id="list-view">
      <section class="tree-panel">
        <h2>Technique map</h2>
        <div class="tree-description">
          Rough decision tree: start from the top, follow what the input &amp; constraints suggest
          (arrays, intervals, graphs, flows, geometry, DP, ‚Ä¶).
        </div>
        <div id="tree"></div>
      </section>

      <section class="list-panel">
        <h2>Problems</h2>
        <div class="filters">
          <input
            type="search"
            id="search-input"
            placeholder="Search by story name or model (e.g. 'interval scheduling')"
          />
          <select id="week-filter"></select>
          <select id="size-filter"></select>
          <button class="global-flip-btn" id="global-flip">
            Show Models
          </button>
          <div class="tech-filter-label">
            Extra technique filters (ANDed with node):
          </div>
          <div id="tech-filter"></div>
        </div>

        <div id="problem-list"></div>
      </section>
    </main>

    <!-- Graph View Tab (New) -->
    <main class="tab-content" id="graph-view">
      <div class="graph-legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #ffffff;"></div>
          <span>Technique Categories</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #86868b;"></div>
          <span>Sub-Techniques</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #f5f5f7; border: 1px solid #2c2c2e;"></div>
          <span>Problems</span>
        </div>
      </div>
      <div id="graph-container">
        <svg id="graph-canvas"></svg>
        <div class="graph-controls">
          <button class="graph-control-btn" id="zoom-in" title="Zoom In">+</button>
          <button class="graph-control-btn" id="zoom-out" title="Zoom Out">‚àí</button>
          <button class="graph-control-btn" id="reset-view" title="Reset View">‚ü≤</button>
        </div>
      </div>
    </main>
  </div>

  <script>
    // === 1. Tags / enums ====================================================

    const TECHNIQUE_TAGS = [
      "brute force",
      "greedy",
      "split & list",
      "backtracking",
      "dp",
      "sliding window",
      "two pointers",
      "binary search",
      "intervals",
      "priority queue",
      "graph components",
      "mst",
      "bfs",
      "dfs",
      "shortest path",
      "maximum matching",
      "network flows",
      "min-cost flows",
      "delaunay triangulation",
      "minimum enclosing circle",
      "linear programming",
      "geometry"
    ];

    const SIZE_OPTIONS = [
      { value: "all", label: "Any input size" },
      { value: "tiny", label: "Up to ~10¬≥" },
      { value: "small", label: "Up to ~10‚Å¥" },
      { value: "medium", label: "Up to ~10‚Åµ" },
      { value: "large", label: "Up to ~10‚Å∂ or more" }
    ];

    // === 2. Problem data =====================================================

    // Fill / extend this with all Algolab problems.
    // Keep tags in lower case to match TECHNIQUE_TAGS.
    const PROBLEMS = [
      {
        id: "deck-of-cards",
        storyTitle: "Deck of Cards (simplified)",
        modelTitle: "Sliding window for subarray with sum exactly k",
        week: 2,
        methods: ["sliding window", "two pointers"],
        sizeBand: "medium",
        inputHint: "n up to 10^5, non-negative values",
        complexity: "O(n)",
        link: "", // put Code Expert link here
        video: "",
        pdf: ""
      },
      {
        id: "lord-voldemort",
        storyTitle: "Lord Voldemort",
        modelTitle:
          "Weighted interval scheduling with cardinality constraint",
        week: 5,
        methods: ["dp", "intervals", "binary search", "greedy"],
        sizeBand: "medium",
        inputHint: "n up to 2¬∑10^5, k small (e.g. ‚â§ 10)",
        complexity: "O(n log n ¬∑ k)",
        link: "https://expert.ethz.ch/ide2/67fF4wzx4jHAsyArS", // put Code Expert link here
        video: "",
        pdf: ""
      },
      {
        id: "clues",
        storyTitle: "Clues",
        modelTitle:
          "Delaunay triangulation + graph components / 2-coloring",
        week: 7,
        methods: ["geometry", "delaunay triangulation", "graph components", "bfs"],
        sizeBand: "large",
        inputHint: "n, m up to 9¬∑10^4, coordinates up to 2^24",
        complexity: "O((n + m) log n)",
        link: "",
        video: "",
        pdf: ""
      }
    ];

    // === 3. Technique tree ===================================================

    const NODES = [
      {
        id: "root",
        label: "All Algolab problems",
        subtitle: "No restriction, just all stories",
        techniques: [],
        parent: null
      },
      {
        id: "arrays-basic",
        label: "Arrays / prefix sums",
        subtitle: "Brute force ‚Üí prefix sums ‚Üí two pointers",
        techniques: ["brute force"],
        parent: "root"
      },
      {
        id: "sliding-window",
        label: "Sliding window",
        subtitle: "Two pointers on contiguous subarrays",
        techniques: ["sliding window"],
        parent: "arrays-basic"
      },
      {
        id: "greedy",
        label: "Greedy",
        subtitle: "Sort + local choices",
        techniques: ["greedy"],
        parent: "root"
      },
      {
        id: "intervals",
        label: "Intervals & scheduling",
        subtitle: "Sorting endpoints, sweepline, DP",
        techniques: ["intervals"],
        parent: "greedy"
      },
      {
        id: "dp",
        label: "Dynamic programming",
        subtitle: "States, transitions, objective",
        techniques: ["dp"],
        parent: "root"
      },
      {
        id: "dp-intervals",
        label: "DP + intervals",
        subtitle: "Weighted interval scheduling & friends",
        techniques: ["dp", "intervals"],
        parent: "dp"
      },
      {
        id: "graphs",
        label: "Graphs",
        subtitle: "Components, BFS/DFS, MST, etc.",
        techniques: ["graph components"],
        parent: "root"
      },
      {
        id: "shortest-path",
        label: "Shortest paths",
        subtitle: "Dijkstra & variants",
        techniques: ["shortest path"],
        parent: "graphs"
      },
      {
        id: "flows",
        label: "Flows / matchings",
        subtitle: "Max flow, min cut, matchings",
        techniques: ["network flows"],
        parent: "graphs"
      },
      {
        id: "geometry",
        label: "Geometry / CGAL",
        subtitle: "Delaunay, MEC, LP on steroids",
        techniques: ["geometry"],
        parent: "root"
      }
    ];

    const NODE_MAP = {};
    NODES.forEach((n) => (NODE_MAP[n.id] = n));
    NODES.forEach((n) => (n.children = []));
    NODES.forEach((n) => {
      if (n.parent) NODE_MAP[n.parent].children.push(n.id);
    });

    let selectedNodeId = "root";

    const filters = {
      search: "",
      week: "all",
      size: "all",
      techniques: new Set()
    };

    // === 4. Helpers ==========================================================

    function prettyTag(tag) {
      if (tag === "dp") return "DP";
      if (tag === "mst") return "MST";
      if (tag === "bfs") return "BFS";
      if (tag === "dfs") return "DFS";
      if (tag === "shortest path") return "Shortest path (Dijkstra)";
      if (tag === "min-cost flows") return "Min-cost flows";
      return tag
        .split(" ")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function getDepth(node) {
      let d = 0;
      let cur = node;
      while (cur.parent) {
        d++;
        cur = NODE_MAP[cur.parent];
      }
      return d;
    }

    function problemMatchesNode(problem, node) {
      if (!node.techniques || node.techniques.length === 0) return true;
      // Node means: problem must contain all these technique tags
      return node.techniques.every((t) => problem.methods.includes(t));
    }

    function problemMatchesFilters(problem) {
      if (filters.week !== "all" && problem.week !== Number(filters.week)) {
        return false;
      }
      if (filters.size !== "all" && problem.sizeBand !== filters.size) {
        return false;
      }
      if (filters.techniques.size) {
        for (const t of filters.techniques) {
          if (!problem.methods.includes(t)) return false;
        }
      }
      if (filters.search) {
        const hay = (
          problem.storyTitle +
          " " +
          problem.modelTitle
        ).toLowerCase();
        if (!hay.includes(filters.search)) return false;
      }
      return true;
    }

    function getFilteredProblems() {
      const node = NODE_MAP[selectedNodeId];
      return PROBLEMS.filter(
        (p) => problemMatchesNode(p, node) && problemMatchesFilters(p)
      );
    }

    function selectNode(id) {
      selectedNodeId = id;
      renderTree();
      renderProblemList();
    }

    // === 5. Rendering ========================================================

    function renderTree() {
      const treeEl = document.getElementById("tree");
      treeEl.innerHTML = "";

      NODES.forEach((node) => {
        const depth = getDepth(node);
        const wrap = document.createElement("div");
        wrap.className =
          "tree-node depth-" + depth + (node.id === selectedNodeId ? " selected" : "");
        wrap.style.marginLeft = depth * 26 + "px";

        const inner = document.createElement("div");
        inner.className = "tree-node-inner";

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = node.label;

        const subtitle = document.createElement("div");
        subtitle.className = "node-subtitle";
        subtitle.textContent = node.subtitle || "";

        const meta = document.createElement("div");
        meta.className = "node-meta";
        const techText =
          node.techniques && node.techniques.length
            ? node.techniques.map(prettyTag).join(" ¬∑ ")
            : "All techniques";
        const count = PROBLEMS.filter((p) =>
          problemMatchesNode(p, node)
        ).length;
        meta.textContent =
          techText + "  ‚Ä¢  " + count + " problem" + (count === 1 ? "" : "s");

        inner.appendChild(title);
        if (node.subtitle) inner.appendChild(subtitle);
        inner.appendChild(meta);
        wrap.appendChild(inner);

        wrap.addEventListener("click", () => {
          selectNode(node.id);
        });

        treeEl.appendChild(wrap);
      });
    }

    function renderProblemList() {
      const container = document.getElementById("problem-list");
      container.innerHTML = "";

      let problems = getFilteredProblems();
      problems = problems
        .slice()
        .sort(
          (a, b) =>
            a.week - b.week ||
            a.storyTitle.localeCompare(b.storyTitle)
        );

      if (!problems.length) {
        const p = document.createElement("p");
        p.className = "empty-state";
        p.textContent =
          "No problems match this combination of node + filters. Either that technique combo doesn't exist yet or you still have to add those problems.";
        container.appendChild(p);
        return;
      }

      problems.forEach((pInfo) => {
        const card = document.createElement("article");
        card.className = "problem-card";
        card.dataset.mode = globalFlipState ? "model" : "story";
        card.dataset.story = pInfo.storyTitle;
        card.dataset.model = pInfo.modelTitle;

        const header = document.createElement("div");
        header.className = "problem-header";

        const titleBox = document.createElement("div");

        const title = document.createElement("h3");
        title.className = "problem-title";
        title.textContent = globalFlipState ? pInfo.modelTitle : pInfo.storyTitle;

        const model = document.createElement("div");
        model.className = "problem-model";
        model.textContent = globalFlipState ? pInfo.storyTitle : pInfo.modelTitle;

        titleBox.appendChild(title);
        titleBox.appendChild(model);

        header.appendChild(titleBox);
        card.appendChild(header);

        const meta = document.createElement("div");
        meta.className = "problem-meta";
        meta.textContent = `Week ${pInfo.week} ¬∑ Input: ${pInfo.inputHint} ¬∑ Complexity: ${pInfo.complexity}`;
        card.appendChild(meta);

        const tagRow = document.createElement("div");
        tagRow.className = "tag-row";

        const weekTag = document.createElement("span");
        weekTag.className = "tag tag-week";
        weekTag.textContent = "Week " + pInfo.week;
        tagRow.appendChild(weekTag);

        const sizeTag = document.createElement("span");
        sizeTag.className = "tag tag-size";
        const sizeLabel = SIZE_OPTIONS.find((o) => o.value === pInfo.sizeBand);
        sizeTag.textContent = sizeLabel
          ? sizeLabel.label
          : pInfo.sizeBand;
        tagRow.appendChild(sizeTag);

        const compTag = document.createElement("span");
        compTag.className = "tag tag-complexity";
        compTag.textContent = pInfo.complexity;
        tagRow.appendChild(compTag);

        pInfo.methods.forEach((tag) => {
          const tSpan = document.createElement("span");
          tSpan.className = "tag";
          tSpan.textContent = prettyTag(tag);
          tagRow.appendChild(tSpan);
        });

        card.appendChild(tagRow);

        const linkRow = document.createElement("div");
        linkRow.className = "problem-links";

        if (pInfo.link) {
          const a = document.createElement("a");
          a.href = pInfo.link;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "Code Expert";
          linkRow.appendChild(a);
        }
        if (pInfo.video) {
          const a = document.createElement("a");
          a.href = pInfo.video;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "Video";
          linkRow.appendChild(a);
        }
        if (pInfo.pdf) {
          const a = document.createElement("a");
          a.href = pInfo.pdf;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "PDF notes";
          linkRow.appendChild(a);
        }
        if (linkRow.children.length > 0) {
          card.appendChild(linkRow);
        }

        const notes = document.createElement("div");
        notes.className = "notes";
        const notesLabel = document.createElement("div");
        notesLabel.textContent = "Your notes (intuition, reduction, tricks):";
        const textarea = document.createElement("textarea");
        const storageKey = "algolab_notes_" + pInfo.id;

        try {
          const saved = window.localStorage.getItem(storageKey);
          if (saved) textarea.value = saved;
        } catch (e) {
          // localStorage might be blocked; ignore
        }

        textarea.addEventListener("input", () => {
          try {
            window.localStorage.setItem(storageKey, textarea.value);
          } catch (e) {
            // ignore
          }
        });

        notes.appendChild(notesLabel);
        notes.appendChild(textarea);
        card.appendChild(notes);

        container.appendChild(card);
      });
    }

    // === 6. Filters UI =======================================================

    let globalFlipState = false; // false = show story, true = show model

    function initFilters() {
      const searchInput = document.getElementById("search-input");
      const weekSelect = document.getElementById("week-filter");
      const sizeSelect = document.getElementById("size-filter");
      const techContainer = document.getElementById("tech-filter");
      const globalFlipBtn = document.getElementById("global-flip");

      // Global flip button
      globalFlipBtn.addEventListener("click", () => {
        globalFlipState = !globalFlipState;
        globalFlipBtn.textContent = globalFlipState ? "Show Stories" : "Show Models";
        globalFlipBtn.classList.toggle("active", globalFlipState);
        renderProblemList();
      });

      // Week options from existing problems
      const weeks = Array.from(new Set(PROBLEMS.map((p) => p.week))).sort(
        (a, b) => a - b
      );
      const optAll = document.createElement("option");
      optAll.value = "all";
      optAll.textContent = "All weeks";
      weekSelect.appendChild(optAll);
      weeks.forEach((w) => {
        const opt = document.createElement("option");
        opt.value = String(w);
        opt.textContent = "Week " + w;
        weekSelect.appendChild(opt);
      });

      // Size options
      SIZE_OPTIONS.forEach((info) => {
        const opt = document.createElement("option");
        opt.value = info.value;
        opt.textContent = info.label;
        sizeSelect.appendChild(opt);
      });

      // Technique checkboxes
      TECHNIQUE_TAGS.forEach((tag) => {
        const label = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = tag;
        const span = document.createElement("span");
        span.textContent = prettyTag(tag);
        label.appendChild(cb);
        label.appendChild(span);
        techContainer.appendChild(label);

        cb.addEventListener("change", () => {
          if (cb.checked) filters.techniques.add(tag);
          else filters.techniques.delete(tag);
          renderProblemList();
        });
      });

      searchInput.addEventListener("input", () => {
        filters.search = searchInput.value.trim().toLowerCase();
        renderProblemList();
      });

      weekSelect.addEventListener("change", () => {
        filters.week = weekSelect.value;
        renderProblemList();
      });

      sizeSelect.addEventListener("change", () => {
        filters.size = sizeSelect.value;
        renderProblemList();
      });
    }

    // === 7. Tab Switching ====================================================

    function initTabs() {
      const tabBtns = document.querySelectorAll('.tab-btn');
      const tabContents = document.querySelectorAll('.tab-content');

      tabBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          const targetTab = btn.dataset.tab;
          
          // Remove active class from all tabs and buttons
          tabBtns.forEach(b => b.classList.remove('active'));
          tabContents.forEach(content => content.classList.remove('active'));
          
          // Add active class to clicked button and target content
          btn.classList.add('active');
          const targetContent = document.getElementById(targetTab);
          targetContent.classList.add('active');
          
          // If switching to graph view, render the graph and scroll to it
          if (targetTab === 'graph-view') {
            renderGraph();
            // Smooth scroll to graph view
            setTimeout(() => {
              targetContent.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 50);
          }
        });
      });
    }

    // === 8. Graph Visualization ==============================================

    let graphState = {
      scale: 1,
      translateX: 0,
      translateY: 0,
      isDragging: false,
      dragStart: { x: 0, y: 0 }
    };

    function renderGraph() {
      const svg = document.getElementById('graph-canvas');
      const container = document.getElementById('graph-container');
      
      // Set SVG dimensions
      const width = container.clientWidth;
      const height = container.clientHeight;
      svg.setAttribute('width', width);
      svg.setAttribute('height', height);
      
      // Clear existing content
      svg.innerHTML = '';
      
      // Create main group for zoom/pan
      const mainGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      mainGroup.id = 'main-graph-group';
      svg.appendChild(mainGroup);
      
      // Build graph data structure
      const graphData = buildGraphData();
      
      // Calculate layout
      const layout = calculateGraphLayout(graphData, width, height);
      
      // Draw edges first (so they appear behind nodes)
      drawEdges(mainGroup, layout.edges);
      
      // Draw nodes
      drawNodes(mainGroup, layout.nodes);
      
      // Setup zoom/pan controls
      setupGraphControls(svg, mainGroup);
    }

    function buildGraphData() {
      const nodes = [];
      const edges = [];
      const nodeMap = new Map();
      
      // Add technique nodes
      NODES.forEach((node, idx) => {
        const graphNode = {
          id: node.id,
          label: node.label,
          type: node.parent ? 'sub-technique' : 'technique',
          parent: node.parent,
          techniques: node.techniques || [],
          level: 0
        };
        nodes.push(graphNode);
        nodeMap.set(node.id, graphNode);
      });
      
      // Calculate levels (depth in tree)
      nodes.forEach(node => {
        let level = 0;
        let current = node;
        while (current.parent) {
          level++;
          current = nodeMap.get(current.parent);
          if (!current) break;
        }
        node.level = level;
      });
      
      // Add edges between technique nodes
      NODES.forEach(node => {
        if (node.parent && nodeMap.has(node.parent)) {
          edges.push({
            source: node.parent,
            target: node.id,
            type: 'hierarchy'
          });
        }
      });
      
      // Add problem nodes
      PROBLEMS.forEach((problem, idx) => {
        const problemNode = {
          id: 'problem-' + idx,
          label: problem.storyTitle,
          modelTitle: problem.modelTitle,
          type: 'problem',
          methods: problem.methods,
          week: problem.week,
          level: 999 // Problems at bottom
        };
        nodes.push(problemNode);
        nodeMap.set(problemNode.id, problemNode);
        
        // Connect to technique nodes
        problem.methods.forEach(method => {
          // Find nodes that contain this technique
          NODES.forEach(techNode => {
            if (techNode.techniques && techNode.techniques.includes(method)) {
              edges.push({
                source: techNode.id,
                target: problemNode.id,
                type: 'uses',
                method: method
              });
            }
          });
        });
      });
      
      return { nodes, edges, nodeMap };
    }

    function calculateGraphLayout(graphData, width, height) {
      const { nodes, edges } = graphData;
      
      // Group nodes by level
      const levels = {};
      nodes.forEach(node => {
        if (!levels[node.level]) levels[node.level] = [];
        levels[node.level].push(node);
      });
      
      const levelKeys = Object.keys(levels).map(Number).sort((a, b) => a - b);
      const levelHeight = height / (levelKeys.length + 1);
      
      // Position nodes
      const layoutNodes = [];
      levelKeys.forEach((level, levelIdx) => {
        const nodesAtLevel = levels[level];
        const spacing = width / (nodesAtLevel.length + 1);
        
        nodesAtLevel.forEach((node, idx) => {
          layoutNodes.push({
            ...node,
            x: spacing * (idx + 1),
            y: levelHeight * (levelIdx + 1)
          });
        });
      });
      
      // Position edges
      const layoutEdges = edges.map(edge => {
        const source = layoutNodes.find(n => n.id === edge.source);
        const target = layoutNodes.find(n => n.id === edge.target);
        return {
          ...edge,
          x1: source.x,
          y1: source.y,
          x2: target.x,
          y2: target.y
        };
      });
      
      return { nodes: layoutNodes, edges: layoutEdges };
    }

    function drawEdges(container, edges) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '10');
      marker.setAttribute('refX', '9');
      marker.setAttribute('refY', '3');
      marker.setAttribute('orient', 'auto');
      
      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3, 0 6');
      polygon.setAttribute('fill', '#86868b');
      marker.appendChild(polygon);
      defs.appendChild(marker);
      container.appendChild(defs);
      
      edges.forEach(edge => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', edge.x1);
        line.setAttribute('y1', edge.y1);
        line.setAttribute('x2', edge.x2);
        line.setAttribute('y2', edge.y2);
        line.setAttribute('stroke', edge.type === 'hierarchy' ? '#6e6e73' : '#2c2c2e');
        line.setAttribute('stroke-width', edge.type === 'hierarchy' ? '2' : '1');
        line.setAttribute('marker-end', 'url(#arrowhead)');
        line.setAttribute('opacity', '0.5');
        container.appendChild(line);
      });
    }

    function drawNodes(container, nodes) {
      nodes.forEach(node => {
        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        group.setAttribute('transform', `translate(${node.x}, ${node.y})`);
        group.style.cursor = 'pointer';
        
        // All nodes are rectangles for better readability
        const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
        
        let rectWidth, rectHeight, fillColor;
        
        if (node.type === 'problem') {
          rectWidth = 140;
          rectHeight = 70;
          fillColor = '#f5f5f7';
        } else if (node.type === 'technique') {
          rectWidth = 120;
          rectHeight = 60;
          fillColor = '#ffffff';
        } else {
          rectWidth = 110;
          rectHeight = 55;
          fillColor = '#86868b';
        }
        
        rect.setAttribute('x', -rectWidth / 2);
        rect.setAttribute('y', -rectHeight / 2);
        rect.setAttribute('width', rectWidth);
        rect.setAttribute('height', rectHeight);
        rect.setAttribute('rx', '10');
        rect.setAttribute('fill', fillColor);
        rect.setAttribute('stroke', '#2c2c2e');
        rect.setAttribute('stroke-width', '2');
        group.appendChild(rect);
        
        // Label with better text wrapping
        const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
        text.setAttribute('text-anchor', 'middle');
        text.setAttribute('y', '0');
        text.setAttribute('dominant-baseline', 'middle');
        text.setAttribute('fill', node.type === 'sub-technique' ? '#ffffff' : '#000000');
        text.setAttribute('font-size', node.type === 'problem' ? '12' : '13');
        text.setAttribute('font-weight', '500');
        
        // Wrap text if too long
        const maxChars = node.type === 'problem' ? 18 : 15;
        const words = node.label.split(' ');
        let lines = [];
        let currentLine = '';
        
        words.forEach(word => {
          if ((currentLine + word).length > maxChars && currentLine.length > 0) {
            lines.push(currentLine.trim());
            currentLine = word + ' ';
          } else {
            currentLine += word + ' ';
          }
        });
        if (currentLine.trim()) lines.push(currentLine.trim());
        
        if (lines.length === 1) {
          text.textContent = lines[0];
          group.appendChild(text);
        } else {
          // Multiple lines
          lines.slice(0, 2).forEach((line, i) => {
            const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
            tspan.setAttribute('x', '0');
            tspan.setAttribute('dy', i === 0 ? '-0.4em' : '1.2em');
            tspan.textContent = line.length > maxChars ? line.substring(0, maxChars - 2) + '...' : line;
            text.appendChild(tspan);
          });
          group.appendChild(text);
        }
        
        // Hover tooltip
        const title = document.createElementNS('http://www.w3.org/2000/svg', 'title');
        title.textContent = node.type === 'problem' ? 
          `${node.label}\nModel: ${node.modelTitle}\nWeek ${node.week}` : 
          node.label;
        group.appendChild(title);
        
        // Click interaction
        group.addEventListener('click', () => {
          if (node.type === 'problem') {
            // Switch to list view and highlight this problem
            document.querySelector('[data-tab="list-view"]').click();
            setTimeout(() => {
              const problemCards = document.querySelectorAll('.problem-card');
              problemCards.forEach(card => {
                if (card.dataset.story === node.label) {
                  card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                  card.style.outline = '3px solid #ffffff';
                  setTimeout(() => {
                    card.style.outline = '';
                  }, 2000);
                }
              });
            }, 300);
          } else {
            // Filter by this technique
            selectNode(node.id);
            document.querySelector('[data-tab="list-view"]').click();
          }
        });
        
        container.appendChild(group);
      });
    }

    function setupGraphControls(svg, mainGroup) {
      const zoomIn = document.getElementById('zoom-in');
      const zoomOut = document.getElementById('zoom-out');
      const resetView = document.getElementById('reset-view');
      
      function updateTransform() {
        mainGroup.setAttribute('transform', 
          `translate(${graphState.translateX}, ${graphState.translateY}) scale(${graphState.scale})`
        );
      }
      
      zoomIn.addEventListener('click', () => {
        graphState.scale = Math.min(graphState.scale * 1.2, 3);
        updateTransform();
      });
      
      zoomOut.addEventListener('click', () => {
        graphState.scale = Math.max(graphState.scale / 1.2, 0.3);
        updateTransform();
      });
      
      resetView.addEventListener('click', () => {
        graphState.scale = 1;
        graphState.translateX = 0;
        graphState.translateY = 0;
        updateTransform();
      });
      
      // Pan functionality
      svg.addEventListener('mousedown', (e) => {
        graphState.isDragging = true;
        graphState.dragStart = { x: e.clientX - graphState.translateX, y: e.clientY - graphState.translateY };
      });
      
      svg.addEventListener('mousemove', (e) => {
        if (graphState.isDragging) {
          graphState.translateX = e.clientX - graphState.dragStart.x;
          graphState.translateY = e.clientY - graphState.dragStart.y;
          updateTransform();
        }
      });
      
      svg.addEventListener('mouseup', () => {
        graphState.isDragging = false;
      });
      
      svg.addEventListener('mouseleave', () => {
        graphState.isDragging = false;
      });
      
      // Zoom with mouse wheel
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        graphState.scale = Math.min(Math.max(graphState.scale * delta, 0.3), 3);
        updateTransform();
      });
    }

    // === 9. Init =============================================================

    function loadQuizStats() {
      try {
        const saved = localStorage.getItem('algolab_quiz_progress');
        if (saved) {
          const data = JSON.parse(saved);
          
          // Update total exercises (count from data)
          const totalExercises = 34; // Updated count with new exercises
          document.getElementById('total-exercises').textContent = totalExercises;
          
          // Count mastered exercises (80%+ accuracy with 3+ consecutive correct)
          let masteredCount = 0;
          for (const exerciseName in data.exercises) {
            const ex = data.exercises[exerciseName];
            const successRate = ex.correct / (ex.correct + ex.incorrect);
            if (successRate >= 0.8 && ex.consecutiveCorrect >= 3) {
              masteredCount++;
            }
          }
          document.getElementById('completed-exercises').textContent = masteredCount;
          
          // Update streak
          document.getElementById('quiz-streak').textContent = data.currentStreak || 0;
        }
      } catch (e) {
        console.error('Error loading quiz stats:', e);
      }
    }

    function init() {
      initTabs();
      initFilters();
      renderTree();
      renderProblemList();
      loadQuizStats();
    }

    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
