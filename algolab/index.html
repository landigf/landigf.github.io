<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Algolab Problem Map</title>
  <style>
    :root {
      --bg: #050816;
      --panel: #111827;
      --card: #1f2937;
      --accent: #6366f1;
      --accent-soft: #22d3ee;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --tag-bg: #374151;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "SF Pro Text",
        "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #0f172a 0, #020617 55%, #000 100%);
      color: var(--text-main);
    }

    #app {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 16px 24px;
      border-bottom: 1px solid #111827;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0;
      font-size: 1.3rem;
      font-weight: 600;
    }

    header p {
      margin: 4px 0 0;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    main.layout {
      display: flex;
      flex: 1;
      min-height: 0;
    }

    .tree-panel {
      width: 32%;
      min-width: 260px;
      max-width: 420px;
      border-right: 1px solid #111827;
      background: linear-gradient(to bottom, #020617, #020617);
      padding: 16px 16px 24px;
      overflow-y: auto;
    }

    .list-panel {
      flex: 1;
      padding: 16px 24px 24px;
      overflow-y: auto;
    }

    .tree-panel h2,
    .list-panel h2 {
      margin: 0 0 6px;
      font-size: 0.95rem;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: #9ca3af;
    }

    .tree-description {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    /* Tree nodes */

    #tree {
      margin-top: 4px;
    }

    .tree-node {
      position: relative;
      margin: 6px 0;
      cursor: pointer;
      transition: transform 0.08s ease, box-shadow 0.12s ease,
        background 0.12s ease;
      border-radius: 999px;
      padding: 1px;
      background: linear-gradient(135deg, var(--accent), var(--accent-soft));
      box-shadow: 0 10px 15px rgba(0, 0, 0, 0.35);
    }

    .tree-node-inner {
      border-radius: 999px;
      padding: 7px 10px;
      background: rgba(15, 23, 42, 0.96);
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .tree-node .node-title {
      font-size: 0.9rem;
      font-weight: 600;
    }

    .tree-node .node-subtitle {
      font-size: 0.78rem;
      color: #a5b4fc;
    }

    .tree-node .node-meta {
      font-size: 0.7rem;
      color: #e0f2fe;
    }

    .tree-node.selected {
      box-shadow: 0 0 0 2px #f97316, 0 15px 25px rgba(0, 0, 0, 0.5);
      transform: translateX(2px);
    }

    .tree-node::before {
      content: "";
      position: absolute;
      left: -14px;
      top: 50%;
      width: 10px;
      height: 1px;
      background: #374151;
      opacity: 0.8;
    }

    .tree-node.depth-0::before {
      display: none;
    }

    /* Filters */

    .filters {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 12px;
      align-items: center;
    }

    .filters input[type="search"] {
      flex: 1 1 220px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: inherit;
      font-size: 0.85rem;
      outline: none;
    }

    .filters input[type="search"]:focus {
      border-color: var(--accent-soft);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.5);
    }

    .filters select {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #374151;
      background: #020617;
      color: inherit;
      font-size: 0.8rem;
      outline: none;
    }

    .filters select:focus {
      border-color: var(--accent-soft);
    }

    .tech-filter-label {
      font-size: 0.75rem;
      color: var(--text-muted);
      width: 100%;
      margin-top: 4px;
    }

    #tech-filter {
      width: 100%;
      max-height: 88px;
      overflow-y: auto;
      margin-top: 2px;
      border-radius: 10px;
      padding: 3px 4px;
      background: #020617;
      border: 1px solid #111827;
    }

    #tech-filter label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      font-size: 0.72rem;
      color: #e5e7eb;
      margin: 2px 4px 2px 0;
      padding: 2px 7px;
      border-radius: 999px;
      background: #111827;
      cursor: pointer;
    }

    #tech-filter input[type="checkbox"] {
      accent-color: var(--accent);
      cursor: pointer;
    }

    /* Problem list */

    #problem-list {
      margin-top: 4px;
    }

    .problem-card {
      background: var(--card);
      border-radius: 18px;
      padding: 12px 14px;
      margin-bottom: 12px;
      box-shadow: 0 8px 12px rgba(0, 0, 0, 0.28);
      border: 1px solid #111827;
    }

    .problem-header {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      align-items: flex-start;
    }

    .problem-title {
      margin: 0;
      font-size: 1rem;
      font-weight: 600;
    }

    .problem-model {
      margin-top: 2px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .problem-meta {
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 4px;
    }

    .tag-row {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .tag {
      font-size: 0.7rem;
      padding: 2px 6px;
      border-radius: 999px;
      background: var(--tag-bg);
      color: #e5e7eb;
      white-space: nowrap;
    }

    .tag-week {
      background: #047857;
    }

    .tag-size {
      background: #1d4ed8;
    }

    .tag-complexity {
      background: #a855f7;
    }

    .problem-links {
      margin-top: 6px;
      font-size: 0.75rem;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .problem-links a {
      color: #e5e7eb;
      text-decoration: none;
      opacity: 0.85;
    }

    .problem-links a:hover {
      opacity: 1;
      text-decoration: underline;
    }

    .flip-btn {
      margin-top: 2px;
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 999px;
      border: 0;
      background: #f97316;
      color: #000;
      cursor: pointer;
      white-space: nowrap;
    }

    .flip-btn:hover {
      filter: brightness(1.05);
    }

    .notes {
      margin-top: 8px;
      font-size: 0.76rem;
    }

    .notes textarea {
      width: 100%;
      min-height: 60px;
      max-height: 180px;
      border-radius: 10px;
      padding: 6px 8px;
      border: 1px solid #4b5563;
      background: #020617;
      color: inherit;
      font-size: 0.75rem;
      resize: vertical;
    }

    .empty-state {
      margin-top: 16px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    @media (max-width: 900px) {
      main.layout {
        flex-direction: column;
      }
      .tree-panel {
        width: 100%;
        max-width: none;
        border-right: none;
        border-bottom: 1px solid #111827;
      }
    }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Algolab Problem Map</h1>
      <p>
        Click a technique node to see all problems that use that pattern.
        For each problem you can flip between story name and "model name".
      </p>
    </header>

    <main class="layout">
      <section class="tree-panel">
        <h2>Technique map</h2>
        <div class="tree-description">
          Rough decision tree: start from the top, follow what the input &amp; constraints suggest
          (arrays, intervals, graphs, flows, geometry, DP, …).
        </div>
        <div id="tree"></div>
      </section>

      <section class="list-panel">
        <h2>Problems</h2>
        <div class="filters">
          <input
            type="search"
            id="search-input"
            placeholder="Search by story name or model (e.g. 'interval scheduling')"
          />
          <select id="week-filter"></select>
          <select id="size-filter"></select>
          <div class="tech-filter-label">
            Extra technique filters (ANDed with node):
          </div>
          <div id="tech-filter"></div>
        </div>

        <div id="problem-list"></div>
      </section>
    </main>
  </div>

  <script>
    // === 1. Tags / enums ====================================================

    const TECHNIQUE_TAGS = [
      "brute force",
      "greedy",
      "split & list",
      "backtracking",
      "dp",
      "sliding window",
      "two pointers",
      "binary search",
      "intervals",
      "priority queue",
      "graph components",
      "mst",
      "bfs",
      "dfs",
      "shortest path",
      "maximum matching",
      "network flows",
      "min-cost flows",
      "delaunay triangulation",
      "minimum enclosing circle",
      "linear programming",
      "geometry"
    ];

    const SIZE_OPTIONS = [
      { value: "all", label: "Any input size" },
      { value: "tiny", label: "Up to ~10³" },
      { value: "small", label: "Up to ~10⁴" },
      { value: "medium", label: "Up to ~10⁵" },
      { value: "large", label: "Up to ~10⁶ or more" }
    ];

    // === 2. Problem data =====================================================

    // Fill / extend this with all Algolab problems.
    // Keep tags in lower case to match TECHNIQUE_TAGS.
    const PROBLEMS = [
      {
        id: "deck-of-cards",
        storyTitle: "Deck of Cards (simplified)",
        modelTitle: "Sliding window for subarray with sum exactly k",
        week: 2,
        methods: ["sliding window", "two pointers"],
        sizeBand: "medium",
        inputHint: "n up to 10^5, non-negative values",
        complexity: "O(n)",
        link: "", // put Code Expert link here
        video: "",
        pdf: ""
      },
      {
        id: "lord-voldemort",
        storyTitle: "Lord Voldemort",
        modelTitle:
          "Weighted interval scheduling with cardinality constraint",
        week: 5,
        methods: ["dp", "intervals", "binary search", "greedy"],
        sizeBand: "medium",
        inputHint: "n up to 2·10^5, k small (e.g. ≤ 10)",
        complexity: "O(n log n · k)",
        link: "",
        video: "",
        pdf: ""
      },
      {
        id: "clues",
        storyTitle: "Clues",
        modelTitle:
          "Delaunay triangulation + graph components / 2-coloring",
        week: 7,
        methods: ["geometry", "delaunay triangulation", "graph components", "bfs"],
        sizeBand: "large",
        inputHint: "n, m up to 9·10^4, coordinates up to 2^24",
        complexity: "O((n + m) log n)",
        link: "",
        video: "",
        pdf: ""
      }
    ];

    // === 3. Technique tree ===================================================

    const NODES = [
      {
        id: "root",
        label: "All Algolab problems",
        subtitle: "No restriction, just all stories",
        techniques: [],
        parent: null
      },
      {
        id: "arrays-basic",
        label: "Arrays / prefix sums",
        subtitle: "Brute force → prefix sums → two pointers",
        techniques: ["brute force"],
        parent: "root"
      },
      {
        id: "sliding-window",
        label: "Sliding window",
        subtitle: "Two pointers on contiguous subarrays",
        techniques: ["sliding window"],
        parent: "arrays-basic"
      },
      {
        id: "greedy",
        label: "Greedy",
        subtitle: "Sort + local choices",
        techniques: ["greedy"],
        parent: "root"
      },
      {
        id: "intervals",
        label: "Intervals & scheduling",
        subtitle: "Sorting endpoints, sweepline, DP",
        techniques: ["intervals"],
        parent: "greedy"
      },
      {
        id: "dp",
        label: "Dynamic programming",
        subtitle: "States, transitions, objective",
        techniques: ["dp"],
        parent: "root"
      },
      {
        id: "dp-intervals",
        label: "DP + intervals",
        subtitle: "Weighted interval scheduling & friends",
        techniques: ["dp", "intervals"],
        parent: "dp"
      },
      {
        id: "graphs",
        label: "Graphs",
        subtitle: "Components, BFS/DFS, MST, etc.",
        techniques: ["graph components"],
        parent: "root"
      },
      {
        id: "shortest-path",
        label: "Shortest paths",
        subtitle: "Dijkstra & variants",
        techniques: ["shortest path"],
        parent: "graphs"
      },
      {
        id: "flows",
        label: "Flows / matchings",
        subtitle: "Max flow, min cut, matchings",
        techniques: ["network flows"],
        parent: "graphs"
      },
      {
        id: "geometry",
        label: "Geometry / CGAL",
        subtitle: "Delaunay, MEC, LP on steroids",
        techniques: ["geometry"],
        parent: "root"
      }
    ];

    const NODE_MAP = {};
    NODES.forEach((n) => (NODE_MAP[n.id] = n));
    NODES.forEach((n) => (n.children = []));
    NODES.forEach((n) => {
      if (n.parent) NODE_MAP[n.parent].children.push(n.id);
    });

    let selectedNodeId = "root";

    const filters = {
      search: "",
      week: "all",
      size: "all",
      techniques: new Set()
    };

    // === 4. Helpers ==========================================================

    function prettyTag(tag) {
      if (tag === "dp") return "DP";
      if (tag === "mst") return "MST";
      if (tag === "bfs") return "BFS";
      if (tag === "dfs") return "DFS";
      if (tag === "shortest path") return "Shortest path (Dijkstra)";
      if (tag === "min-cost flows") return "Min-cost flows";
      return tag
        .split(" ")
        .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
        .join(" ");
    }

    function getDepth(node) {
      let d = 0;
      let cur = node;
      while (cur.parent) {
        d++;
        cur = NODE_MAP[cur.parent];
      }
      return d;
    }

    function problemMatchesNode(problem, node) {
      if (!node.techniques || node.techniques.length === 0) return true;
      // Node means: problem must contain all these technique tags
      return node.techniques.every((t) => problem.methods.includes(t));
    }

    function problemMatchesFilters(problem) {
      if (filters.week !== "all" && problem.week !== Number(filters.week)) {
        return false;
      }
      if (filters.size !== "all" && problem.sizeBand !== filters.size) {
        return false;
      }
      if (filters.techniques.size) {
        for (const t of filters.techniques) {
          if (!problem.methods.includes(t)) return false;
        }
      }
      if (filters.search) {
        const hay = (
          problem.storyTitle +
          " " +
          problem.modelTitle
        ).toLowerCase();
        if (!hay.includes(filters.search)) return false;
      }
      return true;
    }

    function getFilteredProblems() {
      const node = NODE_MAP[selectedNodeId];
      return PROBLEMS.filter(
        (p) => problemMatchesNode(p, node) && problemMatchesFilters(p)
      );
    }

    // === 5. Rendering ========================================================

    function renderTree() {
      const treeEl = document.getElementById("tree");
      treeEl.innerHTML = "";

      NODES.forEach((node) => {
        const depth = getDepth(node);
        const wrap = document.createElement("div");
        wrap.className =
          "tree-node depth-" + depth + (node.id === selectedNodeId ? " selected" : "");
        wrap.style.marginLeft = depth * 26 + "px";

        const inner = document.createElement("div");
        inner.className = "tree-node-inner";

        const title = document.createElement("div");
        title.className = "node-title";
        title.textContent = node.label;

        const subtitle = document.createElement("div");
        subtitle.className = "node-subtitle";
        subtitle.textContent = node.subtitle || "";

        const meta = document.createElement("div");
        meta.className = "node-meta";
        const techText =
          node.techniques && node.techniques.length
            ? node.techniques.map(prettyTag).join(" · ")
            : "All techniques";
        const count = PROBLEMS.filter((p) =>
          problemMatchesNode(p, node)
        ).length;
        meta.textContent =
          techText + "  •  " + count + " problem" + (count === 1 ? "" : "s");

        inner.appendChild(title);
        if (node.subtitle) inner.appendChild(subtitle);
        inner.appendChild(meta);
        wrap.appendChild(inner);

        wrap.addEventListener("click", () => {
          selectedNodeId = node.id;
          renderTree();
          renderProblemList();
        });

        treeEl.appendChild(wrap);
      });
    }

    function renderProblemList() {
      const container = document.getElementById("problem-list");
      container.innerHTML = "";

      let problems = getFilteredProblems();
      problems = problems
        .slice()
        .sort(
          (a, b) =>
            a.week - b.week ||
            a.storyTitle.localeCompare(b.storyTitle)
        );

      if (!problems.length) {
        const p = document.createElement("p");
        p.className = "empty-state";
        p.textContent =
          "No problems match this combination of node + filters. Either that technique combo doesn't exist yet or you still have to add those problems.";
        container.appendChild(p);
        return;
      }

      problems.forEach((pInfo) => {
        const card = document.createElement("article");
        card.className = "problem-card";
        card.dataset.mode = "story";
        card.dataset.story = pInfo.storyTitle;
        card.dataset.model = pInfo.modelTitle;

        const header = document.createElement("div");
        header.className = "problem-header";

        const titleBox = document.createElement("div");

        const title = document.createElement("h3");
        title.className = "problem-title";
        title.textContent = pInfo.storyTitle;

        const model = document.createElement("div");
        model.className = "problem-model";
        model.textContent = pInfo.modelTitle;

        titleBox.appendChild(title);
        titleBox.appendChild(model);

        const rightBox = document.createElement("div");
        const flipBtn = document.createElement("button");
        flipBtn.className = "flip-btn";
        flipBtn.textContent = "Flip";
        flipBtn.title =
          "Switch which name is primary: story vs. underlying model";
        rightBox.appendChild(flipBtn);

        header.appendChild(titleBox);
        header.appendChild(rightBox);
        card.appendChild(header);

        const meta = document.createElement("div");
        meta.className = "problem-meta";
        meta.textContent = `Week ${pInfo.week} · Input: ${pInfo.inputHint} · Complexity: ${pInfo.complexity}`;
        card.appendChild(meta);

        const tagRow = document.createElement("div");
        tagRow.className = "tag-row";

        const weekTag = document.createElement("span");
        weekTag.className = "tag tag-week";
        weekTag.textContent = "Week " + pInfo.week;
        tagRow.appendChild(weekTag);

        const sizeTag = document.createElement("span");
        sizeTag.className = "tag tag-size";
        const sizeLabel = SIZE_OPTIONS.find((o) => o.value === pInfo.sizeBand);
        sizeTag.textContent = sizeLabel
          ? sizeLabel.label
          : pInfo.sizeBand;
        tagRow.appendChild(sizeTag);

        const compTag = document.createElement("span");
        compTag.className = "tag tag-complexity";
        compTag.textContent = pInfo.complexity;
        tagRow.appendChild(compTag);

        pInfo.methods.forEach((tag) => {
          const tSpan = document.createElement("span");
          tSpan.className = "tag";
          tSpan.textContent = prettyTag(tag);
          tagRow.appendChild(tSpan);
        });

        card.appendChild(tagRow);

        const linkRow = document.createElement("div");
        linkRow.className = "problem-links";

        if (pInfo.link) {
          const a = document.createElement("a");
          a.href = pInfo.link;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "Code Expert";
          linkRow.appendChild(a);
        }
        if (pInfo.video) {
          const a = document.createElement("a");
          a.href = pInfo.video;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "Video";
          linkRow.appendChild(a);
        }
        if (pInfo.pdf) {
          const a = document.createElement("a");
          a.href = pInfo.pdf;
          a.target = "_blank";
          a.rel = "noopener noreferrer";
          a.textContent = "PDF notes";
          linkRow.appendChild(a);
        }
        if (linkRow.children.length > 0) {
          card.appendChild(linkRow);
        }

        const notes = document.createElement("div");
        notes.className = "notes";
        const notesLabel = document.createElement("div");
        notesLabel.textContent = "Your notes (intuition, reduction, tricks):";
        const textarea = document.createElement("textarea");
        const storageKey = "algolab_notes_" + pInfo.id;

        try {
          const saved = window.localStorage.getItem(storageKey);
          if (saved) textarea.value = saved;
        } catch (e) {
          // localStorage might be blocked; ignore
        }

        textarea.addEventListener("input", () => {
          try {
            window.localStorage.setItem(storageKey, textarea.value);
          } catch (e) {
            // ignore
          }
        });

        notes.appendChild(notesLabel);
        notes.appendChild(textarea);
        card.appendChild(notes);

        flipBtn.addEventListener("click", () => {
          const mode =
            card.dataset.mode === "story" ? "model" : "story";
          card.dataset.mode = mode;
          if (mode === "story") {
            title.textContent = card.dataset.story;
            model.textContent = card.dataset.model;
          } else {
            title.textContent = card.dataset.model;
            model.textContent = card.dataset.story;
          }
        });

        container.appendChild(card);
      });
    }

    // === 6. Filters UI =======================================================

    function initFilters() {
      const searchInput = document.getElementById("search-input");
      const weekSelect = document.getElementById("week-filter");
      const sizeSelect = document.getElementById("size-filter");
      const techContainer = document.getElementById("tech-filter");

      // Week options from existing problems
      const weeks = Array.from(new Set(PROBLEMS.map((p) => p.week))).sort(
        (a, b) => a - b
      );
      const optAll = document.createElement("option");
      optAll.value = "all";
      optAll.textContent = "All weeks";
      weekSelect.appendChild(optAll);
      weeks.forEach((w) => {
        const opt = document.createElement("option");
        opt.value = String(w);
        opt.textContent = "Week " + w;
        weekSelect.appendChild(opt);
      });

      // Size options
      SIZE_OPTIONS.forEach((info) => {
        const opt = document.createElement("option");
        opt.value = info.value;
        opt.textContent = info.label;
        sizeSelect.appendChild(opt);
      });

      // Technique checkboxes
      TECHNIQUE_TAGS.forEach((tag) => {
        const label = document.createElement("label");
        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.value = tag;
        const span = document.createElement("span");
        span.textContent = prettyTag(tag);
        label.appendChild(cb);
        label.appendChild(span);
        techContainer.appendChild(label);

        cb.addEventListener("change", () => {
          if (cb.checked) filters.techniques.add(tag);
          else filters.techniques.delete(tag);
          renderProblemList();
        });
      });

      searchInput.addEventListener("input", () => {
        filters.search = searchInput.value.trim().toLowerCase();
        renderProblemList();
      });

      weekSelect.addEventListener("change", () => {
        filters.week = weekSelect.value;
        renderProblemList();
      });

      sizeSelect.addEventListener("change", () => {
        filters.size = sizeSelect.value;
        renderProblemList();
      });
    }

    // === 7. Init =============================================================

    function init() {
      initFilters();
      renderTree();
      renderProblemList();
    }

    window.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
